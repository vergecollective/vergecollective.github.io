 ! function (t) {
    var e = {};

    function n(i) {
        if (e[i]) return e[i].exports;
        var r = e[i] = {
            i: i,
            l: !1,
            exports: {}
        };
        return t[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports
    }
    n.m = t, n.c = e, n.d = function (t, e, i) {
        n.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: i
        })
    }, n.r = function (t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, n.t = function (t, e) {
        if (1 & e && (t = n(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var i = Object.create(null);
        if (n.r(i), Object.defineProperty(i, "default", {
                enumerable: !0,
                value: t
            }), 2 & e && "string" != typeof t)
            for (var r in t) n.d(i, r, function (e) {
                return t[e]
            }.bind(null, r));
        return i
    }, n.n = function (t) {
        var e = t && t.__esModule ? function () {
            return t.default
        } : function () {
            return t
        };
        return n.d(e, "a", e), e
    }, n.o = function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, n.p = "/dist/", n(n.s = 4)
}([function (module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    "undefined" != typeof navigator && function (t, e) {
        void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return e(t)
        }.call(exports, __webpack_require__, exports, module)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
    }(window || {}, (function (window) {
        "use strict";
        var svgNS = "http://www.w3.org/2000/svg",
            locationHref = "",
            initialDefaultFrame = -999999,
            subframeEnabled = !0,
            expressionsPlugin, isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
            cachedColors = {},
            bm_rounder = Math.round,
            bm_rnd, bm_pow = Math.pow,
            bm_sqrt = Math.sqrt,
            bm_abs = Math.abs,
            bm_floor = Math.floor,
            bm_max = Math.max,
            bm_min = Math.min,
            blitter = 10,
            BMMath = {};

        function ProjectInterface() {
            return {}
        }! function () {
            var t, e = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"],
                n = e.length;
            for (t = 0; t < n; t += 1) BMMath[e[t]] = Math[e[t]]
        }(), BMMath.random = Math.random, BMMath.abs = function (t) {
            if ("object" === typeof t && t.length) {
                var e, n = createSizedArray(t.length),
                    i = t.length;
                for (e = 0; e < i; e += 1) n[e] = Math.abs(t[e]);
                return n
            }
            return Math.abs(t)
        };
        var defaultCurveSegments = 150,
            degToRads = Math.PI / 180,
            roundCorner = .5519;

        function roundValues(t) {
            bm_rnd = t ? Math.round : function (t) {
                return t
            }
        }

        function styleDiv(t) {
            t.style.position = "absolute", t.style.top = 0, t.style.left = 0, t.style.display = "block", t.style.transformOrigin = t.style.webkitTransformOrigin = "0 0", t.style.backfaceVisibility = t.style.webkitBackfaceVisibility = "visible", t.style.transformStyle = t.style.webkitTransformStyle = t.style.mozTransformStyle = "preserve-3d"
        }

        function BMEnterFrameEvent(t, e, n, i) {
            this.type = t, this.currentTime = e, this.totalTime = n, this.direction = i < 0 ? -1 : 1
        }

        function BMCompleteEvent(t, e) {
            this.type = t, this.direction = e < 0 ? -1 : 1
        }

        function BMCompleteLoopEvent(t, e, n, i) {
            this.type = t, this.currentLoop = n, this.totalLoops = e, this.direction = i < 0 ? -1 : 1
        }

        function BMSegmentStartEvent(t, e, n) {
            this.type = t, this.firstFrame = e, this.totalFrames = n
        }

        function BMDestroyEvent(t, e) {
            this.type = t, this.target = e
        }

        function BMRenderFrameErrorEvent(t, e) {
            this.type = "renderFrameError", this.nativeError = t, this.currentTime = e
        }

        function BMConfigErrorEvent(t) {
            this.type = "configError", this.nativeError = t
        }

        function BMAnimationConfigErrorEvent(t, e) {
            this.type = t, this.nativeError = e, this.currentTime = currentTime
        }
        roundValues(!1);
        var createElementID = (_count = 0, function () {
                return "__lottie_element_" + ++_count
            }),
            _count;

        function HSVtoRGB(t, e, n) {
            var i, r, a, s, o, l, h, u;
            switch (l = n * (1 - e), h = n * (1 - (o = 6 * t - (s = Math.floor(6 * t))) * e), u = n * (1 - (1 - o) * e), s % 6) {
                case 0:
                    i = n, r = u, a = l;
                    break;
                case 1:
                    i = h, r = n, a = l;
                    break;
                case 2:
                    i = l, r = n, a = u;
                    break;
                case 3:
                    i = l, r = h, a = n;
                    break;
                case 4:
                    i = u, r = l, a = n;
                    break;
                case 5:
                    i = n, r = l, a = h
            }
            return [i, r, a]
        }

        function RGBtoHSV(t, e, n) {
            var i, r = Math.max(t, e, n),
                a = Math.min(t, e, n),
                s = r - a,
                o = 0 === r ? 0 : s / r,
                l = r / 255;
            switch (r) {
                case a:
                    i = 0;
                    break;
                case t:
                    i = e - n + s * (e < n ? 6 : 0), i /= 6 * s;
                    break;
                case e:
                    i = n - t + 2 * s, i /= 6 * s;
                    break;
                case n:
                    i = t - e + 4 * s, i /= 6 * s
            }
            return [i, o, l]
        }

        function addSaturationToRGB(t, e) {
            var n = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
            return n[1] += e, n[1] > 1 ? n[1] = 1 : n[1] <= 0 && (n[1] = 0), HSVtoRGB(n[0], n[1], n[2])
        }

        function addBrightnessToRGB(t, e) {
            var n = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
            return n[2] += e, n[2] > 1 ? n[2] = 1 : n[2] < 0 && (n[2] = 0), HSVtoRGB(n[0], n[1], n[2])
        }

        function addHueToRGB(t, e) {
            var n = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
            return n[0] += e / 360, n[0] > 1 ? n[0] -= 1 : n[0] < 0 && (n[0] += 1), HSVtoRGB(n[0], n[1], n[2])
        }
        var rgbToHex = function () {
            var t, e, n = [];
            for (t = 0; t < 256; t += 1) e = t.toString(16), n[t] = 1 == e.length ? "0" + e : e;
            return function (t, e, i) {
                return t < 0 && (t = 0), e < 0 && (e = 0), i < 0 && (i = 0), "#" + n[t] + n[e] + n[i]
            }
        }();

        function BaseEvent() {}
        BaseEvent.prototype = {
            triggerEvent: function (t, e) {
                if (this._cbs[t])
                    for (var n = this._cbs[t].length, i = 0; i < n; i++) this._cbs[t][i](e)
            },
            addEventListener: function (t, e) {
                return this._cbs[t] || (this._cbs[t] = []), this._cbs[t].push(e),
                    function () {
                        this.removeEventListener(t, e)
                    }.bind(this)
            },
            removeEventListener: function (t, e) {
                if (e) {
                    if (this._cbs[t]) {
                        for (var n = 0, i = this._cbs[t].length; n < i;) this._cbs[t][n] === e && (this._cbs[t].splice(n, 1), n -= 1, i -= 1), n += 1;
                        this._cbs[t].length || (this._cbs[t] = null)
                    }
                } else this._cbs[t] = null
            }
        };
        var createTypedArray = "function" == typeof Uint8ClampedArray && "function" == typeof Float32Array ? function (t, e) {
            return "float32" === t ? new Float32Array(e) : "int16" === t ? new Int16Array(e) : "uint8c" === t ? new Uint8ClampedArray(e) : void 0
        } : function (t, e) {
            var n, i = 0,
                r = [];
            switch (t) {
                case "int16":
                case "uint8c":
                    n = 1;
                    break;
                default:
                    n = 1.1
            }
            for (i = 0; i < e; i += 1) r.push(n);
            return r
        };

        function createSizedArray(t) {
            return Array.apply(null, {
                length: t
            })
        }

        function createNS(t) {
            return document.createElementNS(svgNS, t)
        }

        function createTag(t) {
            return document.createElement(t)
        }

        function DynamicPropertyContainer() {}
        DynamicPropertyContainer.prototype = {
            addDynamicProperty: function (t) {
                -1 === this.dynamicProperties.indexOf(t) && (this.dynamicProperties.push(t), this.container.addDynamicProperty(this), this._isAnimated = !0)
            },
            iterateDynamicProperties: function () {
                this._mdf = !1;
                var t, e = this.dynamicProperties.length;
                for (t = 0; t < e; t += 1) this.dynamicProperties[t].getValue(), this.dynamicProperties[t]._mdf && (this._mdf = !0)
            },
            initDynamicPropertyContainer: function (t) {
                this.container = t, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1
            }
        };
        var getBlendMode = (blendModeEnums = {
                0: "source-over",
                1: "multiply",
                2: "screen",
                3: "overlay",
                4: "darken",
                5: "lighten",
                6: "color-dodge",
                7: "color-burn",
                8: "hard-light",
                9: "soft-light",
                10: "difference",
                11: "exclusion",
                12: "hue",
                13: "saturation",
                14: "color",
                15: "luminosity"
            }, function (t) {
                return blendModeEnums[t] || ""
            }),
            blendModeEnums, Matrix = function () {
                var t = Math.cos,
                    e = Math.sin,
                    n = Math.tan,
                    i = Math.round;

                function r() {
                    return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this
                }

                function a(n) {
                    if (0 === n) return this;
                    var i = t(n),
                        r = e(n);
                    return this._t(i, -r, 0, 0, r, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                }

                function s(n) {
                    if (0 === n) return this;
                    var i = t(n),
                        r = e(n);
                    return this._t(1, 0, 0, 0, 0, i, -r, 0, 0, r, i, 0, 0, 0, 0, 1)
                }

                function o(n) {
                    if (0 === n) return this;
                    var i = t(n),
                        r = e(n);
                    return this._t(i, 0, r, 0, 0, 1, 0, 0, -r, 0, i, 0, 0, 0, 0, 1)
                }

                function l(n) {
                    if (0 === n) return this;
                    var i = t(n),
                        r = e(n);
                    return this._t(i, -r, 0, 0, r, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                }

                function h(t, e) {
                    return this._t(1, e, t, 1, 0, 0)
                }

                function u(t, e) {
                    return this.shear(n(t), n(e))
                }

                function c(i, r) {
                    var a = t(r),
                        s = e(r);
                    return this._t(a, s, 0, 0, -s, a, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, n(i), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(a, -s, 0, 0, s, a, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                }

                function p(t, e, n) {
                    return n || 0 === n || (n = 1), 1 === t && 1 === e && 1 === n ? this : this._t(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1)
                }

                function f(t, e, n, i, r, a, s, o, l, h, u, c, p, f, d, m) {
                    return this.props[0] = t, this.props[1] = e, this.props[2] = n, this.props[3] = i, this.props[4] = r, this.props[5] = a, this.props[6] = s, this.props[7] = o, this.props[8] = l, this.props[9] = h, this.props[10] = u, this.props[11] = c, this.props[12] = p, this.props[13] = f, this.props[14] = d, this.props[15] = m, this
                }

                function d(t, e, n) {
                    return n = n || 0, 0 !== t || 0 !== e || 0 !== n ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t, e, n, 1) : this
                }

                function m(t, e, n, i, r, a, s, o, l, h, u, c, p, f, d, m) {
                    var g = this.props;
                    if (1 === t && 0 === e && 0 === n && 0 === i && 0 === r && 1 === a && 0 === s && 0 === o && 0 === l && 0 === h && 1 === u && 0 === c) return g[12] = g[12] * t + g[15] * p, g[13] = g[13] * a + g[15] * f, g[14] = g[14] * u + g[15] * d, g[15] = g[15] * m, this._identityCalculated = !1, this;
                    var v = g[0],
                        y = g[1],
                        _ = g[2],
                        x = g[3],
                        b = g[4],
                        E = g[5],
                        w = g[6],
                        D = g[7],
                        M = g[8],
                        S = g[9],
                        T = g[10],
                        A = g[11],
                        C = g[12],
                        P = g[13],
                        F = g[14],
                        L = g[15];
                    return g[0] = v * t + y * r + _ * l + x * p, g[1] = v * e + y * a + _ * h + x * f, g[2] = v * n + y * s + _ * u + x * d, g[3] = v * i + y * o + _ * c + x * m, g[4] = b * t + E * r + w * l + D * p, g[5] = b * e + E * a + w * h + D * f, g[6] = b * n + E * s + w * u + D * d, g[7] = b * i + E * o + w * c + D * m, g[8] = M * t + S * r + T * l + A * p, g[9] = M * e + S * a + T * h + A * f, g[10] = M * n + S * s + T * u + A * d, g[11] = M * i + S * o + T * c + A * m, g[12] = C * t + P * r + F * l + L * p, g[13] = C * e + P * a + F * h + L * f, g[14] = C * n + P * s + F * u + L * d, g[15] = C * i + P * o + F * c + L * m, this._identityCalculated = !1, this
                }

                function g() {
                    return this._identityCalculated || (this._identity = !(1 !== this.props[0] || 0 !== this.props[1] || 0 !== this.props[2] || 0 !== this.props[3] || 0 !== this.props[4] || 1 !== this.props[5] || 0 !== this.props[6] || 0 !== this.props[7] || 0 !== this.props[8] || 0 !== this.props[9] || 1 !== this.props[10] || 0 !== this.props[11] || 0 !== this.props[12] || 0 !== this.props[13] || 0 !== this.props[14] || 1 !== this.props[15]), this._identityCalculated = !0), this._identity
                }

                function v(t) {
                    for (var e = 0; e < 16;) {
                        if (t.props[e] !== this.props[e]) return !1;
                        e += 1
                    }
                    return !0
                }

                function y(t) {
                    var e;
                    for (e = 0; e < 16; e += 1) t.props[e] = this.props[e]
                }

                function _(t) {
                    var e;
                    for (e = 0; e < 16; e += 1) this.props[e] = t[e]
                }

                function x(t, e, n) {
                    return {
                        x: t * this.props[0] + e * this.props[4] + n * this.props[8] + this.props[12],
                        y: t * this.props[1] + e * this.props[5] + n * this.props[9] + this.props[13],
                        z: t * this.props[2] + e * this.props[6] + n * this.props[10] + this.props[14]
                    }
                }

                function b(t, e, n) {
                    return t * this.props[0] + e * this.props[4] + n * this.props[8] + this.props[12]
                }

                function E(t, e, n) {
                    return t * this.props[1] + e * this.props[5] + n * this.props[9] + this.props[13]
                }

                function w(t, e, n) {
                    return t * this.props[2] + e * this.props[6] + n * this.props[10] + this.props[14]
                }

                function D() {
                    var t = this.props[0] * this.props[5] - this.props[1] * this.props[4],
                        e = this.props[5] / t,
                        n = -this.props[1] / t,
                        i = -this.props[4] / t,
                        r = this.props[0] / t,
                        a = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / t,
                        s = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / t,
                        o = new Matrix;
                    return o.props[0] = e, o.props[1] = n, o.props[4] = i, o.props[5] = r, o.props[12] = a, o.props[13] = s, o
                }

                function M(t) {
                    return this.getInverseMatrix().applyToPointArray(t[0], t[1], t[2] || 0)
                }

                function S(t) {
                    var e, n = t.length,
                        i = [];
                    for (e = 0; e < n; e += 1) i[e] = M(t[e]);
                    return i
                }

                function T(t, e, n) {
                    var i = createTypedArray("float32", 6);
                    if (this.isIdentity()) i[0] = t[0], i[1] = t[1], i[2] = e[0], i[3] = e[1], i[4] = n[0], i[5] = n[1];
                    else {
                        var r = this.props[0],
                            a = this.props[1],
                            s = this.props[4],
                            o = this.props[5],
                            l = this.props[12],
                            h = this.props[13];
                        i[0] = t[0] * r + t[1] * s + l, i[1] = t[0] * a + t[1] * o + h, i[2] = e[0] * r + e[1] * s + l, i[3] = e[0] * a + e[1] * o + h, i[4] = n[0] * r + n[1] * s + l, i[5] = n[0] * a + n[1] * o + h
                    }
                    return i
                }

                function A(t, e, n) {
                    return this.isIdentity() ? [t, e, n] : [t * this.props[0] + e * this.props[4] + n * this.props[8] + this.props[12], t * this.props[1] + e * this.props[5] + n * this.props[9] + this.props[13], t * this.props[2] + e * this.props[6] + n * this.props[10] + this.props[14]]
                }

                function C(t, e) {
                    if (this.isIdentity()) return t + "," + e;
                    var n = this.props;
                    return Math.round(100 * (t * n[0] + e * n[4] + n[12])) / 100 + "," + Math.round(100 * (t * n[1] + e * n[5] + n[13])) / 100
                }

                function P() {
                    for (var t = 0, e = this.props, n = "matrix3d("; t < 16;) n += i(1e4 * e[t]) / 1e4, n += 15 === t ? ")" : ",", t += 1;
                    return n
                }

                function F(t) {
                    return t < 1e-6 && t > 0 || t > -1e-6 && t < 0 ? i(1e4 * t) / 1e4 : t
                }

                function L() {
                    var t = this.props;
                    return "matrix(" + F(t[0]) + "," + F(t[1]) + "," + F(t[4]) + "," + F(t[5]) + "," + F(t[12]) + "," + F(t[13]) + ")"
                }
                return function () {
                    this.reset = r, this.rotate = a, this.rotateX = s, this.rotateY = o, this.rotateZ = l, this.skew = u, this.skewFromAxis = c, this.shear = h, this.scale = p, this.setTransform = f, this.translate = d, this.transform = m, this.applyToPoint = x, this.applyToX = b, this.applyToY = E, this.applyToZ = w, this.applyToPointArray = A, this.applyToTriplePoints = T, this.applyToPointStringified = C, this.toCSS = P, this.to2dCSS = L, this.clone = y, this.cloneFromProps = _, this.equals = v, this.inversePoints = S, this.inversePoint = M, this.getInverseMatrix = D, this._t = this.transform, this.isIdentity = g, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset()
                }
            }();
        ! function (t, e) {
            var n = this,
                i = e.pow(256, 6),
                r = e.pow(2, 52),
                a = 2 * r;

            function s(t) {
                var e, n = t.length,
                    i = this,
                    r = 0,
                    a = i.i = i.j = 0,
                    s = i.S = [];
                for (n || (t = [n++]); r < 256;) s[r] = r++;
                for (r = 0; r < 256; r++) s[r] = s[a = 255 & a + t[r % n] + (e = s[r])], s[a] = e;
                i.g = function (t) {
                    for (var e, n = 0, r = i.i, a = i.j, s = i.S; t--;) e = s[r = 255 & r + 1], n = 256 * n + s[255 & (s[r] = s[a = 255 & a + e]) + (s[a] = e)];
                    return i.i = r, i.j = a, n
                }
            }

            function o(t, e) {
                return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e
            }

            function l(t, e) {
                for (var n, i = t + "", r = 0; r < i.length;) e[255 & r] = 255 & (n ^= 19 * e[255 & r]) + i.charCodeAt(r++);
                return h(e)
            }

            function h(t) {
                return String.fromCharCode.apply(0, t)
            }
            e.seedrandom = function (u, c, p) {
                var f = [],
                    d = l(function t(e, n) {
                        var i, r = [],
                            a = typeof e;
                        if (n && "object" == a)
                            for (i in e) try {
                                r.push(t(e[i], n - 1))
                            } catch (t) {}
                        return r.length ? r : "string" == a ? e : e + "\0"
                    }((c = !0 === c ? {
                        entropy: !0
                    } : c || {}).entropy ? [u, h(t)] : null === u ? function () {
                        try {
                            void 0;
                            var e = new Uint8Array(256);
                            return (n.crypto || n.msCrypto).getRandomValues(e), h(e)
                        } catch (e) {
                            var i = n.navigator,
                                r = i && i.plugins;
                            return [+new Date, n, r, n.screen, h(t)]
                        }
                    }() : u, 3), f),
                    m = new s(f),
                    g = function () {
                        for (var t = m.g(6), e = i, n = 0; t < r;) t = 256 * (t + n), e *= 256, n = m.g(1);
                        for (; t >= a;) t /= 2, e /= 2, n >>>= 1;
                        return (t + n) / e
                    };
                return g.int32 = function () {
                    return 0 | m.g(4)
                }, g.quick = function () {
                    return m.g(4) / 4294967296
                }, g.double = g, l(h(m.S), t), (c.pass || p || function (t, n, i, r) {
                    return r && (r.S && o(r, m), t.state = function () {
                        return o(m, {})
                    }), i ? (e.random = t, n) : t
                })(g, d, "global" in c ? c.global : this == e, c.state)
            }, l(e.random(), t)
        }([], BMMath);
        var BezierFactory = function () {
            var t = {
                    getBezierEasing: function (t, n, i, r, a) {
                        var s = a || ("bez_" + t + "_" + n + "_" + i + "_" + r).replace(/\./g, "p");
                        if (e[s]) return e[s];
                        var o = new l([t, n, i, r]);
                        return e[s] = o, o
                    }
                },
                e = {};
            var n = "function" == typeof Float32Array;

            function i(t, e) {
                return 1 - 3 * e + 3 * t
            }

            function r(t, e) {
                return 3 * e - 6 * t
            }

            function a(t) {
                return 3 * t
            }

            function s(t, e, n) {
                return ((i(e, n) * t + r(e, n)) * t + a(e)) * t
            }

            function o(t, e, n) {
                return 3 * i(e, n) * t * t + 2 * r(e, n) * t + a(e)
            }

            function l(t) {
                this._p = t, this._mSampleValues = n ? new Float32Array(11) : new Array(11), this._precomputed = !1, this.get = this.get.bind(this)
            }
            return l.prototype = {
                get: function (t) {
                    var e = this._p[0],
                        n = this._p[1],
                        i = this._p[2],
                        r = this._p[3];
                    return this._precomputed || this._precompute(), e === n && i === r ? t : 0 === t ? 0 : 1 === t ? 1 : s(this._getTForX(t), n, r)
                },
                _precompute: function () {
                    var t = this._p[0],
                        e = this._p[1],
                        n = this._p[2],
                        i = this._p[3];
                    this._precomputed = !0, t === e && n === i || this._calcSampleValues()
                },
                _calcSampleValues: function () {
                    for (var t = this._p[0], e = this._p[2], n = 0; n < 11; ++n) this._mSampleValues[n] = s(.1 * n, t, e)
                },
                _getTForX: function (t) {
                    for (var e = this._p[0], n = this._p[2], i = this._mSampleValues, r = 0, a = 1; 10 !== a && i[a] <= t; ++a) r += .1;
                    var l = r + .1 * ((t - i[--a]) / (i[a + 1] - i[a])),
                        h = o(l, e, n);
                    return h >= .001 ? function (t, e, n, i) {
                        for (var r = 0; r < 4; ++r) {
                            var a = o(e, n, i);
                            if (0 === a) return e;
                            e -= (s(e, n, i) - t) / a
                        }
                        return e
                    }(t, l, e, n) : 0 === h ? l : function (t, e, n, i, r) {
                        var a, o, l = 0;
                        do {
                            (a = s(o = e + (n - e) / 2, i, r) - t) > 0 ? n = o : e = o
                        } while (Math.abs(a) > 1e-7 && ++l < 10);
                        return o
                    }(t, r, r + .1, e, n)
                }
            }, t
        }();

        function extendPrototype(t, e) {
            var n, i, r = t.length;
            for (n = 0; n < r; n += 1)
                for (var a in i = t[n].prototype) i.hasOwnProperty(a) && (e.prototype[a] = i[a])
        }

        function getDescriptor(t, e) {
            return Object.getOwnPropertyDescriptor(t, e)
        }

        function createProxyFunction(t) {
            function e() {}
            return e.prototype = t, e
        }

        function bezFunction() {
            Math;

            function t(t, e, n, i, r, a) {
                var s = t * i + e * r + n * a - r * i - a * t - n * e;
                return s > -.001 && s < .001
            }
            var e = function (t, e, n, i) {
                var r, a, s, o, l, h, u = defaultCurveSegments,
                    c = 0,
                    p = [],
                    f = [],
                    d = bezier_length_pool.newElement();
                for (s = n.length, r = 0; r < u; r += 1) {
                    for (l = r / (u - 1), h = 0, a = 0; a < s; a += 1) o = bm_pow(1 - l, 3) * t[a] + 3 * bm_pow(1 - l, 2) * l * n[a] + 3 * (1 - l) * bm_pow(l, 2) * i[a] + bm_pow(l, 3) * e[a], p[a] = o, null !== f[a] && (h += bm_pow(p[a] - f[a], 2)), f[a] = p[a];
                    h && (c += h = bm_sqrt(h)), d.percents[r] = l, d.lengths[r] = c
                }
                return d.addedLength = c, d
            };

            function n(t) {
                this.segmentLength = 0, this.points = new Array(t)
            }

            function i(t, e) {
                this.partialLength = t, this.point = e
            }
            var r, a = (r = {}, function (e, a, s, o) {
                var l = (e[0] + "_" + e[1] + "_" + a[0] + "_" + a[1] + "_" + s[0] + "_" + s[1] + "_" + o[0] + "_" + o[1]).replace(/\./g, "p");
                if (!r[l]) {
                    var h, u, c, p, f, d, m, g = defaultCurveSegments,
                        v = 0,
                        y = null;
                    2 === e.length && (e[0] != a[0] || e[1] != a[1]) && t(e[0], e[1], a[0], a[1], e[0] + s[0], e[1] + s[1]) && t(e[0], e[1], a[0], a[1], a[0] + o[0], a[1] + o[1]) && (g = 2);
                    var _ = new n(g);
                    for (c = s.length, h = 0; h < g; h += 1) {
                        for (m = createSizedArray(c), f = h / (g - 1), d = 0, u = 0; u < c; u += 1) p = bm_pow(1 - f, 3) * e[u] + 3 * bm_pow(1 - f, 2) * f * (e[u] + s[u]) + 3 * (1 - f) * bm_pow(f, 2) * (a[u] + o[u]) + bm_pow(f, 3) * a[u], m[u] = p, null !== y && (d += bm_pow(m[u] - y[u], 2));
                        v += d = bm_sqrt(d), _.points[h] = new i(d, m), y = m
                    }
                    _.segmentLength = v, r[l] = _
                }
                return r[l]
            });

            function s(t, e) {
                var n = e.percents,
                    i = e.lengths,
                    r = n.length,
                    a = bm_floor((r - 1) * t),
                    s = t * e.addedLength,
                    o = 0;
                if (a === r - 1 || 0 === a || s === i[a]) return n[a];
                for (var l = i[a] > s ? -1 : 1, h = !0; h;)
                    if (i[a] <= s && i[a + 1] > s ? (o = (s - i[a]) / (i[a + 1] - i[a]), h = !1) : a += l, a < 0 || a >= r - 1) {
                        if (a === r - 1) return n[a];
                        h = !1
                    } return n[a] + (n[a + 1] - n[a]) * o
            }
            var o = createTypedArray("float32", 8);
            return {
                getSegmentsLength: function (t) {
                    var n, i = segments_length_pool.newElement(),
                        r = t.c,
                        a = t.v,
                        s = t.o,
                        o = t.i,
                        l = t._length,
                        h = i.lengths,
                        u = 0;
                    for (n = 0; n < l - 1; n += 1) h[n] = e(a[n], a[n + 1], s[n], o[n + 1]), u += h[n].addedLength;
                    return r && l && (h[n] = e(a[n], a[0], s[n], o[0]), u += h[n].addedLength), i.totalLength = u, i
                },
                getNewSegment: function (t, e, n, i, r, a, l) {
                    var h, u = s(r = r < 0 ? 0 : r > 1 ? 1 : r, l),
                        c = s(a = a > 1 ? 1 : a, l),
                        p = t.length,
                        f = 1 - u,
                        d = 1 - c,
                        m = f * f * f,
                        g = u * f * f * 3,
                        v = u * u * f * 3,
                        y = u * u * u,
                        _ = f * f * d,
                        x = u * f * d + f * u * d + f * f * c,
                        b = u * u * d + f * u * c + u * f * c,
                        E = u * u * c,
                        w = f * d * d,
                        D = u * d * d + f * c * d + f * d * c,
                        M = u * c * d + f * c * c + u * d * c,
                        S = u * c * c,
                        T = d * d * d,
                        A = c * d * d + d * c * d + d * d * c,
                        C = c * c * d + d * c * c + c * d * c,
                        P = c * c * c;
                    for (h = 0; h < p; h += 1) o[4 * h] = Math.round(1e3 * (m * t[h] + g * n[h] + v * i[h] + y * e[h])) / 1e3, o[4 * h + 1] = Math.round(1e3 * (_ * t[h] + x * n[h] + b * i[h] + E * e[h])) / 1e3, o[4 * h + 2] = Math.round(1e3 * (w * t[h] + D * n[h] + M * i[h] + S * e[h])) / 1e3, o[4 * h + 3] = Math.round(1e3 * (T * t[h] + A * n[h] + C * i[h] + P * e[h])) / 1e3;
                    return o
                },
                getPointInSegment: function (t, e, n, i, r, a) {
                    var o = s(r, a),
                        l = 1 - o;
                    return [Math.round(1e3 * (l * l * l * t[0] + (o * l * l + l * o * l + l * l * o) * n[0] + (o * o * l + l * o * o + o * l * o) * i[0] + o * o * o * e[0])) / 1e3, Math.round(1e3 * (l * l * l * t[1] + (o * l * l + l * o * l + l * l * o) * n[1] + (o * o * l + l * o * o + o * l * o) * i[1] + o * o * o * e[1])) / 1e3]
                },
                buildBezierData: a,
                pointOnLine2D: t,
                pointOnLine3D: function (e, n, i, r, a, s, o, l, h) {
                    if (0 === i && 0 === s && 0 === h) return t(e, n, r, a, o, l);
                    var u, c = Math.sqrt(Math.pow(r - e, 2) + Math.pow(a - n, 2) + Math.pow(s - i, 2)),
                        p = Math.sqrt(Math.pow(o - e, 2) + Math.pow(l - n, 2) + Math.pow(h - i, 2)),
                        f = Math.sqrt(Math.pow(o - r, 2) + Math.pow(l - a, 2) + Math.pow(h - s, 2));
                    return (u = c > p ? c > f ? c - p - f : f - p - c : f > p ? f - p - c : p - c - f) > -1e-4 && u < 1e-4
                }
            }
        }! function () {
            for (var t = 0, e = ["ms", "moz", "webkit", "o"], n = 0; n < e.length && !window.requestAnimationFrame; ++n) window.requestAnimationFrame = window[e[n] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[e[n] + "CancelAnimationFrame"] || window[e[n] + "CancelRequestAnimationFrame"];
            window.requestAnimationFrame || (window.requestAnimationFrame = function (e, n) {
                var i = (new Date).getTime(),
                    r = Math.max(0, 16 - (i - t)),
                    a = setTimeout((function () {
                        e(i + r)
                    }), r);
                return t = i + r, a
            }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function (t) {
                clearTimeout(t)
            })
        }();
        var bez = bezFunction();

        function dataFunctionManager() {
            function t(r, a, s) {
                var o, l, h, c, p, f, d = r.length;
                for (l = 0; l < d; l += 1)
                    if ("ks" in (o = r[l]) && !o.completed) {
                        if (o.completed = !0, o.tt && (r[l - 1].td = o.tt), [], -1, o.hasMask) {
                            var m = o.masksProperties;
                            for (c = m.length, h = 0; h < c; h += 1)
                                if (m[h].pt.k.i) i(m[h].pt.k);
                                else
                                    for (f = m[h].pt.k.length, p = 0; p < f; p += 1) m[h].pt.k[p].s && i(m[h].pt.k[p].s[0]), m[h].pt.k[p].e && i(m[h].pt.k[p].e[0])
                        }
                        0 === o.ty ? (o.layers = e(o.refId, a), t(o.layers, a, s)) : 4 === o.ty ? n(o.shapes) : 5 == o.ty && u(o, s)
                    }
            }

            function e(t, e) {
                for (var n = 0, i = e.length; n < i;) {
                    if (e[n].id === t) return e[n].layers.__used ? JSON.parse(JSON.stringify(e[n].layers)) : (e[n].layers.__used = !0, e[n].layers);
                    n += 1
                }
            }

            function n(t) {
                var e, r, a;
                for (e = t.length - 1; e >= 0; e -= 1)
                    if ("sh" == t[e].ty) {
                        if (t[e].ks.k.i) i(t[e].ks.k);
                        else
                            for (a = t[e].ks.k.length, r = 0; r < a; r += 1) t[e].ks.k[r].s && i(t[e].ks.k[r].s[0]), t[e].ks.k[r].e && i(t[e].ks.k[r].e[0]);
                        !0
                    } else "gr" == t[e].ty && n(t[e].it)
            }

            function i(t) {
                var e, n = t.i.length;
                for (e = 0; e < n; e += 1) t.i[e][0] += t.v[e][0], t.i[e][1] += t.v[e][1], t.o[e][0] += t.v[e][0], t.o[e][1] += t.v[e][1]
            }

            function r(t, e) {
                var n = e ? e.split(".") : [100, 100, 100];
                return t[0] > n[0] || !(n[0] > t[0]) && (t[1] > n[1] || !(n[1] > t[1]) && (t[2] > n[2] || !(n[2] > t[2]) && void 0))
            }
            var a, s = function () {
                    var t = [4, 4, 14];

                    function e(t) {
                        var e, n, i, r = t.length;
                        for (e = 0; e < r; e += 1) 5 === t[e].ty && (n = t[e], i = void 0, i = n.t.d, n.t.d = {
                            k: [{
                                s: i,
                                t: 0
                            }]
                        })
                    }
                    return function (n) {
                        if (r(t, n.v) && (e(n.layers), n.assets)) {
                            var i, a = n.assets.length;
                            for (i = 0; i < a; i += 1) n.assets[i].layers && e(n.assets[i].layers)
                        }
                    }
                }(),
                o = (a = [4, 7, 99], function (t) {
                    if (t.chars && !r(a, t.v)) {
                        var e, n, s, o, l, h = t.chars.length;
                        for (e = 0; e < h; e += 1)
                            if (t.chars[e].data && t.chars[e].data.shapes)
                                for (s = (l = t.chars[e].data.shapes[0].it).length, n = 0; n < s; n += 1)(o = l[n].ks.k).__converted || (i(l[n].ks.k), o.__converted = !0)
                    }
                }),
                l = function () {
                    var t = [4, 1, 9];

                    function e(t) {
                        var n, i, r, a = t.length;
                        for (n = 0; n < a; n += 1)
                            if ("gr" === t[n].ty) e(t[n].it);
                            else if ("fl" === t[n].ty || "st" === t[n].ty)
                            if (t[n].c.k && t[n].c.k[0].i)
                                for (r = t[n].c.k.length, i = 0; i < r; i += 1) t[n].c.k[i].s && (t[n].c.k[i].s[0] /= 255, t[n].c.k[i].s[1] /= 255, t[n].c.k[i].s[2] /= 255, t[n].c.k[i].s[3] /= 255), t[n].c.k[i].e && (t[n].c.k[i].e[0] /= 255, t[n].c.k[i].e[1] /= 255, t[n].c.k[i].e[2] /= 255, t[n].c.k[i].e[3] /= 255);
                            else t[n].c.k[0] /= 255, t[n].c.k[1] /= 255, t[n].c.k[2] /= 255, t[n].c.k[3] /= 255
                    }

                    function n(t) {
                        var n, i = t.length;
                        for (n = 0; n < i; n += 1) 4 === t[n].ty && e(t[n].shapes)
                    }
                    return function (e) {
                        if (r(t, e.v) && (n(e.layers), e.assets)) {
                            var i, a = e.assets.length;
                            for (i = 0; i < a; i += 1) e.assets[i].layers && n(e.assets[i].layers)
                        }
                    }
                }(),
                h = function () {
                    var t = [4, 4, 18];

                    function e(t) {
                        var n, i, r;
                        for (n = t.length - 1; n >= 0; n -= 1)
                            if ("sh" == t[n].ty) {
                                if (t[n].ks.k.i) t[n].ks.k.c = t[n].closed;
                                else
                                    for (r = t[n].ks.k.length, i = 0; i < r; i += 1) t[n].ks.k[i].s && (t[n].ks.k[i].s[0].c = t[n].closed), t[n].ks.k[i].e && (t[n].ks.k[i].e[0].c = t[n].closed);
                                !0
                            } else "gr" == t[n].ty && e(t[n].it)
                    }

                    function n(t) {
                        var n, i, r, a, s, o, l = t.length;
                        for (i = 0; i < l; i += 1) {
                            if ((n = t[i]).hasMask) {
                                var h = n.masksProperties;
                                for (a = h.length, r = 0; r < a; r += 1)
                                    if (h[r].pt.k.i) h[r].pt.k.c = h[r].cl;
                                    else
                                        for (o = h[r].pt.k.length, s = 0; s < o; s += 1) h[r].pt.k[s].s && (h[r].pt.k[s].s[0].c = h[r].cl), h[r].pt.k[s].e && (h[r].pt.k[s].e[0].c = h[r].cl)
                            }
                            4 === n.ty && e(n.shapes)
                        }
                    }
                    return function (e) {
                        if (r(t, e.v) && (n(e.layers), e.assets)) {
                            var i, a = e.assets.length;
                            for (i = 0; i < a; i += 1) e.assets[i].layers && n(e.assets[i].layers)
                        }
                    }
                }();

            function u(t, e) {
                0 !== t.t.a.length || "m" in t.t.p || (t.singleShape = !0)
            }
            var c = {
                completeData: function (e, n) {
                    e.__complete || (l(e), s(e), o(e), h(e), t(e.layers, e.assets, n), e.__complete = !0)
                }
            };
            return c.checkColors = l, c.checkChars = o, c.checkShapes = h, c.completeLayers = t, c
        }
        var dataManager = dataFunctionManager(),
            FontManager = function () {
                var t = {
                        w: 0,
                        size: 0,
                        shapes: []
                    },
                    e = [];

                function n(t, e) {
                    var n = createTag("span");
                    n.style.fontFamily = e;
                    var i = createTag("span");
                    i.innerHTML = "giItT1WQy@!-/#", n.style.position = "absolute", n.style.left = "-10000px", n.style.top = "-10000px", n.style.fontSize = "300px", n.style.fontVariant = "normal", n.style.fontStyle = "normal", n.style.fontWeight = "normal", n.style.letterSpacing = "0", n.appendChild(i), document.body.appendChild(n);
                    var r = i.offsetWidth;
                    return i.style.fontFamily = t + ", " + e, {
                        node: i,
                        w: r,
                        parent: n
                    }
                }

                function i(t, e) {
                    var n = createNS("text");
                    return n.style.fontSize = "100px", n.setAttribute("font-family", e.fFamily), n.setAttribute("font-style", e.fStyle), n.setAttribute("font-weight", e.fWeight), n.textContent = "1", e.fClass ? (n.style.fontFamily = "inherit", n.setAttribute("class", e.fClass)) : n.style.fontFamily = e.fFamily, t.appendChild(n), createTag("canvas").getContext("2d").font = e.fWeight + " " + e.fStyle + " 100px " + e.fFamily, n
                }
                e = e.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
                var r = function () {
                    this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this.initTime = Date.now()
                };
                return r.getCombinedCharacterCodes = function () {
                    return e
                }, r.prototype.addChars = function (t) {
                    if (t) {
                        this.chars || (this.chars = []);
                        var e, n, i, r = t.length,
                            a = this.chars.length;
                        for (e = 0; e < r; e += 1) {
                            for (n = 0, i = !1; n < a;) this.chars[n].style === t[e].style && this.chars[n].fFamily === t[e].fFamily && this.chars[n].ch === t[e].ch && (i = !0), n += 1;
                            i || (this.chars.push(t[e]), a += 1)
                        }
                    }
                }, r.prototype.addFonts = function (t, e) {
                    if (t) {
                        if (this.chars) return this.isLoaded = !0, void(this.fonts = t.list);
                        var r, a = t.list,
                            s = a.length,
                            o = s;
                        for (r = 0; r < s; r += 1) {
                            var l, h, u = !0;
                            if (a[r].loaded = !1, a[r].monoCase = n(a[r].fFamily, "monospace"), a[r].sansCase = n(a[r].fFamily, "sans-serif"), a[r].fPath) {
                                if ("p" === a[r].fOrigin || 3 === a[r].origin) {
                                    if ((l = document.querySelectorAll('style[f-forigin="p"][f-family="' + a[r].fFamily + '"], style[f-origin="3"][f-family="' + a[r].fFamily + '"]')).length > 0 && (u = !1), u) {
                                        var c = createTag("style");
                                        c.setAttribute("f-forigin", a[r].fOrigin), c.setAttribute("f-origin", a[r].origin), c.setAttribute("f-family", a[r].fFamily), c.type = "text/css", c.innerHTML = "@font-face {font-family: " + a[r].fFamily + "; font-style: normal; src: url('" + a[r].fPath + "');}", e.appendChild(c)
                                    }
                                } else if ("g" === a[r].fOrigin || 1 === a[r].origin) {
                                    for (l = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), h = 0; h < l.length; h++) - 1 !== l[h].href.indexOf(a[r].fPath) && (u = !1);
                                    if (u) {
                                        var p = createTag("link");
                                        p.setAttribute("f-forigin", a[r].fOrigin), p.setAttribute("f-origin", a[r].origin), p.type = "text/css", p.rel = "stylesheet", p.href = a[r].fPath, document.body.appendChild(p)
                                    }
                                } else if ("t" === a[r].fOrigin || 2 === a[r].origin) {
                                    for (l = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), h = 0; h < l.length; h++) a[r].fPath === l[h].src && (u = !1);
                                    if (u) {
                                        var f = createTag("link");
                                        f.setAttribute("f-forigin", a[r].fOrigin), f.setAttribute("f-origin", a[r].origin), f.setAttribute("rel", "stylesheet"), f.setAttribute("href", a[r].fPath), e.appendChild(f)
                                    }
                                }
                            } else a[r].loaded = !0, o -= 1;
                            a[r].helper = i(e, a[r]), a[r].cache = {}, this.fonts.push(a[r])
                        }
                        0 === o ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
                    } else this.isLoaded = !0
                }, r.prototype.getCharData = function (e, n, i) {
                    for (var r = 0, a = this.chars.length; r < a;) {
                        if (this.chars[r].ch === e && this.chars[r].style === n && this.chars[r].fFamily === i) return this.chars[r];
                        r += 1
                    }
                    return ("string" == typeof e && 13 !== e.charCodeAt(0) || !e) && console && console.warn && console.warn("Missing character from exported characters list: ", e, n, i), t
                }, r.prototype.getFontByName = function (t) {
                    for (var e = 0, n = this.fonts.length; e < n;) {
                        if (this.fonts[e].fName === t) return this.fonts[e];
                        e += 1
                    }
                    return this.fonts[0]
                }, r.prototype.measureText = function (t, e, n) {
                    var i = this.getFontByName(e),
                        r = t.charCodeAt(0);
                    if (!i.cache[r + 1]) {
                        var a = i.helper;
                        if (" " === t) {
                            a.textContent = "|" + t + "|";
                            var s = a.getComputedTextLength();
                            a.textContent = "||";
                            var o = a.getComputedTextLength();
                            i.cache[r + 1] = (s - o) / 100
                        } else a.textContent = t, i.cache[r + 1] = a.getComputedTextLength() / 100
                    }
                    return i.cache[r + 1] * n
                }, r.prototype.checkLoadedFonts = function () {
                    var t, e, n, i = this.fonts.length,
                        r = i;
                    for (t = 0; t < i; t += 1) this.fonts[t].loaded ? r -= 1 : "n" === this.fonts[t].fOrigin || 0 === this.fonts[t].origin ? this.fonts[t].loaded = !0 : (e = this.fonts[t].monoCase.node, n = this.fonts[t].monoCase.w, e.offsetWidth !== n ? (r -= 1, this.fonts[t].loaded = !0) : (e = this.fonts[t].sansCase.node, n = this.fonts[t].sansCase.w, e.offsetWidth !== n && (r -= 1, this.fonts[t].loaded = !0)), this.fonts[t].loaded && (this.fonts[t].sansCase.parent.parentNode.removeChild(this.fonts[t].sansCase.parent), this.fonts[t].monoCase.parent.parentNode.removeChild(this.fonts[t].monoCase.parent)));
                    0 !== r && Date.now() - this.initTime < 5e3 ? setTimeout(this.checkLoadedFonts.bind(this), 20) : setTimeout(function () {
                        this.isLoaded = !0
                    }.bind(this), 0)
                }, r.prototype.loaded = function () {
                    return this.isLoaded
                }, r
            }(),
            PropertyFactory = function () {
                var t = initialDefaultFrame,
                    e = Math.abs;

                function n(t, e) {
                    var n, r = this.offsetTime;
                    "multidimensional" === this.propType && (n = createTypedArray("float32", this.pv.length));
                    for (var a, s, o, l, h, u, c, p, f = e.lastIndex, d = f, m = this.keyframes.length - 1, g = !0; g;) {
                        if (a = this.keyframes[d], s = this.keyframes[d + 1], d === m - 1 && t >= s.t - r) {
                            a.h && (a = s), f = 0;
                            break
                        }
                        if (s.t - r > t) {
                            f = d;
                            break
                        }
                        d < m - 1 ? d += 1 : (f = 0, g = !1)
                    }
                    var v, y = s.t - r,
                        _ = a.t - r;
                    if (a.to) {
                        a.bezierData || (a.bezierData = bez.buildBezierData(a.s, s.s || a.e, a.to, a.ti));
                        var x = a.bezierData;
                        if (t >= y || t < _) {
                            var b = t >= y ? x.points.length - 1 : 0;
                            for (l = x.points[b].point.length, o = 0; o < l; o += 1) n[o] = x.points[b].point[o]
                        } else {
                            a.__fnct ? p = a.__fnct : (p = BezierFactory.getBezierEasing(a.o.x, a.o.y, a.i.x, a.i.y, a.n).get, a.__fnct = p), h = p((t - _) / (y - _));
                            var E, w = x.segmentLength * h,
                                D = e.lastFrame < t && e._lastKeyframeIndex === d ? e._lastAddedLength : 0;
                            for (c = e.lastFrame < t && e._lastKeyframeIndex === d ? e._lastPoint : 0, g = !0, u = x.points.length; g;) {
                                if (D += x.points[c].partialLength, 0 === w || 0 === h || c === x.points.length - 1) {
                                    for (l = x.points[c].point.length, o = 0; o < l; o += 1) n[o] = x.points[c].point[o];
                                    break
                                }
                                if (w >= D && w < D + x.points[c + 1].partialLength) {
                                    for (E = (w - D) / x.points[c + 1].partialLength, l = x.points[c].point.length, o = 0; o < l; o += 1) n[o] = x.points[c].point[o] + (x.points[c + 1].point[o] - x.points[c].point[o]) * E;
                                    break
                                }
                                c < u - 1 ? c += 1 : g = !1
                            }
                            e._lastPoint = c, e._lastAddedLength = D - x.points[c].partialLength, e._lastKeyframeIndex = d
                        }
                    } else {
                        var M, S, T, A, C;
                        if (m = a.s.length, v = s.s || a.e, this.sh && 1 !== a.h)
                            if (t >= y) n[0] = v[0], n[1] = v[1], n[2] = v[2];
                            else if (t <= _) n[0] = a.s[0], n[1] = a.s[1], n[2] = a.s[2];
                        else {
                            ! function (t, e) {
                                var n = e[0],
                                    i = e[1],
                                    r = e[2],
                                    a = e[3],
                                    s = Math.atan2(2 * i * a - 2 * n * r, 1 - 2 * i * i - 2 * r * r),
                                    o = Math.asin(2 * n * i + 2 * r * a),
                                    l = Math.atan2(2 * n * a - 2 * i * r, 1 - 2 * n * n - 2 * r * r);
                                t[0] = s / degToRads, t[1] = o / degToRads, t[2] = l / degToRads
                            }(n, function (t, e, n) {
                                var i, r, a, s, o, l = [],
                                    h = t[0],
                                    u = t[1],
                                    c = t[2],
                                    p = t[3],
                                    f = e[0],
                                    d = e[1],
                                    m = e[2],
                                    g = e[3];
                                (r = h * f + u * d + c * m + p * g) < 0 && (r = -r, f = -f, d = -d, m = -m, g = -g);
                                1 - r > 1e-6 ? (i = Math.acos(r), a = Math.sin(i), s = Math.sin((1 - n) * i) / a, o = Math.sin(n * i) / a) : (s = 1 - n, o = n);
                                return l[0] = s * h + o * f, l[1] = s * u + o * d, l[2] = s * c + o * m, l[3] = s * p + o * g, l
                            }(i(a.s), i(v), (t - _) / (y - _)))
                        } else
                            for (d = 0; d < m; d += 1) 1 !== a.h && (t >= y ? h = 1 : t < _ ? h = 0 : (a.o.x.constructor === Array ? (a.__fnct || (a.__fnct = []), a.__fnct[d] ? p = a.__fnct[d] : (M = void 0 === a.o.x[d] ? a.o.x[0] : a.o.x[d], S = void 0 === a.o.y[d] ? a.o.y[0] : a.o.y[d], T = void 0 === a.i.x[d] ? a.i.x[0] : a.i.x[d], A = void 0 === a.i.y[d] ? a.i.y[0] : a.i.y[d], p = BezierFactory.getBezierEasing(M, S, T, A).get, a.__fnct[d] = p)) : a.__fnct ? p = a.__fnct : (M = a.o.x, S = a.o.y, T = a.i.x, A = a.i.y, p = BezierFactory.getBezierEasing(M, S, T, A).get, a.__fnct = p), h = p((t - _) / (y - _)))), v = s.s || a.e, C = 1 === a.h ? a.s[d] : a.s[d] + (v[d] - a.s[d]) * h, "multidimensional" === this.propType ? n[d] = C : n = C
                    }
                    return e.lastIndex = f, n
                }

                function i(t) {
                    var e = t[0] * degToRads,
                        n = t[1] * degToRads,
                        i = t[2] * degToRads,
                        r = Math.cos(e / 2),
                        a = Math.cos(n / 2),
                        s = Math.cos(i / 2),
                        o = Math.sin(e / 2),
                        l = Math.sin(n / 2),
                        h = Math.sin(i / 2);
                    return [o * l * s + r * a * h, o * a * s + r * l * h, r * l * s - o * a * h, r * a * s - o * l * h]
                }

                function r() {
                    var e = this.comp.renderedFrame - this.offsetTime,
                        n = this.keyframes[0].t - this.offsetTime,
                        i = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
                    if (!(e === this._caching.lastFrame || this._caching.lastFrame !== t && (this._caching.lastFrame >= i && e >= i || this._caching.lastFrame < n && e < n))) {
                        this._caching.lastFrame >= e && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0);
                        var r = this.interpolateValue(e, this._caching);
                        this.pv = r
                    }
                    return this._caching.lastFrame = e, this.pv
                }

                function a(t) {
                    var n;
                    if ("unidimensional" === this.propType) n = t * this.mult, e(this.v - n) > 1e-5 && (this.v = n, this._mdf = !0);
                    else
                        for (var i = 0, r = this.v.length; i < r;) n = t[i] * this.mult, e(this.v[i] - n) > 1e-5 && (this.v[i] = n, this._mdf = !0), i += 1
                }

                function s() {
                    if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length)
                        if (this.lock) this.setVValue(this.pv);
                        else {
                            this.lock = !0, this._mdf = this._isFirstFrame;
                            var t, e = this.effectsSequence.length,
                                n = this.kf ? this.pv : this.data.k;
                            for (t = 0; t < e; t += 1) n = this.effectsSequence[t](n);
                            this.setVValue(n), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId
                        }
                }

                function o(t) {
                    this.effectsSequence.push(t), this.container.addDynamicProperty(this)
                }

                function l(t, e, n, i) {
                    this.propType = "unidimensional", this.mult = n || 1, this.data = e, this.v = n ? e.k * n : e.k, this.pv = e.k, this._mdf = !1, this.elem = t, this.container = i, this.comp = t.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = s, this.setVValue = a, this.addEffect = o
                }

                function h(t, e, n, i) {
                    this.propType = "multidimensional", this.mult = n || 1, this.data = e, this._mdf = !1, this.elem = t, this.container = i, this.comp = t.comp, this.k = !1, this.kf = !1, this.frameId = -1;
                    var r, l = e.k.length;
                    this.v = createTypedArray("float32", l), this.pv = createTypedArray("float32", l);
                    createTypedArray("float32", l);
                    for (this.vel = createTypedArray("float32", l), r = 0; r < l; r += 1) this.v[r] = e.k[r] * this.mult, this.pv[r] = e.k[r];
                    this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = s, this.setVValue = a, this.addEffect = o
                }

                function u(e, i, l, h) {
                    this.propType = "unidimensional", this.keyframes = i.k, this.offsetTime = e.data.st, this.frameId = -1, this._caching = {
                        lastFrame: t,
                        lastIndex: 0,
                        value: 0,
                        _lastKeyframeIndex: -1
                    }, this.k = !0, this.kf = !0, this.data = i, this.mult = l || 1, this.elem = e, this.container = h, this.comp = e.comp, this.v = t, this.pv = t, this._isFirstFrame = !0, this.getValue = s, this.setVValue = a, this.interpolateValue = n, this.effectsSequence = [r.bind(this)], this.addEffect = o
                }

                function c(e, i, l, h) {
                    this.propType = "multidimensional";
                    var u, c, p, f, d, m = i.k.length;
                    for (u = 0; u < m - 1; u += 1) i.k[u].to && i.k[u].s && i.k[u + 1] && i.k[u + 1].s && (c = i.k[u].s, p = i.k[u + 1].s, f = i.k[u].to, d = i.k[u].ti, (2 === c.length && (c[0] !== p[0] || c[1] !== p[1]) && bez.pointOnLine2D(c[0], c[1], p[0], p[1], c[0] + f[0], c[1] + f[1]) && bez.pointOnLine2D(c[0], c[1], p[0], p[1], p[0] + d[0], p[1] + d[1]) || 3 === c.length && (c[0] !== p[0] || c[1] !== p[1] || c[2] !== p[2]) && bez.pointOnLine3D(c[0], c[1], c[2], p[0], p[1], p[2], c[0] + f[0], c[1] + f[1], c[2] + f[2]) && bez.pointOnLine3D(c[0], c[1], c[2], p[0], p[1], p[2], p[0] + d[0], p[1] + d[1], p[2] + d[2])) && (i.k[u].to = null, i.k[u].ti = null), c[0] === p[0] && c[1] === p[1] && 0 === f[0] && 0 === f[1] && 0 === d[0] && 0 === d[1] && (2 === c.length || c[2] === p[2] && 0 === f[2] && 0 === d[2]) && (i.k[u].to = null, i.k[u].ti = null));
                    this.effectsSequence = [r.bind(this)], this.keyframes = i.k, this.offsetTime = e.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = l || 1, this.elem = e, this.container = h, this.comp = e.comp, this.getValue = s, this.setVValue = a, this.interpolateValue = n, this.frameId = -1;
                    var g = i.k[0].s.length;
                    for (this.v = createTypedArray("float32", g), this.pv = createTypedArray("float32", g), u = 0; u < g; u += 1) this.v[u] = t, this.pv[u] = t;
                    this._caching = {
                        lastFrame: t,
                        lastIndex: 0,
                        value: createTypedArray("float32", g)
                    }, this.addEffect = o
                }
                return {
                    getProp: function (t, e, n, i, r) {
                        var a;
                        if (e.k.length)
                            if ("number" == typeof e.k[0]) a = new h(t, e, i, r);
                            else switch (n) {
                                case 0:
                                    a = new u(t, e, i, r);
                                    break;
                                case 1:
                                    a = new c(t, e, i, r)
                            } else a = new l(t, e, i, r);
                        return a.effectsSequence.length && r.addDynamicProperty(a), a
                    }
                }
            }(),
            TransformPropertyFactory = function () {
                var t = [0, 0];

                function e(t, e, n) {
                    if (this.elem = t, this.frameId = -1, this.propType = "transform", this.data = e, this.v = new Matrix, this.pre = new Matrix, this.appliedTransformations = 0, this.initDynamicPropertyContainer(n || t), e.p && e.p.s ? (this.px = PropertyFactory.getProp(t, e.p.x, 0, 0, this), this.py = PropertyFactory.getProp(t, e.p.y, 0, 0, this), e.p.z && (this.pz = PropertyFactory.getProp(t, e.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(t, e.p || {
                            k: [0, 0, 0]
                        }, 1, 0, this), e.rx) {
                        if (this.rx = PropertyFactory.getProp(t, e.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(t, e.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(t, e.rz, 0, degToRads, this), e.or.k[0].ti) {
                            var i, r = e.or.k.length;
                            for (i = 0; i < r; i += 1) e.or.k[i].to = e.or.k[i].ti = null
                        }
                        this.or = PropertyFactory.getProp(t, e.or, 1, degToRads, this), this.or.sh = !0
                    } else this.r = PropertyFactory.getProp(t, e.r || {
                        k: 0
                    }, 0, degToRads, this);
                    e.sk && (this.sk = PropertyFactory.getProp(t, e.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(t, e.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(t, e.a || {
                        k: [0, 0, 0]
                    }, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s || {
                        k: [100, 100, 100]
                    }, 1, .01, this), e.o ? this.o = PropertyFactory.getProp(t, e.o, 0, .01, t) : this.o = {
                        _mdf: !1,
                        v: 1
                    }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0)
                }
                return e.prototype = {
                    applyToMatrix: function (t) {
                        var e = this._mdf;
                        this.iterateDynamicProperties(), this._mdf = this._mdf || e, this.a && t.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && t.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && t.skewFromAxis(-this.sk.v, this.sa.v), this.r ? t.rotate(-this.r.v) : t.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? t.translate(this.px.v, this.py.v, -this.pz.v) : t.translate(this.px.v, this.py.v, 0) : t.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                    },
                    getValue: function (e) {
                        if (this.elem.globalData.frameId !== this.frameId) {
                            if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || e) {
                                if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) {
                                    var n, i, r = this.elem.globalData.frameRate;
                                    if (this.p && this.p.keyframes && this.p.getValueAtTime) this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (n = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / r, 0), i = this.p.getValueAtTime(this.p.keyframes[0].t / r, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (n = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / r, 0), i = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / r, 0)) : (n = this.p.pv, i = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / r, this.p.offsetTime));
                                    else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                                        n = [], i = [];
                                        var a = this.px,
                                            s = this.py;
                                        a._caching.lastFrame + a.offsetTime <= a.keyframes[0].t ? (n[0] = a.getValueAtTime((a.keyframes[0].t + .01) / r, 0), n[1] = s.getValueAtTime((s.keyframes[0].t + .01) / r, 0), i[0] = a.getValueAtTime(a.keyframes[0].t / r, 0), i[1] = s.getValueAtTime(s.keyframes[0].t / r, 0)) : a._caching.lastFrame + a.offsetTime >= a.keyframes[a.keyframes.length - 1].t ? (n[0] = a.getValueAtTime(a.keyframes[a.keyframes.length - 1].t / r, 0), n[1] = s.getValueAtTime(s.keyframes[s.keyframes.length - 1].t / r, 0), i[0] = a.getValueAtTime((a.keyframes[a.keyframes.length - 1].t - .01) / r, 0), i[1] = s.getValueAtTime((s.keyframes[s.keyframes.length - 1].t - .01) / r, 0)) : (n = [a.pv, s.pv], i[0] = a.getValueAtTime((a._caching.lastFrame + a.offsetTime - .01) / r, a.offsetTime), i[1] = s.getValueAtTime((s._caching.lastFrame + s.offsetTime - .01) / r, s.offsetTime))
                                    } else n = i = t;
                                    this.v.rotate(-Math.atan2(n[1] - i[1], n[0] - i[0]))
                                }
                                this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                            }
                            this.frameId = this.elem.globalData.frameId
                        }
                    },
                    precalculateMatrix: function () {
                        if (!this.a.k && (this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1, !this.s.effectsSequence.length)) {
                            if (this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2, this.sk) {
                                if (this.sk.effectsSequence.length || this.sa.effectsSequence.length) return;
                                this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3
                            }
                            if (this.r) {
                                if (this.r.effectsSequence.length) return;
                                this.pre.rotate(-this.r.v), this.appliedTransformations = 4
                            } else this.rz.effectsSequence.length || this.ry.effectsSequence.length || this.rx.effectsSequence.length || this.or.effectsSequence.length || (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4)
                        }
                    },
                    autoOrient: function () {}
                }, extendPrototype([DynamicPropertyContainer], e), e.prototype.addDynamicProperty = function (t) {
                    this._addDynamicProperty(t), this.elem.addDynamicProperty(t), this._isDirty = !0
                }, e.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty, {
                    getTransformProperty: function (t, n, i) {
                        return new e(t, n, i)
                    }
                }
            }();

        function ShapePath() {
            this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength)
        }
        ShapePath.prototype.setPathData = function (t, e) {
            this.c = t, this.setLength(e);
            for (var n = 0; n < e;) this.v[n] = point_pool.newElement(), this.o[n] = point_pool.newElement(), this.i[n] = point_pool.newElement(), n += 1
        }, ShapePath.prototype.setLength = function (t) {
            for (; this._maxLength < t;) this.doubleArrayLength();
            this._length = t
        }, ShapePath.prototype.doubleArrayLength = function () {
            this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2
        }, ShapePath.prototype.setXYAt = function (t, e, n, i, r) {
            var a;
            switch (this._length = Math.max(this._length, i + 1), this._length >= this._maxLength && this.doubleArrayLength(), n) {
                case "v":
                    a = this.v;
                    break;
                case "i":
                    a = this.i;
                    break;
                case "o":
                    a = this.o
            }(!a[i] || a[i] && !r) && (a[i] = point_pool.newElement()), a[i][0] = t, a[i][1] = e
        }, ShapePath.prototype.setTripleAt = function (t, e, n, i, r, a, s, o) {
            this.setXYAt(t, e, "v", s, o), this.setXYAt(n, i, "o", s, o), this.setXYAt(r, a, "i", s, o)
        }, ShapePath.prototype.reverse = function () {
            var t = new ShapePath;
            t.setPathData(this.c, this._length);
            var e = this.v,
                n = this.o,
                i = this.i,
                r = 0;
            this.c && (t.setTripleAt(e[0][0], e[0][1], i[0][0], i[0][1], n[0][0], n[0][1], 0, !1), r = 1);
            var a, s = this._length - 1,
                o = this._length;
            for (a = r; a < o; a += 1) t.setTripleAt(e[s][0], e[s][1], i[s][0], i[s][1], n[s][0], n[s][1], a, !1), s -= 1;
            return t
        };
        var ShapePropertyFactory = function () {
                function t(t, e, n) {
                    var i, r, a, s, o, l, h, u, c, p = n.lastIndex,
                        f = this.keyframes;
                    if (t < f[0].t - this.offsetTime) i = f[0].s[0], a = !0, p = 0;
                    else if (t >= f[f.length - 1].t - this.offsetTime) i = f[f.length - 1].s ? f[f.length - 1].s[0] : f[f.length - 2].e[0], a = !0;
                    else {
                        for (var d, m, g = p, v = f.length - 1, y = !0; y && (d = f[g], !((m = f[g + 1]).t - this.offsetTime > t));) g < v - 1 ? g += 1 : y = !1;
                        if (p = g, !(a = 1 === d.h)) {
                            if (t >= m.t - this.offsetTime) u = 1;
                            else if (t < d.t - this.offsetTime) u = 0;
                            else {
                                var _;
                                d.__fnct ? _ = d.__fnct : (_ = BezierFactory.getBezierEasing(d.o.x, d.o.y, d.i.x, d.i.y).get, d.__fnct = _), u = _((t - (d.t - this.offsetTime)) / (m.t - this.offsetTime - (d.t - this.offsetTime)))
                            }
                            r = m.s ? m.s[0] : d.e[0]
                        }
                        i = d.s[0]
                    }
                    for (l = e._length, h = i.i[0].length, n.lastIndex = p, s = 0; s < l; s += 1)
                        for (o = 0; o < h; o += 1) c = a ? i.i[s][o] : i.i[s][o] + (r.i[s][o] - i.i[s][o]) * u, e.i[s][o] = c, c = a ? i.o[s][o] : i.o[s][o] + (r.o[s][o] - i.o[s][o]) * u, e.o[s][o] = c, c = a ? i.v[s][o] : i.v[s][o] + (r.v[s][o] - i.v[s][o]) * u, e.v[s][o] = c
                }

                function e() {
                    var t = this.comp.renderedFrame - this.offsetTime,
                        e = this.keyframes[0].t - this.offsetTime,
                        n = this.keyframes[this.keyframes.length - 1].t - this.offsetTime,
                        i = this._caching.lastFrame;
                    return -999999 !== i && (i < e && t < e || i > n && t > n) || (this._caching.lastIndex = i < t ? this._caching.lastIndex : 0, this.interpolateShape(t, this.pv, this._caching)), this._caching.lastFrame = t, this.pv
                }

                function n() {
                    this.paths = this.localShapeCollection
                }

                function i(t) {
                    (function (t, e) {
                        if (t._length !== e._length || t.c !== e.c) return !1;
                        var n, i = t._length;
                        for (n = 0; n < i; n += 1)
                            if (t.v[n][0] !== e.v[n][0] || t.v[n][1] !== e.v[n][1] || t.o[n][0] !== e.o[n][0] || t.o[n][1] !== e.o[n][1] || t.i[n][0] !== e.i[n][0] || t.i[n][1] !== e.i[n][1]) return !1;
                        return !0
                    })(this.v, t) || (this.v = shape_pool.clone(t), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection)
                }

                function r() {
                    if (this.elem.globalData.frameId !== this.frameId)
                        if (this.effectsSequence.length)
                            if (this.lock) this.setVValue(this.pv);
                            else {
                                this.lock = !0, this._mdf = !1;
                                var t, e = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k,
                                    n = this.effectsSequence.length;
                                for (t = 0; t < n; t += 1) e = this.effectsSequence[t](e);
                                this.setVValue(e), this.lock = !1, this.frameId = this.elem.globalData.frameId
                            }
                    else this._mdf = !1
                }

                function a(t, e, i) {
                    this.propType = "shape", this.comp = t.comp, this.container = t, this.elem = t, this.data = e, this.k = !1, this.kf = !1, this._mdf = !1;
                    var r = 3 === i ? e.pt.k : e.ks.k;
                    this.v = shape_pool.clone(r), this.pv = shape_pool.clone(this.v), this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = n, this.effectsSequence = []
                }

                function s(t) {
                    this.effectsSequence.push(t), this.container.addDynamicProperty(this)
                }

                function o(t, i, r) {
                    this.propType = "shape", this.comp = t.comp, this.elem = t, this.container = t, this.offsetTime = t.data.st, this.keyframes = 3 === r ? i.pt.k : i.ks.k, this.k = !0, this.kf = !0;
                    var a = this.keyframes[0].s[0].i.length;
                    this.keyframes[0].s[0].i[0].length;
                    this.v = shape_pool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, a), this.pv = shape_pool.clone(this.v), this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = -999999, this.reset = n, this._caching = {
                        lastFrame: -999999,
                        lastIndex: 0
                    }, this.effectsSequence = [e.bind(this)]
                }
                a.prototype.interpolateShape = t, a.prototype.getValue = r, a.prototype.setVValue = i, a.prototype.addEffect = s, o.prototype.getValue = r, o.prototype.interpolateShape = t, o.prototype.setVValue = i, o.prototype.addEffect = s;
                var l = function () {
                        var t = roundCorner;

                        function e(t, e) {
                            this.v = shape_pool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = e.d, this.elem = t, this.comp = t.comp, this.frameId = -1, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath())
                        }
                        return e.prototype = {
                            reset: n,
                            getValue: function () {
                                this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath())
                            },
                            convertEllToPath: function () {
                                var e = this.p.v[0],
                                    n = this.p.v[1],
                                    i = this.s.v[0] / 2,
                                    r = this.s.v[1] / 2,
                                    a = 3 !== this.d,
                                    s = this.v;
                                s.v[0][0] = e, s.v[0][1] = n - r, s.v[1][0] = a ? e + i : e - i, s.v[1][1] = n, s.v[2][0] = e, s.v[2][1] = n + r, s.v[3][0] = a ? e - i : e + i, s.v[3][1] = n, s.i[0][0] = a ? e - i * t : e + i * t, s.i[0][1] = n - r, s.i[1][0] = a ? e + i : e - i, s.i[1][1] = n - r * t, s.i[2][0] = a ? e + i * t : e - i * t, s.i[2][1] = n + r, s.i[3][0] = a ? e - i : e + i, s.i[3][1] = n + r * t, s.o[0][0] = a ? e + i * t : e - i * t, s.o[0][1] = n - r, s.o[1][0] = a ? e + i : e - i, s.o[1][1] = n + r * t, s.o[2][0] = a ? e - i * t : e + i * t, s.o[2][1] = n + r, s.o[3][0] = a ? e - i : e + i, s.o[3][1] = n - r * t
                            }
                        }, extendPrototype([DynamicPropertyContainer], e), e
                    }(),
                    h = function () {
                        function t(t, e) {
                            this.v = shape_pool.newElement(), this.v.setPathData(!0, 0), this.elem = t, this.comp = t.comp, this.data = e, this.frameId = -1, this.d = e.d, this.initDynamicPropertyContainer(t), 1 === e.sy ? (this.ir = PropertyFactory.getProp(t, e.ir, 0, 0, this), this.is = PropertyFactory.getProp(t, e.is, 0, .01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(t, e.pt, 0, 0, this), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.r = PropertyFactory.getProp(t, e.r, 0, degToRads, this), this.or = PropertyFactory.getProp(t, e.or, 0, 0, this), this.os = PropertyFactory.getProp(t, e.os, 0, .01, this), this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath())
                        }
                        return t.prototype = {
                            reset: n,
                            getValue: function () {
                                this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath())
                            },
                            convertStarToPath: function () {
                                var t, e, n, i, r = 2 * Math.floor(this.pt.v),
                                    a = 2 * Math.PI / r,
                                    s = !0,
                                    o = this.or.v,
                                    l = this.ir.v,
                                    h = this.os.v,
                                    u = this.is.v,
                                    c = 2 * Math.PI * o / (2 * r),
                                    p = 2 * Math.PI * l / (2 * r),
                                    f = -Math.PI / 2;
                                f += this.r.v;
                                var d = 3 === this.data.d ? -1 : 1;
                                for (this.v._length = 0, t = 0; t < r; t += 1) {
                                    n = s ? h : u, i = s ? c : p;
                                    var m = (e = s ? o : l) * Math.cos(f),
                                        g = e * Math.sin(f),
                                        v = 0 === m && 0 === g ? 0 : g / Math.sqrt(m * m + g * g),
                                        y = 0 === m && 0 === g ? 0 : -m / Math.sqrt(m * m + g * g);
                                    m += +this.p.v[0], g += +this.p.v[1], this.v.setTripleAt(m, g, m - v * i * n * d, g - y * i * n * d, m + v * i * n * d, g + y * i * n * d, t, !0), s = !s, f += a * d
                                }
                            },
                            convertPolygonToPath: function () {
                                var t, e = Math.floor(this.pt.v),
                                    n = 2 * Math.PI / e,
                                    i = this.or.v,
                                    r = this.os.v,
                                    a = 2 * Math.PI * i / (4 * e),
                                    s = -Math.PI / 2,
                                    o = 3 === this.data.d ? -1 : 1;
                                for (s += this.r.v, this.v._length = 0, t = 0; t < e; t += 1) {
                                    var l = i * Math.cos(s),
                                        h = i * Math.sin(s),
                                        u = 0 === l && 0 === h ? 0 : h / Math.sqrt(l * l + h * h),
                                        c = 0 === l && 0 === h ? 0 : -l / Math.sqrt(l * l + h * h);
                                    l += +this.p.v[0], h += +this.p.v[1], this.v.setTripleAt(l, h, l - u * a * r * o, h - c * a * r * o, l + u * a * r * o, h + c * a * r * o, t, !0), s += n * o
                                }
                                this.paths.length = 0, this.paths[0] = this.v
                            }
                        }, extendPrototype([DynamicPropertyContainer], t), t
                    }(),
                    u = function () {
                        function t(t, e) {
                            this.v = shape_pool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollection_pool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = t, this.comp = t.comp, this.frameId = -1, this.d = e.d, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, e.p, 1, 0, this), this.s = PropertyFactory.getProp(t, e.s, 1, 0, this), this.r = PropertyFactory.getProp(t, e.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath())
                        }
                        return t.prototype = {
                            convertRectToPath: function () {
                                var t = this.p.v[0],
                                    e = this.p.v[1],
                                    n = this.s.v[0] / 2,
                                    i = this.s.v[1] / 2,
                                    r = bm_min(n, i, this.r.v),
                                    a = r * (1 - roundCorner);
                                this.v._length = 0, 2 === this.d || 1 === this.d ? (this.v.setTripleAt(t + n, e - i + r, t + n, e - i + r, t + n, e - i + a, 0, !0), this.v.setTripleAt(t + n, e + i - r, t + n, e + i - a, t + n, e + i - r, 1, !0), 0 !== r ? (this.v.setTripleAt(t + n - r, e + i, t + n - r, e + i, t + n - a, e + i, 2, !0), this.v.setTripleAt(t - n + r, e + i, t - n + a, e + i, t - n + r, e + i, 3, !0), this.v.setTripleAt(t - n, e + i - r, t - n, e + i - r, t - n, e + i - a, 4, !0), this.v.setTripleAt(t - n, e - i + r, t - n, e - i + a, t - n, e - i + r, 5, !0), this.v.setTripleAt(t - n + r, e - i, t - n + r, e - i, t - n + a, e - i, 6, !0), this.v.setTripleAt(t + n - r, e - i, t + n - a, e - i, t + n - r, e - i, 7, !0)) : (this.v.setTripleAt(t - n, e + i, t - n + a, e + i, t - n, e + i, 2), this.v.setTripleAt(t - n, e - i, t - n, e - i + a, t - n, e - i, 3))) : (this.v.setTripleAt(t + n, e - i + r, t + n, e - i + a, t + n, e - i + r, 0, !0), 0 !== r ? (this.v.setTripleAt(t + n - r, e - i, t + n - r, e - i, t + n - a, e - i, 1, !0), this.v.setTripleAt(t - n + r, e - i, t - n + a, e - i, t - n + r, e - i, 2, !0), this.v.setTripleAt(t - n, e - i + r, t - n, e - i + r, t - n, e - i + a, 3, !0), this.v.setTripleAt(t - n, e + i - r, t - n, e + i - a, t - n, e + i - r, 4, !0), this.v.setTripleAt(t - n + r, e + i, t - n + r, e + i, t - n + a, e + i, 5, !0), this.v.setTripleAt(t + n - r, e + i, t + n - a, e + i, t + n - r, e + i, 6, !0), this.v.setTripleAt(t + n, e + i - r, t + n, e + i - r, t + n, e + i - a, 7, !0)) : (this.v.setTripleAt(t - n, e - i, t - n + a, e - i, t - n, e - i, 1, !0), this.v.setTripleAt(t - n, e + i, t - n, e + i - a, t - n, e + i, 2, !0), this.v.setTripleAt(t + n, e + i, t + n - a, e + i, t + n, e + i, 3, !0)))
                            },
                            getValue: function (t) {
                                this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath())
                            },
                            reset: n
                        }, extendPrototype([DynamicPropertyContainer], t), t
                    }();
                var c = {
                    getShapeProp: function (t, e, n) {
                        var i;
                        return 3 === n || 4 === n ? i = (3 === n ? e.pt : e.ks).k.length ? new o(t, e, n) : new a(t, e, n) : 5 === n ? i = new u(t, e) : 6 === n ? i = new l(t, e) : 7 === n && (i = new h(t, e)), i.k && t.addDynamicProperty(i), i
                    },
                    getConstructorFunction: function () {
                        return a
                    },
                    getKeyframedConstructorFunction: function () {
                        return o
                    }
                };
                return c
            }(),
            ShapeModifiers = function () {
                var t = {},
                    e = {};
                return t.registerModifier = function (t, n) {
                    e[t] || (e[t] = n)
                }, t.getModifier = function (t, n, i) {
                    return new e[t](n, i)
                }, t
            }();

        function ShapeModifier() {}

        function TrimModifier() {}

        function RoundCornersModifier() {}

        function RepeaterModifier() {}

        function ShapeCollection() {
            this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength)
        }

        function DashProperty(t, e, n, i) {
            this.elem = t, this.frameId = -1, this.dataProps = createSizedArray(e.length), this.renderer = n, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", e.length ? e.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(i);
            var r, a, s = e.length || 0;
            for (r = 0; r < s; r += 1) a = PropertyFactory.getProp(t, e[r].v, 0, 0, this), this.k = a.k || this.k, this.dataProps[r] = {
                n: e[r].n,
                p: a
            };
            this.k || this.getValue(!0), this._isAnimated = this.k
        }

        function GradientProperty(t, e, n) {
            this.data = e, this.c = createTypedArray("uint8c", 4 * e.p);
            var i = e.k.k[0].s ? e.k.k[0].s.length - 4 * e.p : e.k.k.length - 4 * e.p;
            this.o = createTypedArray("float32", i), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = i, this.initDynamicPropertyContainer(n), this.prop = PropertyFactory.getProp(t, e.k, 1, null, this), this.k = this.prop.k, this.getValue(!0)
        }
        ShapeModifier.prototype.initModifierProperties = function () {}, ShapeModifier.prototype.addShapeToModifier = function () {}, ShapeModifier.prototype.addShape = function (t) {
            if (!this.closed) {
                t.sh.container.addDynamicProperty(t.sh);
                var e = {
                    shape: t.sh,
                    data: t,
                    localShapeCollection: shapeCollection_pool.newShapeCollection()
                };
                this.shapes.push(e), this.addShapeToModifier(e), this._isAnimated && t.setAsAnimated()
            }
        }, ShapeModifier.prototype.init = function (t, e) {
            this.shapes = [], this.elem = t, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, e), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
        }, ShapeModifier.prototype.processKeys = function () {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties())
        }, extendPrototype([DynamicPropertyContainer], ShapeModifier), extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function (t, e) {
            this.s = PropertyFactory.getProp(t, e.s, 0, .01, this), this.e = PropertyFactory.getProp(t, e.e, 0, .01, this), this.o = PropertyFactory.getProp(t, e.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = e.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
        }, TrimModifier.prototype.addShapeToModifier = function (t) {
            t.pathsData = []
        }, TrimModifier.prototype.calculateShapeEdges = function (t, e, n, i, r) {
            var a = [];
            e <= 1 ? a.push({
                s: t,
                e: e
            }) : t >= 1 ? a.push({
                s: t - 1,
                e: e - 1
            }) : (a.push({
                s: t,
                e: 1
            }), a.push({
                s: 0,
                e: e - 1
            }));
            var s, o, l = [],
                h = a.length;
            for (s = 0; s < h; s += 1) {
                var u, c;
                if ((o = a[s]).e * r < i || o.s * r > i + n);
                else u = o.s * r <= i ? 0 : (o.s * r - i) / n, c = o.e * r >= i + n ? 1 : (o.e * r - i) / n, l.push([u, c])
            }
            return l.length || l.push([0, 0]), l
        }, TrimModifier.prototype.releasePathsData = function (t) {
            var e, n = t.length;
            for (e = 0; e < n; e += 1) segments_length_pool.release(t[e]);
            return t.length = 0, t
        }, TrimModifier.prototype.processShapes = function (t) {
            var e, n, i;
            if (this._mdf || t) {
                var r = this.o.v % 360 / 360;
                if (r < 0 && (r += 1), (e = (this.s.v > 1 ? 1 : this.s.v < 0 ? 0 : this.s.v) + r) > (n = (this.e.v > 1 ? 1 : this.e.v < 0 ? 0 : this.e.v) + r)) {
                    var a = e;
                    e = n, n = a
                }
                e = 1e-4 * Math.round(1e4 * e), n = 1e-4 * Math.round(1e4 * n), this.sValue = e, this.eValue = n
            } else e = this.sValue, n = this.eValue;
            var s, o, l, h, u, c, p = this.shapes.length,
                f = 0;
            if (n === e)
                for (s = 0; s < p; s += 1) this.shapes[s].localShapeCollection.releaseShapes(), this.shapes[s].shape._mdf = !0, this.shapes[s].shape.paths = this.shapes[s].localShapeCollection;
            else if (1 === n && 0 === e || 0 === n && 1 === e) {
                if (this._mdf)
                    for (s = 0; s < p; s += 1) this.shapes[s].pathsData.length = 0, this.shapes[s].shape._mdf = !0
            } else {
                var d, m, g = [];
                for (s = 0; s < p; s += 1)
                    if ((d = this.shapes[s]).shape._mdf || this._mdf || t || 2 === this.m) {
                        if (l = (i = d.shape.paths)._length, c = 0, !d.shape._mdf && d.pathsData.length) c = d.totalShapeLength;
                        else {
                            for (h = this.releasePathsData(d.pathsData), o = 0; o < l; o += 1) u = bez.getSegmentsLength(i.shapes[o]), h.push(u), c += u.totalLength;
                            d.totalShapeLength = c, d.pathsData = h
                        }
                        f += c, d.shape._mdf = !0
                    } else d.shape.paths = d.localShapeCollection;
                var v, y = e,
                    _ = n,
                    x = 0;
                for (s = p - 1; s >= 0; s -= 1)
                    if ((d = this.shapes[s]).shape._mdf) {
                        for ((m = d.localShapeCollection).releaseShapes(), 2 === this.m && p > 1 ? (v = this.calculateShapeEdges(e, n, d.totalShapeLength, x, f), x += d.totalShapeLength) : v = [[y, _]], l = v.length, o = 0; o < l; o += 1) {
                            y = v[o][0], _ = v[o][1], g.length = 0, _ <= 1 ? g.push({
                                s: d.totalShapeLength * y,
                                e: d.totalShapeLength * _
                            }) : y >= 1 ? g.push({
                                s: d.totalShapeLength * (y - 1),
                                e: d.totalShapeLength * (_ - 1)
                            }) : (g.push({
                                s: d.totalShapeLength * y,
                                e: d.totalShapeLength
                            }), g.push({
                                s: 0,
                                e: d.totalShapeLength * (_ - 1)
                            }));
                            var b = this.addShapes(d, g[0]);
                            if (g[0].s !== g[0].e) {
                                if (g.length > 1)
                                    if (d.shape.paths.shapes[d.shape.paths._length - 1].c) {
                                        var E = b.pop();
                                        this.addPaths(b, m), b = this.addShapes(d, g[1], E)
                                    } else this.addPaths(b, m), b = this.addShapes(d, g[1]);
                                this.addPaths(b, m)
                            }
                        }
                        d.shape.paths = m
                    }
            }
        }, TrimModifier.prototype.addPaths = function (t, e) {
            var n, i = t.length;
            for (n = 0; n < i; n += 1) e.addShape(t[n])
        }, TrimModifier.prototype.addSegment = function (t, e, n, i, r, a, s) {
            r.setXYAt(e[0], e[1], "o", a), r.setXYAt(n[0], n[1], "i", a + 1), s && r.setXYAt(t[0], t[1], "v", a), r.setXYAt(i[0], i[1], "v", a + 1)
        }, TrimModifier.prototype.addSegmentFromArray = function (t, e, n, i) {
            e.setXYAt(t[1], t[5], "o", n), e.setXYAt(t[2], t[6], "i", n + 1), i && e.setXYAt(t[0], t[4], "v", n), e.setXYAt(t[3], t[7], "v", n + 1)
        }, TrimModifier.prototype.addShapes = function (t, e, n) {
            var i, r, a, s, o, l, h, u, c = t.pathsData,
                p = t.shape.paths.shapes,
                f = t.shape.paths._length,
                d = 0,
                m = [],
                g = !0;
            for (n ? (o = n._length, u = n._length) : (n = shape_pool.newElement(), o = 0, u = 0), m.push(n), i = 0; i < f; i += 1) {
                for (l = c[i].lengths, n.c = p[i].c, a = p[i].c ? l.length : l.length + 1, r = 1; r < a; r += 1)
                    if (d + (s = l[r - 1]).addedLength < e.s) d += s.addedLength, n.c = !1;
                    else {
                        if (d > e.e) {
                            n.c = !1;
                            break
                        }
                        e.s <= d && e.e >= d + s.addedLength ? (this.addSegment(p[i].v[r - 1], p[i].o[r - 1], p[i].i[r], p[i].v[r], n, o, g), g = !1) : (h = bez.getNewSegment(p[i].v[r - 1], p[i].v[r], p[i].o[r - 1], p[i].i[r], (e.s - d) / s.addedLength, (e.e - d) / s.addedLength, l[r - 1]), this.addSegmentFromArray(h, n, o, g), g = !1, n.c = !1), d += s.addedLength, o += 1
                    } if (p[i].c && l.length) {
                    if (s = l[r - 1], d <= e.e) {
                        var v = l[r - 1].addedLength;
                        e.s <= d && e.e >= d + v ? (this.addSegment(p[i].v[r - 1], p[i].o[r - 1], p[i].i[0], p[i].v[0], n, o, g), g = !1) : (h = bez.getNewSegment(p[i].v[r - 1], p[i].v[0], p[i].o[r - 1], p[i].i[0], (e.s - d) / v, (e.e - d) / v, l[r - 1]), this.addSegmentFromArray(h, n, o, g), g = !1, n.c = !1)
                    } else n.c = !1;
                    d += s.addedLength, o += 1
                }
                if (n._length && (n.setXYAt(n.v[u][0], n.v[u][1], "i", u), n.setXYAt(n.v[n._length - 1][0], n.v[n._length - 1][1], "o", n._length - 1)), d > e.e) break;
                i < f - 1 && (n = shape_pool.newElement(), g = !0, m.push(n), o = 0)
            }
            return m
        }, ShapeModifiers.registerModifier("tm", TrimModifier), extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function (t, e) {
            this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(t, e.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length
        }, RoundCornersModifier.prototype.processPath = function (t, e) {
            var n = shape_pool.newElement();
            n.c = t.c;
            var i, r, a, s, o, l, h, u, c, p, f, d, m, g = t._length,
                v = 0;
            for (i = 0; i < g; i += 1) r = t.v[i], s = t.o[i], a = t.i[i], r[0] === s[0] && r[1] === s[1] && r[0] === a[0] && r[1] === a[1] ? 0 !== i && i !== g - 1 || t.c ? (o = 0 === i ? t.v[g - 1] : t.v[i - 1], h = (l = Math.sqrt(Math.pow(r[0] - o[0], 2) + Math.pow(r[1] - o[1], 2))) ? Math.min(l / 2, e) / l : 0, u = d = r[0] + (o[0] - r[0]) * h, c = m = r[1] - (r[1] - o[1]) * h, p = u - (u - r[0]) * roundCorner, f = c - (c - r[1]) * roundCorner, n.setTripleAt(u, c, p, f, d, m, v), v += 1, o = i === g - 1 ? t.v[0] : t.v[i + 1], h = (l = Math.sqrt(Math.pow(r[0] - o[0], 2) + Math.pow(r[1] - o[1], 2))) ? Math.min(l / 2, e) / l : 0, u = p = r[0] + (o[0] - r[0]) * h, c = f = r[1] + (o[1] - r[1]) * h, d = u - (u - r[0]) * roundCorner, m = c - (c - r[1]) * roundCorner, n.setTripleAt(u, c, p, f, d, m, v), v += 1) : (n.setTripleAt(r[0], r[1], s[0], s[1], a[0], a[1], v), v += 1) : (n.setTripleAt(t.v[i][0], t.v[i][1], t.o[i][0], t.o[i][1], t.i[i][0], t.i[i][1], v), v += 1);
            return n
        }, RoundCornersModifier.prototype.processShapes = function (t) {
            var e, n, i, r, a, s, o = this.shapes.length,
                l = this.rd.v;
            if (0 !== l)
                for (n = 0; n < o; n += 1) {
                    if ((a = this.shapes[n]).shape.paths, s = a.localShapeCollection, a.shape._mdf || this._mdf || t)
                        for (s.releaseShapes(), a.shape._mdf = !0, e = a.shape.paths.shapes, r = a.shape.paths._length, i = 0; i < r; i += 1) s.addShape(this.processPath(e[i], l));
                    a.shape.paths = a.localShapeCollection
                }
            this.dynamicProperties.length || (this._mdf = !1)
        }, ShapeModifiers.registerModifier("rd", RoundCornersModifier), extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function (t, e) {
            this.getValue = this.processKeys, this.c = PropertyFactory.getProp(t, e.c, 0, null, this), this.o = PropertyFactory.getProp(t, e.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(t, e.tr, this), this.so = PropertyFactory.getProp(t, e.tr.so, 0, .01, this), this.eo = PropertyFactory.getProp(t, e.tr.eo, 0, .01, this), this.data = e, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix, this.rMatrix = new Matrix, this.sMatrix = new Matrix, this.tMatrix = new Matrix, this.matrix = new Matrix
        }, RepeaterModifier.prototype.applyTransforms = function (t, e, n, i, r, a) {
            var s = a ? -1 : 1,
                o = i.s.v[0] + (1 - i.s.v[0]) * (1 - r),
                l = i.s.v[1] + (1 - i.s.v[1]) * (1 - r);
            t.translate(i.p.v[0] * s * r, i.p.v[1] * s * r, i.p.v[2]), e.translate(-i.a.v[0], -i.a.v[1], i.a.v[2]), e.rotate(-i.r.v * s * r), e.translate(i.a.v[0], i.a.v[1], i.a.v[2]), n.translate(-i.a.v[0], -i.a.v[1], i.a.v[2]), n.scale(a ? 1 / o : o, a ? 1 / l : l), n.translate(i.a.v[0], i.a.v[1], i.a.v[2])
        }, RepeaterModifier.prototype.init = function (t, e, n, i) {
            this.elem = t, this.arr = e, this.pos = n, this.elemsData = i, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, e[n]);
            for (; n > 0;) n -= 1, this._elements.unshift(e[n]), 1;
            this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
        }, RepeaterModifier.prototype.resetElements = function (t) {
            var e, n = t.length;
            for (e = 0; e < n; e += 1) t[e]._processed = !1, "gr" === t[e].ty && this.resetElements(t[e].it)
        }, RepeaterModifier.prototype.cloneElements = function (t) {
            t.length;
            var e = JSON.parse(JSON.stringify(t));
            return this.resetElements(e), e
        }, RepeaterModifier.prototype.changeGroupRender = function (t, e) {
            var n, i = t.length;
            for (n = 0; n < i; n += 1) t[n]._render = e, "gr" === t[n].ty && this.changeGroupRender(t[n].it, e)
        }, RepeaterModifier.prototype.processShapes = function (t) {
            var e, n, i, r, a;
            if (this._mdf || t) {
                var s, o = Math.ceil(this.c.v);
                if (this._groups.length < o) {
                    for (; this._groups.length < o;) {
                        var l = {
                            it: this.cloneElements(this._elements),
                            ty: "gr"
                        };
                        l.it.push({
                            a: {
                                a: 0,
                                ix: 1,
                                k: [0, 0]
                            },
                            nm: "Transform",
                            o: {
                                a: 0,
                                ix: 7,
                                k: 100
                            },
                            p: {
                                a: 0,
                                ix: 2,
                                k: [0, 0]
                            },
                            r: {
                                a: 1,
                                ix: 6,
                                k: [{
                                    s: 0,
                                    e: 0,
                                    t: 0
                                }, {
                                    s: 0,
                                    e: 0,
                                    t: 1
                                }]
                            },
                            s: {
                                a: 0,
                                ix: 3,
                                k: [100, 100]
                            },
                            sa: {
                                a: 0,
                                ix: 5,
                                k: 0
                            },
                            sk: {
                                a: 0,
                                ix: 4,
                                k: 0
                            },
                            ty: "tr"
                        }), this.arr.splice(0, 0, l), this._groups.splice(0, 0, l), this._currentCopies += 1
                    }
                    this.elem.reloadShapes()
                }
                for (a = 0, i = 0; i <= this._groups.length - 1; i += 1) s = a < o, this._groups[i]._render = s, this.changeGroupRender(this._groups[i].it, s), a += 1;
                this._currentCopies = o;
                var h = this.o.v,
                    u = h % 1,
                    c = h > 0 ? Math.floor(h) : Math.ceil(h),
                    p = (this.tr.v.props, this.pMatrix.props),
                    f = this.rMatrix.props,
                    d = this.sMatrix.props;
                this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset();
                var m, g, v = 0;
                if (h > 0) {
                    for (; v < c;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), v += 1;
                    u && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, u, !1), v += u)
                } else if (h < 0) {
                    for (; v > c;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), v -= 1;
                    u && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -u, !0), v -= u)
                }
                for (i = 1 === this.data.m ? 0 : this._currentCopies - 1, r = 1 === this.data.m ? 1 : -1, a = this._currentCopies; a;) {
                    if (g = (n = (e = this.elemsData[i].it)[e.length - 1].transform.mProps.v.props).length, e[e.length - 1].transform.mProps._mdf = !0, e[e.length - 1].transform.op._mdf = !0, e[e.length - 1].transform.op.v = this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1)), 0 !== v) {
                        for ((0 !== i && 1 === r || i !== this._currentCopies - 1 && -1 === r) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10], f[11], f[12], f[13], f[14], f[15]), this.matrix.transform(d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8], d[9], d[10], d[11], d[12], d[13], d[14], d[15]), this.matrix.transform(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]), m = 0; m < g; m += 1) n[m] = this.matrix.props[m];
                        this.matrix.reset()
                    } else
                        for (this.matrix.reset(), m = 0; m < g; m += 1) n[m] = this.matrix.props[m];
                    v += 1, a -= 1, i += r
                }
            } else
                for (a = this._currentCopies, i = 0, r = 1; a;) n = (e = this.elemsData[i].it)[e.length - 1].transform.mProps.v.props, e[e.length - 1].transform.mProps._mdf = !1, e[e.length - 1].transform.op._mdf = !1, a -= 1, i += r
        }, RepeaterModifier.prototype.addShape = function () {}, ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeCollection.prototype.addShape = function (t) {
            this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = t, this._length += 1
        }, ShapeCollection.prototype.releaseShapes = function () {
            var t;
            for (t = 0; t < this._length; t += 1) shape_pool.release(this.shapes[t]);
            this._length = 0
        }, DashProperty.prototype.getValue = function (t) {
            if ((this.elem.globalData.frameId !== this.frameId || t) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || t, this._mdf)) {
                var e = 0,
                    n = this.dataProps.length;
                for ("svg" === this.renderer && (this.dashStr = ""), e = 0; e < n; e += 1) "o" != this.dataProps[e].n ? "svg" === this.renderer ? this.dashStr += " " + this.dataProps[e].p.v : this.dashArray[e] = this.dataProps[e].p.v : this.dashoffset[0] = this.dataProps[e].p.v
            }
        }, extendPrototype([DynamicPropertyContainer], DashProperty), GradientProperty.prototype.comparePoints = function (t, e) {
            for (var n = 0, i = this.o.length / 2; n < i;) {
                if (Math.abs(t[4 * n] - t[4 * e + 2 * n]) > .01) return !1;
                n += 1
            }
            return !0
        }, GradientProperty.prototype.checkCollapsable = function () {
            if (this.o.length / 2 != this.c.length / 4) return !1;
            if (this.data.k.k[0].s)
                for (var t = 0, e = this.data.k.k.length; t < e;) {
                    if (!this.comparePoints(this.data.k.k[t].s, this.data.p)) return !1;
                    t += 1
                } else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1;
            return !0
        }, GradientProperty.prototype.getValue = function (t) {
            if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || t) {
                var e, n, i, r = 4 * this.data.p;
                for (e = 0; e < r; e += 1) n = e % 4 == 0 ? 100 : 255, i = Math.round(this.prop.v[e] * n), this.c[e] !== i && (this.c[e] = i, this._cmdf = !t);
                if (this.o.length)
                    for (r = this.prop.v.length, e = 4 * this.data.p; e < r; e += 1) n = e % 2 == 0 ? 100 : 1, i = e % 2 == 0 ? Math.round(100 * this.prop.v[e]) : this.prop.v[e], this.o[e - 4 * this.data.p] !== i && (this.o[e - 4 * this.data.p] = i, this._omdf = !t);
                this._mdf = !t
            }
        }, extendPrototype([DynamicPropertyContainer], GradientProperty);
        var buildShapeString = function (t, e, n, i) {
                if (0 === e) return "";
                var r, a = t.o,
                    s = t.i,
                    o = t.v,
                    l = " M" + i.applyToPointStringified(o[0][0], o[0][1]);
                for (r = 1; r < e; r += 1) l += " C" + i.applyToPointStringified(a[r - 1][0], a[r - 1][1]) + " " + i.applyToPointStringified(s[r][0], s[r][1]) + " " + i.applyToPointStringified(o[r][0], o[r][1]);
                return n && e && (l += " C" + i.applyToPointStringified(a[r - 1][0], a[r - 1][1]) + " " + i.applyToPointStringified(s[0][0], s[0][1]) + " " + i.applyToPointStringified(o[0][0], o[0][1]), l += "z"), l
            },
            ImagePreloader = function () {
                var t = function () {
                    var t = createTag("canvas");
                    t.width = 1, t.height = 1;
                    var e = t.getContext("2d");
                    return e.fillStyle = "rgba(0,0,0,0)", e.fillRect(0, 0, 1, 1), t
                }();

                function e() {
                    this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.imagesLoadedCb && this.imagesLoadedCb(null)
                }

                function n(e) {
                    var n = function (t, e, n) {
                            var i = "";
                            if (t.e) i = t.p;
                            else if (e) {
                                var r = t.p; - 1 !== r.indexOf("images/") && (r = r.split("/")[1]), i = e + r
                            } else i = n, i += t.u ? t.u : "", i += t.p;
                            return i
                        }(e, this.assetsPath, this.path),
                        i = createTag("img");
                    i.crossOrigin = "anonymous", i.addEventListener("load", this._imageLoaded.bind(this), !1), i.addEventListener("error", function () {
                        r.img = t, this._imageLoaded()
                    }.bind(this), !1), i.src = n;
                    var r = {
                        img: i,
                        assetData: e
                    };
                    return r
                }

                function i(t, e) {
                    this.imagesLoadedCb = e;
                    var n, i = t.length;
                    for (n = 0; n < i; n += 1) t[n].layers || (this.totalImages += 1, this.images.push(this._createImageData(t[n])))
                }

                function r(t) {
                    this.path = t || ""
                }

                function a(t) {
                    this.assetsPath = t || ""
                }

                function s(t) {
                    for (var e = 0, n = this.images.length; e < n;) {
                        if (this.images[e].assetData === t) return this.images[e].img;
                        e += 1
                    }
                }

                function o() {
                    this.imagesLoadedCb = null, this.images.length = 0
                }

                function l() {
                    return this.totalImages === this.loadedAssets
                }
                return function () {
                    this.loadAssets = i, this.setAssetsPath = a, this.setPath = r, this.loaded = l, this.destroy = o, this.getImage = s, this._createImageData = n, this._imageLoaded = e, this.assetsPath = "", this.path = "", this.totalImages = 0, this.loadedAssets = 0, this.imagesLoadedCb = null, this.images = []
                }
            }(),
            featureSupport = function () {
                var t = {
                    maskType: !0
                };
                return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (t.maskType = !1), t
            }(),
            filtersFactory = function () {
                var t = {};
                return t.createFilter = function (t) {
                    var e = createNS("filter");
                    return e.setAttribute("id", t), e.setAttribute("filterUnits", "objectBoundingBox"), e.setAttribute("x", "0%"), e.setAttribute("y", "0%"), e.setAttribute("width", "100%"), e.setAttribute("height", "100%"), e
                }, t.createAlphaToLuminanceFilter = function () {
                    var t = createNS("feColorMatrix");
                    return t.setAttribute("type", "matrix"), t.setAttribute("color-interpolation-filters", "sRGB"), t.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), t
                }, t
            }();
//        ,
//            assetLoader = function () {
//                function t(t) {
//                    return t.response && "object" == typeof t.response ? t.response : t.response && "string" == typeof t.response ? JSON.parse(t.response) : t.responseText ? JSON.parse(t.responseText) : void 0
//                }
//                return {
//                    load: function (e, n, i) {
//                        var r, a = new XMLHttpRequest;
//                        a.open("GET", e, !0);
//                        try {
//                            a.responseType = "json"
//                        } catch (t) {}
//                        a.send(), a.onreadystatechange = function () {
//                            if (4 == a.readyState)
//                                if (200 == a.status) r = t(a), n(r);
//                                else try {
//                                    r = t(a), n(r)
//                                } catch (t) {
//                                    i && i(t)
//                                }
//                        }
//                    }
//                }
//            }();

        function TextAnimatorProperty(t, e, n) {
            this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = t, this._renderType = e, this._elem = n, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = {
                alignment: {}
            }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(n)
        }

        function TextAnimatorDataProperty(t, e, n) {
            var i = {
                    propType: !1
                },
                r = PropertyFactory.getProp,
                a = e.a;
            this.a = {
                r: a.r ? r(t, a.r, 0, degToRads, n) : i,
                rx: a.rx ? r(t, a.rx, 0, degToRads, n) : i,
                ry: a.ry ? r(t, a.ry, 0, degToRads, n) : i,
                sk: a.sk ? r(t, a.sk, 0, degToRads, n) : i,
                sa: a.sa ? r(t, a.sa, 0, degToRads, n) : i,
                s: a.s ? r(t, a.s, 1, .01, n) : i,
                a: a.a ? r(t, a.a, 1, 0, n) : i,
                o: a.o ? r(t, a.o, 0, .01, n) : i,
                p: a.p ? r(t, a.p, 1, 0, n) : i,
                sw: a.sw ? r(t, a.sw, 0, 0, n) : i,
                sc: a.sc ? r(t, a.sc, 1, 0, n) : i,
                fc: a.fc ? r(t, a.fc, 1, 0, n) : i,
                fh: a.fh ? r(t, a.fh, 0, 0, n) : i,
                fs: a.fs ? r(t, a.fs, 0, .01, n) : i,
                fb: a.fb ? r(t, a.fb, 0, .01, n) : i,
                t: a.t ? r(t, a.t, 0, 0, n) : i
            }, this.s = TextSelectorProp.getTextSelectorProp(t, e.s, n), this.s.t = e.s.t
        }

        function LetterProps(t, e, n, i, r, a) {
            this.o = t, this.sw = e, this.sc = n, this.fc = i, this.m = r, this.p = a, this._mdf = {
                o: !0,
                sw: !!e,
                sc: !!n,
                fc: !!i,
                m: !0,
                p: !0
            }
        }

        function TextProperty(t, e) {
            this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, this.data = e, this.elem = t, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = {
                ascent: 0,
                boxWidth: this.defaultBoxWidth,
                f: "",
                fStyle: "",
                fWeight: "",
                fc: "",
                j: "",
                justifyOffset: "",
                l: [],
                lh: 0,
                lineWidths: [],
                ls: "",
                of: "",
                s: "",
                sc: "",
                sw: 0,
                t: 0,
                tr: 0,
                sz: 0,
                ps: null,
                fillColorAnim: !1,
                strokeColorAnim: !1,
                strokeWidthAnim: !1,
                yOffset: 0,
                finalSize: 0,
                finalText: [],
                finalLineHeight: 0,
                __complete: !1
            }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData)
        }
        TextAnimatorProperty.prototype.searchProperties = function () {
            var t, e, n = this._textData.a.length,
                i = PropertyFactory.getProp;
            for (t = 0; t < n; t += 1) e = this._textData.a[t], this._animatorsData[t] = new TextAnimatorDataProperty(this._elem, e, this);
            this._textData.p && "m" in this._textData.p ? (this._pathData = {
                f: i(this._elem, this._textData.p.f, 0, 0, this),
                l: i(this._elem, this._textData.p.l, 0, 0, this),
                r: this._textData.p.r,
                m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
            }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = i(this._elem, this._textData.m.a, 1, 0, this)
        }, TextAnimatorProperty.prototype.getMeasures = function (t, e) {
            if (this.lettersChangedFlag = e, this._mdf || this._isFirstFrame || e || this._hasMaskedPath && this._pathData.m._mdf) {
                this._isFirstFrame = !1;
                var n, i, r, a, s, o, l, h, u, c, p, f, d, m, g, v, y, _, x, b = this._moreOptions.alignment.v,
                    E = this._animatorsData,
                    w = this._textData,
                    D = this.mHelper,
                    M = this._renderType,
                    S = this.renderedLetters.length,
                    T = (this.data, t.l);
                if (this._hasMaskedPath) {
                    if (x = this._pathData.m, !this._pathData.n || this._pathData._mdf) {
                        var A, C = x.v;
                        for (this._pathData.r && (C = C.reverse()), s = {
                                tLength: 0,
                                segments: []
                            }, a = C._length - 1, v = 0, r = 0; r < a; r += 1) A = bez.buildBezierData(C.v[r], C.v[r + 1], [C.o[r][0] - C.v[r][0], C.o[r][1] - C.v[r][1]], [C.i[r + 1][0] - C.v[r + 1][0], C.i[r + 1][1] - C.v[r + 1][1]]), s.tLength += A.segmentLength, s.segments.push(A), v += A.segmentLength;
                        r = a, x.v.c && (A = bez.buildBezierData(C.v[r], C.v[0], [C.o[r][0] - C.v[r][0], C.o[r][1] - C.v[r][1]], [C.i[0][0] - C.v[0][0], C.i[0][1] - C.v[0][1]]), s.tLength += A.segmentLength, s.segments.push(A), v += A.segmentLength), this._pathData.pi = s
                    }
                    if (s = this._pathData.pi, o = this._pathData.f.v, p = 0, c = 1, h = 0, u = !0, m = s.segments, o < 0 && x.v.c)
                        for (s.tLength < Math.abs(o) && (o = -Math.abs(o) % s.tLength), c = (d = m[p = m.length - 1].points).length - 1; o < 0;) o += d[c].partialLength, (c -= 1) < 0 && (c = (d = m[p -= 1].points).length - 1);
                    f = (d = m[p].points)[c - 1], g = (l = d[c]).partialLength
                }
                a = T.length, n = 0, i = 0;
                var P, F, L, R, I = 1.2 * t.finalSize * .714,
                    k = !0;
                L = E.length;
                var O, N, B, z, U, V, G, H, j, W, X, q, Y, Z = -1,
                    J = o,
                    K = p,
                    $ = c,
                    Q = -1,
                    tt = "",
                    et = this.defaultPropsArray;
                if (2 === t.j || 1 === t.j) {
                    var nt = 0,
                        it = 0,
                        rt = 2 === t.j ? -.5 : -1,
                        at = 0,
                        st = !0;
                    for (r = 0; r < a; r += 1)
                        if (T[r].n) {
                            for (nt && (nt += it); at < r;) T[at].animatorJustifyOffset = nt, at += 1;
                            nt = 0, st = !0
                        } else {
                            for (F = 0; F < L; F += 1)(P = E[F].a).t.propType && (st && 2 === t.j && (it += P.t.v * rt), (O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars)).length ? nt += P.t.v * O[0] * rt : nt += P.t.v * O * rt);
                            st = !1
                        } for (nt && (nt += it); at < r;) T[at].animatorJustifyOffset = nt, at += 1
                }
                for (r = 0; r < a; r += 1) {
                    if (D.reset(), U = 1, T[r].n) n = 0, i += t.yOffset, i += k ? 1 : 0, o = J, k = !1, 0, this._hasMaskedPath && (c = $, f = (d = m[p = K].points)[c - 1], g = (l = d[c]).partialLength, h = 0), Y = W = q = tt = "", et = this.defaultPropsArray;
                    else {
                        if (this._hasMaskedPath) {
                            if (Q !== T[r].line) {
                                switch (t.j) {
                                    case 1:
                                        o += v - t.lineWidths[T[r].line];
                                        break;
                                    case 2:
                                        o += (v - t.lineWidths[T[r].line]) / 2
                                }
                                Q = T[r].line
                            }
                            Z !== T[r].ind && (T[Z] && (o += T[Z].extra), o += T[r].an / 2, Z = T[r].ind), o += b[0] * T[r].an / 200;
                            var ot = 0;
                            for (F = 0; F < L; F += 1)(P = E[F].a).p.propType && ((O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars)).length ? ot += P.p.v[0] * O[0] : ot += P.p.v[0] * O), P.a.propType && ((O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars)).length ? ot += P.a.v[0] * O[0] : ot += P.a.v[0] * O);
                            for (u = !0; u;) h + g >= o + ot || !d ? (y = (o + ot - h) / l.partialLength, B = f.point[0] + (l.point[0] - f.point[0]) * y, z = f.point[1] + (l.point[1] - f.point[1]) * y, D.translate(-b[0] * T[r].an / 200, -b[1] * I / 100), u = !1) : d && (h += l.partialLength, (c += 1) >= d.length && (c = 0, m[p += 1] ? d = m[p].points : x.v.c ? (c = 0, d = m[p = 0].points) : (h -= l.partialLength, d = null)), d && (f = l, g = (l = d[c]).partialLength));
                            N = T[r].an / 2 - T[r].add, D.translate(-N, 0, 0)
                        } else N = T[r].an / 2 - T[r].add, D.translate(-N, 0, 0), D.translate(-b[0] * T[r].an / 200, -b[1] * I / 100, 0);
                        for (T[r].l / 2, F = 0; F < L; F += 1)(P = E[F].a).t.propType && (O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars), 0 === n && 0 === t.j || (this._hasMaskedPath ? O.length ? o += P.t.v * O[0] : o += P.t.v * O : O.length ? n += P.t.v * O[0] : n += P.t.v * O));
                        for (T[r].l / 2, t.strokeWidthAnim && (G = t.sw || 0), t.strokeColorAnim && (V = t.sc ? [t.sc[0], t.sc[1], t.sc[2]] : [0, 0, 0]), t.fillColorAnim && t.fc && (H = [t.fc[0], t.fc[1], t.fc[2]]), F = 0; F < L; F += 1)(P = E[F].a).a.propType && ((O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars)).length ? D.translate(-P.a.v[0] * O[0], -P.a.v[1] * O[1], P.a.v[2] * O[2]) : D.translate(-P.a.v[0] * O, -P.a.v[1] * O, P.a.v[2] * O));
                        for (F = 0; F < L; F += 1)(P = E[F].a).s.propType && ((O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars)).length ? D.scale(1 + (P.s.v[0] - 1) * O[0], 1 + (P.s.v[1] - 1) * O[1], 1) : D.scale(1 + (P.s.v[0] - 1) * O, 1 + (P.s.v[1] - 1) * O, 1));
                        for (F = 0; F < L; F += 1) {
                            if (P = E[F].a, O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars), P.sk.propType && (O.length ? D.skewFromAxis(-P.sk.v * O[0], P.sa.v * O[1]) : D.skewFromAxis(-P.sk.v * O, P.sa.v * O)), P.r.propType && (O.length ? D.rotateZ(-P.r.v * O[2]) : D.rotateZ(-P.r.v * O)), P.ry.propType && (O.length ? D.rotateY(P.ry.v * O[1]) : D.rotateY(P.ry.v * O)), P.rx.propType && (O.length ? D.rotateX(P.rx.v * O[0]) : D.rotateX(P.rx.v * O)), P.o.propType && (O.length ? U += (P.o.v * O[0] - U) * O[0] : U += (P.o.v * O - U) * O), t.strokeWidthAnim && P.sw.propType && (O.length ? G += P.sw.v * O[0] : G += P.sw.v * O), t.strokeColorAnim && P.sc.propType)
                                for (j = 0; j < 3; j += 1) O.length ? V[j] = V[j] + (P.sc.v[j] - V[j]) * O[0] : V[j] = V[j] + (P.sc.v[j] - V[j]) * O;
                            if (t.fillColorAnim && t.fc) {
                                if (P.fc.propType)
                                    for (j = 0; j < 3; j += 1) O.length ? H[j] = H[j] + (P.fc.v[j] - H[j]) * O[0] : H[j] = H[j] + (P.fc.v[j] - H[j]) * O;
                                P.fh.propType && (H = O.length ? addHueToRGB(H, P.fh.v * O[0]) : addHueToRGB(H, P.fh.v * O)), P.fs.propType && (H = O.length ? addSaturationToRGB(H, P.fs.v * O[0]) : addSaturationToRGB(H, P.fs.v * O)), P.fb.propType && (H = O.length ? addBrightnessToRGB(H, P.fb.v * O[0]) : addBrightnessToRGB(H, P.fb.v * O))
                            }
                        }
                        for (F = 0; F < L; F += 1)(P = E[F].a).p.propType && (O = E[F].s.getMult(T[r].anIndexes[F], w.a[F].s.totalChars), this._hasMaskedPath ? O.length ? D.translate(0, P.p.v[1] * O[0], -P.p.v[2] * O[1]) : D.translate(0, P.p.v[1] * O, -P.p.v[2] * O) : O.length ? D.translate(P.p.v[0] * O[0], P.p.v[1] * O[1], -P.p.v[2] * O[2]) : D.translate(P.p.v[0] * O, P.p.v[1] * O, -P.p.v[2] * O));
                        if (t.strokeWidthAnim && (W = G < 0 ? 0 : G), t.strokeColorAnim && (X = "rgb(" + Math.round(255 * V[0]) + "," + Math.round(255 * V[1]) + "," + Math.round(255 * V[2]) + ")"), t.fillColorAnim && t.fc && (q = "rgb(" + Math.round(255 * H[0]) + "," + Math.round(255 * H[1]) + "," + Math.round(255 * H[2]) + ")"), this._hasMaskedPath) {
                            if (D.translate(0, -t.ls), D.translate(0, b[1] * I / 100 + i, 0), w.p.p) {
                                _ = (l.point[1] - f.point[1]) / (l.point[0] - f.point[0]);
                                var lt = 180 * Math.atan(_) / Math.PI;
                                l.point[0] < f.point[0] && (lt += 180), D.rotate(-lt * Math.PI / 180)
                            }
                            D.translate(B, z, 0), o -= b[0] * T[r].an / 200, T[r + 1] && Z !== T[r + 1].ind && (o += T[r].an / 2, o += t.tr / 1e3 * t.finalSize)
                        } else {
                            switch (D.translate(n, i, 0), t.ps && D.translate(t.ps[0], t.ps[1] + t.ascent, 0), t.j) {
                                case 1:
                                    D.translate(T[r].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[T[r].line]), 0, 0);
                                    break;
                                case 2:
                                    D.translate(T[r].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[T[r].line]) / 2, 0, 0)
                            }
                            D.translate(0, -t.ls), D.translate(N, 0, 0), D.translate(b[0] * T[r].an / 200, b[1] * I / 100, 0), n += T[r].l + t.tr / 1e3 * t.finalSize
                        }
                        "html" === M ? tt = D.toCSS() : "svg" === M ? tt = D.to2dCSS() : et = [D.props[0], D.props[1], D.props[2], D.props[3], D.props[4], D.props[5], D.props[6], D.props[7], D.props[8], D.props[9], D.props[10], D.props[11], D.props[12], D.props[13], D.props[14], D.props[15]], Y = U
                    }
                    S <= r ? (R = new LetterProps(Y, W, X, q, tt, et), this.renderedLetters.push(R), S += 1, this.lettersChangedFlag = !0) : (R = this.renderedLetters[r], this.lettersChangedFlag = R.update(Y, W, X, q, tt, et) || this.lettersChangedFlag)
                }
            }
        }, TextAnimatorProperty.prototype.getValue = function () {
            this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties())
        }, TextAnimatorProperty.prototype.mHelper = new Matrix, TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty), LetterProps.prototype.update = function (t, e, n, i, r, a) {
            this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1;
            var s = !1;
            return this.o !== t && (this.o = t, this._mdf.o = !0, s = !0), this.sw !== e && (this.sw = e, this._mdf.sw = !0, s = !0), this.sc !== n && (this.sc = n, this._mdf.sc = !0, s = !0), this.fc !== i && (this.fc = i, this._mdf.fc = !0, s = !0), this.m !== r && (this.m = r, this._mdf.m = !0, s = !0), !a.length || this.p[0] === a[0] && this.p[1] === a[1] && this.p[4] === a[4] && this.p[5] === a[5] && this.p[12] === a[12] && this.p[13] === a[13] || (this.p = a, this._mdf.p = !0, s = !0), s
        }, TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function (t, e) {
            for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
            return t
        }, TextProperty.prototype.setCurrentData = function (t) {
            t.__complete || this.completeTextData(t), this.currentData = t, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0
        }, TextProperty.prototype.searchProperty = function () {
            return this.searchKeyframes()
        }, TextProperty.prototype.searchKeyframes = function () {
            return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf
        }, TextProperty.prototype.addEffect = function (t) {
            this.effectsSequence.push(t), this.elem.addDynamicProperty(this)
        }, TextProperty.prototype.getValue = function (t) {
            if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length || t) {
                this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                var e = this.currentData,
                    n = this.keysIndex;
                if (this.lock) this.setCurrentData(this.currentData);
                else {
                    this.lock = !0, this._mdf = !1;
                    var i, r = this.effectsSequence.length,
                        a = t || this.data.d.k[this.keysIndex].s;
                    for (i = 0; i < r; i += 1) a = n !== this.keysIndex ? this.effectsSequence[i](a, a.t) : this.effectsSequence[i](this.currentData, a.t);
                    e !== a && this.setCurrentData(a), this.pv = this.v = this.currentData, this.lock = !1, this.frameId = this.elem.globalData.frameId
                }
            }
        }, TextProperty.prototype.getKeyframeValue = function () {
            for (var t = this.data.d.k, e = this.elem.comp.renderedFrame, n = 0, i = t.length; n <= i - 1 && (t[n].s, !(n === i - 1 || t[n + 1].t > e));) n += 1;
            return this.keysIndex !== n && (this.keysIndex = n), this.data.d.k[this.keysIndex].s
        }, TextProperty.prototype.buildFinalText = function (t) {
            for (var e, n = FontManager.getCombinedCharacterCodes(), i = [], r = 0, a = t.length; r < a;) e = t.charCodeAt(r), -1 !== n.indexOf(e) ? i[i.length - 1] += t.charAt(r) : e >= 55296 && e <= 56319 && (e = t.charCodeAt(r + 1)) >= 56320 && e <= 57343 ? (i.push(t.substr(r, 2)), ++r) : i.push(t.charAt(r)), r += 1;
            return i
        }, TextProperty.prototype.completeTextData = function (t) {
            t.__complete = !0;
            var e, n, i, r, a, s, o, l = this.elem.globalData.fontManager,
                h = this.data,
                u = [],
                c = 0,
                p = h.m.g,
                f = 0,
                d = 0,
                m = 0,
                g = [],
                v = 0,
                y = 0,
                _ = l.getFontByName(t.f),
                x = 0,
                b = _.fStyle ? _.fStyle.split(" ") : [],
                E = "normal",
                w = "normal";
            for (n = b.length, e = 0; e < n; e += 1) switch (b[e].toLowerCase()) {
                case "italic":
                    w = "italic";
                    break;
                case "bold":
                    E = "700";
                    break;
                case "black":
                    E = "900";
                    break;
                case "medium":
                    E = "500";
                    break;
                case "regular":
                case "normal":
                    E = "400";
                    break;
                case "light":
                case "thin":
                    E = "200"
            }
            t.fWeight = _.fWeight || E, t.fStyle = w, t.finalSize = t.s, t.finalText = this.buildFinalText(t.t), n = t.finalText.length, t.finalLineHeight = t.lh;
            var D, M = t.tr / 1e3 * t.finalSize;
            if (t.sz)
                for (var S, T, A = !0, C = t.sz[0], P = t.sz[1]; A;) {
                    S = 0, v = 0, n = (T = this.buildFinalText(t.t)).length, M = t.tr / 1e3 * t.finalSize;
                    var F = -1;
                    for (e = 0; e < n; e += 1) D = T[e].charCodeAt(0), i = !1, " " === T[e] ? F = e : 13 !== D && 3 !== D || (v = 0, i = !0, S += t.finalLineHeight || 1.2 * t.finalSize), l.chars ? (o = l.getCharData(T[e], _.fStyle, _.fFamily), x = i ? 0 : o.w * t.finalSize / 100) : x = l.measureText(T[e], t.f, t.finalSize), v + x > C && " " !== T[e] ? (-1 === F ? n += 1 : e = F, S += t.finalLineHeight || 1.2 * t.finalSize, T.splice(e, F === e ? 1 : 0, "\r"), F = -1, v = 0) : (v += x, v += M);
                    S += _.ascent * t.finalSize / 100, this.canResize && t.finalSize > this.minimumFontSize && P < S ? (t.finalSize -= 1, t.finalLineHeight = t.finalSize * t.lh / t.s) : (t.finalText = T, n = t.finalText.length, A = !1)
                }
            v = -M, x = 0;
            var L, R = 0;
            for (e = 0; e < n; e += 1)
                if (i = !1, 13 === (D = (L = t.finalText[e]).charCodeAt(0)) || 3 === D ? (R = 0, g.push(v), y = v > y ? v : y, v = -2 * M, r = "", i = !0, m += 1) : r = L, l.chars ? (o = l.getCharData(L, _.fStyle, l.getFontByName(t.f).fFamily), x = i ? 0 : o.w * t.finalSize / 100) : x = l.measureText(r, t.f, t.finalSize), " " === L ? R += x + M : (v += x + M + R, R = 0), u.push({
                        l: x,
                        an: x,
                        add: f,
                        n: i,
                        anIndexes: [],
                        val: r,
                        line: m,
                        animatorJustifyOffset: 0
                    }), 2 == p) {
                    if (f += x, "" === r || " " === r || e === n - 1) {
                        for ("" !== r && " " !== r || (f -= x); d <= e;) u[d].an = f, u[d].ind = c, u[d].extra = x, d += 1;
                        c += 1, f = 0
                    }
                } else if (3 == p) {
                if (f += x, "" === r || e === n - 1) {
                    for ("" === r && (f -= x); d <= e;) u[d].an = f, u[d].ind = c, u[d].extra = x, d += 1;
                    f = 0, c += 1
                }
            } else u[c].ind = c, u[c].extra = 0, c += 1;
            if (t.l = u, y = v > y ? v : y, g.push(v), t.sz) t.boxWidth = t.sz[0], t.justifyOffset = 0;
            else switch (t.boxWidth = y, t.j) {
                case 1:
                    t.justifyOffset = -t.boxWidth;
                    break;
                case 2:
                    t.justifyOffset = -t.boxWidth / 2;
                    break;
                default:
                    t.justifyOffset = 0
            }
            t.lineWidths = g;
            var I, k, O = h.a;
            s = O.length;
            var N, B, z = [];
            for (a = 0; a < s; a += 1) {
                for ((I = O[a]).a.sc && (t.strokeColorAnim = !0), I.a.sw && (t.strokeWidthAnim = !0), (I.a.fc || I.a.fh || I.a.fs || I.a.fb) && (t.fillColorAnim = !0), B = 0, N = I.s.b, e = 0; e < n; e += 1)(k = u[e]).anIndexes[a] = B, (1 == N && "" !== k.val || 2 == N && "" !== k.val && " " !== k.val || 3 == N && (k.n || " " == k.val || e == n - 1) || 4 == N && (k.n || e == n - 1)) && (1 === I.s.rn && z.push(B), B += 1);
                h.a[a].s.totalChars = B;
                var U, V = -1;
                if (1 === I.s.rn)
                    for (e = 0; e < n; e += 1) V != (k = u[e]).anIndexes[a] && (V = k.anIndexes[a], U = z.splice(Math.floor(Math.random() * z.length), 1)[0]), k.anIndexes[a] = U
            }
            t.yOffset = t.finalLineHeight || 1.2 * t.finalSize, t.ls = t.ls || 0, t.ascent = _.ascent * t.finalSize / 100
        }, TextProperty.prototype.updateDocumentData = function (t, e) {
            e = void 0 === e ? this.keysIndex : e;
            var n = this.copyData({}, this.data.d.k[e].s);
            n = this.copyData(n, t), this.data.d.k[e].s = n, this.recalculate(e), this.elem.addDynamicProperty(this)
        }, TextProperty.prototype.recalculate = function (t) {
            var e = this.data.d.k[t].s;
            e.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(e)
        }, TextProperty.prototype.canResizeFont = function (t) {
            this.canResize = t, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
        }, TextProperty.prototype.setMinimumFontSize = function (t) {
            this.minimumFontSize = Math.floor(t) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
        };
        var TextSelectorProp = function () {
                var t = Math.max,
                    e = Math.min,
                    n = Math.floor;

                function i(t, e) {
                    this._currentTextLength = -1, this.k = !1, this.data = e, this.elem = t, this.comp = t.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(t), this.s = PropertyFactory.getProp(t, e.s || {
                        k: 0
                    }, 0, 0, this), this.e = "e" in e ? PropertyFactory.getProp(t, e.e, 0, 0, this) : {
                        v: 100
                    }, this.o = PropertyFactory.getProp(t, e.o || {
                        k: 0
                    }, 0, 0, this), this.xe = PropertyFactory.getProp(t, e.xe || {
                        k: 0
                    }, 0, 0, this), this.ne = PropertyFactory.getProp(t, e.ne || {
                        k: 0
                    }, 0, 0, this), this.a = PropertyFactory.getProp(t, e.a, 0, .01, this), this.dynamicProperties.length || this.getValue()
                }
                return i.prototype = {
                    getMult: function (i) {
                        this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
                        var r = 0,
                            a = 0,
                            s = 1,
                            o = 1;
                        this.ne.v > 0 ? r = this.ne.v / 100 : a = -this.ne.v / 100, this.xe.v > 0 ? s = 1 - this.xe.v / 100 : o = 1 + this.xe.v / 100;
                        var l = BezierFactory.getBezierEasing(r, a, s, o).get,
                            h = 0,
                            u = this.finalS,
                            c = this.finalE,
                            p = this.data.sh;
                        if (2 === p) h = l(h = c === u ? i >= c ? 1 : 0 : t(0, e(.5 / (c - u) + (i - u) / (c - u), 1)));
                        else if (3 === p) h = l(h = c === u ? i >= c ? 0 : 1 : 1 - t(0, e(.5 / (c - u) + (i - u) / (c - u), 1)));
                        else if (4 === p) c === u ? h = 0 : (h = t(0, e(.5 / (c - u) + (i - u) / (c - u), 1))) < .5 ? h *= 2 : h = 1 - 2 * (h - .5), h = l(h);
                        else if (5 === p) {
                            if (c === u) h = 0;
                            else {
                                var f = c - u,
                                    d = -f / 2 + (i = e(t(0, i + .5 - u), c - u)),
                                    m = f / 2;
                                h = Math.sqrt(1 - d * d / (m * m))
                            }
                            h = l(h)
                        } else 6 === p ? (c === u ? h = 0 : (i = e(t(0, i + .5 - u), c - u), h = (1 + Math.cos(Math.PI + 2 * Math.PI * i / (c - u))) / 2), h = l(h)) : (i >= n(u) && (h = t(0, e(i - u < 0 ? e(c, 1) - (u - i) : c - i, 1))), h = l(h));
                        return h * this.a.v
                    },
                    getValue: function (t) {
                        this.iterateDynamicProperties(), this._mdf = t || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, t && 2 === this.data.r && (this.e.v = this._currentTextLength);
                        var e = 2 === this.data.r ? 1 : 100 / this.data.totalChars,
                            n = this.o.v / e,
                            i = this.s.v / e + n,
                            r = this.e.v / e + n;
                        if (i > r) {
                            var a = i;
                            i = r, r = a
                        }
                        this.finalS = i, this.finalE = r
                    }
                }, extendPrototype([DynamicPropertyContainer], i), {
                    getTextSelectorProp: function (t, e, n) {
                        return new i(t, e, n)
                    }
                }
            }(),
            pool_factory = function (t, e, n, i) {
                var r = 0,
                    a = t,
                    s = createSizedArray(a);

                function o() {
                    return r ? s[r -= 1] : e()
                }
                return {
                    newElement: o,
                    release: function (t) {
                        r === a && (s = pooling.double(s), a *= 2), n && n(t), s[r] = t, r += 1
                    }
                }
            },
            pooling = {
                double: function (t) {
                    return t.concat(createSizedArray(t.length))
                }
            },
            point_pool = pool_factory(8, (function () {
                return createTypedArray("float32", 2)
            })),
            shape_pool = (factory = pool_factory(4, (function () {
                return new ShapePath
            }), (function (t) {
                var e, n = t._length;
                for (e = 0; e < n; e += 1) point_pool.release(t.v[e]), point_pool.release(t.i[e]), point_pool.release(t.o[e]), t.v[e] = null, t.i[e] = null, t.o[e] = null;
                t._length = 0, t.c = !1
            })), factory.clone = function (t) {
                var e, n = factory.newElement(),
                    i = void 0 === t._length ? t.v.length : t._length;
                for (n.setLength(i), n.c = t.c, e = 0; e < i; e += 1) n.setTripleAt(t.v[e][0], t.v[e][1], t.o[e][0], t.o[e][1], t.i[e][0], t.i[e][1], e);
                return n
            }, factory),
            factory, shapeCollection_pool = function () {
                var t = {
                        newShapeCollection: function () {
                            var t;
                            t = e ? i[e -= 1] : new ShapeCollection;
                            return t
                        },
                        release: function (t) {
                            var r, a = t._length;
                            for (r = 0; r < a; r += 1) shape_pool.release(t.shapes[r]);
                            t._length = 0, e === n && (i = pooling.double(i), n *= 2);
                            i[e] = t, e += 1
                        }
                    },
                    e = 0,
                    n = 4,
                    i = createSizedArray(n);
                return t
            }(),
            segments_length_pool = pool_factory(8, (function () {
                return {
                    lengths: [],
                    totalLength: 0
                }
            }), (function (t) {
                var e, n = t.lengths.length;
                for (e = 0; e < n; e += 1) bezier_length_pool.release(t.lengths[e]);
                t.lengths.length = 0
            })),
            bezier_length_pool = pool_factory(8, (function () {
                return {
                    addedLength: 0,
                    percents: createTypedArray("float32", defaultCurveSegments),
                    lengths: createTypedArray("float32", defaultCurveSegments)
                }
            }));

        function BaseRenderer() {}

        function SVGRenderer(t, e) {
            this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg");
            var n = "";
            if (e && e.title) {
                var i = createNS("title"),
                    r = createElementID();
                i.setAttribute("id", r), i.textContent = e.title, this.svgElement.appendChild(i), n += r
            }
            if (e && e.description) {
                var a = createNS("desc"),
                    s = createElementID();
                a.setAttribute("id", s), a.textContent = e.description, this.svgElement.appendChild(a), n += " " + s
            }
            n && this.svgElement.setAttribute("aria-labelledby", n);
            var o = createNS("defs");
            this.svgElement.appendChild(o);
            var l = createNS("g");
            this.svgElement.appendChild(l), this.layerElement = l, this.renderConfig = {
                preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet",
                imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                progressiveLoad: e && e.progressiveLoad || !1,
                hideOnTransparent: !e || !1 !== e.hideOnTransparent,
                viewBoxOnly: e && e.viewBoxOnly || !1,
                viewBoxSize: e && e.viewBoxSize || !1,
                className: e && e.className || "",
                id: e && e.id || "",
                focusable: e && e.focusable,
                filterSize: {
                    width: e && e.filterSize && e.filterSize.width || "100%",
                    height: e && e.filterSize && e.filterSize.height || "100%",
                    x: e && e.filterSize && e.filterSize.x || "0%",
                    y: e && e.filterSize && e.filterSize.y || "0%"
                }
            }, this.globalData = {
                _mdf: !1,
                frameNum: -1,
                defs: o,
                renderConfig: this.renderConfig
            }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg"
        }

        function CanvasRenderer(t, e) {
            this.animationItem = t, this.renderConfig = {
                clearCanvas: !e || void 0 === e.clearCanvas || e.clearCanvas,
                context: e && e.context || null,
                progressiveLoad: e && e.progressiveLoad || !1,
                preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet",
                imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                className: e && e.className || "",
                id: e && e.id || ""
            }, this.renderConfig.dpr = e && e.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = e && e.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = {
                frameNum: -1,
                _mdf: !1,
                renderConfig: this.renderConfig,
                currentGlobalAlpha: -1
            }, this.contextData = new CVContextData, this.elements = [], this.pendingElements = [], this.transformMat = new Matrix, this.completeLayers = !1, this.rendererType = "canvas"
        }

        function HybridRenderer(t, e) {
            this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
                className: e && e.className || "",
                imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                hideOnTransparent: !e || !1 !== e.hideOnTransparent,
                filterSize: {
                    width: e && e.filterSize && e.filterSize.width || "400%",
                    height: e && e.filterSize && e.filterSize.height || "400%",
                    x: e && e.filterSize && e.filterSize.x || "-100%",
                    y: e && e.filterSize && e.filterSize.y || "-100%"
                }
            }, this.globalData = {
                _mdf: !1,
                frameNum: -1,
                renderConfig: this.renderConfig
            }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html"
        }

        function MaskElement(t, e, n) {
            this.data = t, this.element = e, this.globalData = n, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null;
            var i, r = this.globalData.defs,
                a = this.masksProperties ? this.masksProperties.length : 0;
            this.viewData = createSizedArray(a), this.solidPath = "";
            var s, o, l, h, u, c, p, f = this.masksProperties,
                d = 0,
                m = [],
                g = createElementID(),
                v = "clipPath",
                y = "clip-path";
            for (i = 0; i < a; i++)
                if (("a" !== f[i].mode && "n" !== f[i].mode || f[i].inv || 100 !== f[i].o.k || f[i].o.x) && (v = "mask", y = "mask"), "s" != f[i].mode && "i" != f[i].mode || 0 !== d ? h = null : ((h = createNS("rect")).setAttribute("fill", "#ffffff"), h.setAttribute("width", this.element.comp.data.w || 0), h.setAttribute("height", this.element.comp.data.h || 0), m.push(h)), s = createNS("path"), "n" != f[i].mode) {
                    var _;
                    if (d += 1, s.setAttribute("fill", "s" === f[i].mode ? "#000000" : "#ffffff"), s.setAttribute("clip-rule", "nonzero"), 0 !== f[i].x.k ? (v = "mask", y = "mask", p = PropertyFactory.getProp(this.element, f[i].x, 0, null, this.element), _ = createElementID(), (u = createNS("filter")).setAttribute("id", _), (c = createNS("feMorphology")).setAttribute("operator", "erode"), c.setAttribute("in", "SourceGraphic"), c.setAttribute("radius", "0"), u.appendChild(c), r.appendChild(u), s.setAttribute("stroke", "s" === f[i].mode ? "#000000" : "#ffffff")) : (c = null, p = null), this.storedData[i] = {
                            elem: s,
                            x: p,
                            expan: c,
                            lastPath: "",
                            lastOperator: "",
                            filterId: _,
                            lastRadius: 0
                        }, "i" == f[i].mode) {
                        l = m.length;
                        var x = createNS("g");
                        for (o = 0; o < l; o += 1) x.appendChild(m[o]);
                        var b = createNS("mask");
                        b.setAttribute("mask-type", "alpha"), b.setAttribute("id", g + "_" + d), b.appendChild(s), r.appendChild(b), x.setAttribute("mask", "url(" + locationHref + "#" + g + "_" + d + ")"), m.length = 0, m.push(x)
                    } else m.push(s);
                    f[i].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[i] = {
                        elem: s,
                        lastPath: "",
                        op: PropertyFactory.getProp(this.element, f[i].o, 0, .01, this.element),
                        prop: ShapePropertyFactory.getShapeProp(this.element, f[i], 3),
                        invRect: h
                    }, this.viewData[i].prop.k || this.drawPath(f[i], this.viewData[i].prop.v, this.viewData[i])
                } else this.viewData[i] = {
                    op: PropertyFactory.getProp(this.element, f[i].o, 0, .01, this.element),
                    prop: ShapePropertyFactory.getShapeProp(this.element, f[i], 3),
                    elem: s,
                    lastPath: ""
                }, r.appendChild(s);
            for (this.maskElement = createNS(v), a = m.length, i = 0; i < a; i += 1) this.maskElement.appendChild(m[i]);
            d > 0 && (this.maskElement.setAttribute("id", g), this.element.maskedElement.setAttribute(y, "url(" + locationHref + "#" + g + ")"), r.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this)
        }

        function HierarchyElement() {}

        function FrameElement() {}

        function TransformElement() {}

        function RenderableElement() {}

        function RenderableDOMElement() {}

        function ProcessedElement(t, e) {
            this.elem = t, this.pos = e
        }

        function SVGStyleData(t, e) {
            this.data = t, this.type = t.ty, this.d = "", this.lvl = e, this._mdf = !1, this.closed = !0 === t.hd, this.pElem = createNS("path"), this.msElem = null
        }

        function SVGShapeData(t, e, n) {
            this.caches = [], this.styles = [], this.transformers = t, this.lStr = "", this.sh = n, this.lvl = e, this._isAnimated = !!n.k;
            for (var i = 0, r = t.length; i < r;) {
                if (t[i].mProps.dynamicProperties.length) {
                    this._isAnimated = !0;
                    break
                }
                i += 1
            }
        }

        function SVGTransformData(t, e, n) {
            this.transform = {
                mProps: t,
                op: e,
                container: n
            }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
        }

        function SVGStrokeStyleData(t, e, n) {
            this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.w = PropertyFactory.getProp(t, e.w, 0, null, this), this.d = new DashProperty(t, e.d || {}, "svg", this), this.c = PropertyFactory.getProp(t, e.c, 1, 255, this), this.style = n, this._isAnimated = !!this._isAnimated
        }

        function SVGFillStyleData(t, e, n) {
            this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.c = PropertyFactory.getProp(t, e.c, 1, 255, this), this.style = n
        }

        function SVGGradientFillStyleData(t, e, n) {
            this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.initGradientData(t, e, n)
        }

        function SVGGradientStrokeStyleData(t, e, n) {
            this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(t, e.w, 0, null, this), this.d = new DashProperty(t, e.d || {}, "svg", this), this.initGradientData(t, e, n), this._isAnimated = !!this._isAnimated
        }

        function ShapeGroupData() {
            this.it = [], this.prevViewData = [], this.gr = createNS("g")
        }
        BaseRenderer.prototype.checkLayers = function (t) {
            var e, n, i = this.layers.length;
            for (this.completeLayers = !0, e = i - 1; e >= 0; e--) this.elements[e] || (n = this.layers[e]).ip - n.st <= t - this.layers[e].st && n.op - n.st > t - this.layers[e].st && this.buildItem(e), this.completeLayers = !!this.elements[e] && this.completeLayers;
            this.checkPendingElements()
        }, BaseRenderer.prototype.createItem = function (t) {
            switch (t.ty) {
                case 2:
                    return this.createImage(t);
                case 0:
                    return this.createComp(t);
                case 1:
                    return this.createSolid(t);
                case 3:
                    return this.createNull(t);
                case 4:
                    return this.createShape(t);
                case 5:
                    return this.createText(t);
                case 13:
                    return this.createCamera(t)
            }
            return this.createNull(t)
        }, BaseRenderer.prototype.createCamera = function () {
            throw new Error("You're using a 3d camera. Try the html renderer.")
        }, BaseRenderer.prototype.buildAllItems = function () {
            var t, e = this.layers.length;
            for (t = 0; t < e; t += 1) this.buildItem(t);
            this.checkPendingElements()
        }, BaseRenderer.prototype.includeLayers = function (t) {
            this.completeLayers = !1;
            var e, n, i = t.length,
                r = this.layers.length;
            for (e = 0; e < i; e += 1)
                for (n = 0; n < r;) {
                    if (this.layers[n].id == t[e].id) {
                        this.layers[n] = t[e];
                        break
                    }
                    n += 1
                }
        }, BaseRenderer.prototype.setProjectInterface = function (t) {
            this.globalData.projectInterface = t
        }, BaseRenderer.prototype.initItems = function () {
            this.globalData.progressiveLoad || this.buildAllItems()
        }, BaseRenderer.prototype.buildElementParenting = function (t, e, n) {
            for (var i = this.elements, r = this.layers, a = 0, s = r.length; a < s;) r[a].ind == e && (i[a] && !0 !== i[a] ? (n.push(i[a]), i[a].setAsParent(), void 0 !== r[a].parent ? this.buildElementParenting(t, r[a].parent, n) : t.setHierarchy(n)) : (this.buildItem(a), this.addPendingElement(t))), a += 1
        }, BaseRenderer.prototype.addPendingElement = function (t) {
            this.pendingElements.push(t)
        }, BaseRenderer.prototype.searchExtraCompositions = function (t) {
            var e, n = t.length;
            for (e = 0; e < n; e += 1)
                if (t[e].xt) {
                    var i = this.createComp(t[e]);
                    i.initExpressions(), this.globalData.projectInterface.registerComposition(i)
                }
        }, BaseRenderer.prototype.setupGlobalData = function (t, e) {
            this.globalData.fontManager = new FontManager, this.globalData.fontManager.addChars(t.chars), this.globalData.fontManager.addFonts(t.fonts, e), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.frameId = 0, this.globalData.frameRate = t.fr, this.globalData.nm = t.nm, this.globalData.compSize = {
                w: t.w,
                h: t.h
            }
        }, extendPrototype([BaseRenderer], SVGRenderer), SVGRenderer.prototype.createNull = function (t) {
            return new NullElement(t, this.globalData, this)
        }, SVGRenderer.prototype.createShape = function (t) {
            return new SVGShapeElement(t, this.globalData, this)
        }, SVGRenderer.prototype.createText = function (t) {
            return new SVGTextElement(t, this.globalData, this)
        }, SVGRenderer.prototype.createImage = function (t) {
            return new IImageElement(t, this.globalData, this)
        }, SVGRenderer.prototype.createComp = function (t) {
            return new SVGCompElement(t, this.globalData, this)
        }, SVGRenderer.prototype.createSolid = function (t) {
            return new ISolidElement(t, this.globalData, this)
        }, SVGRenderer.prototype.configAnimation = function (t) {
            this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + t.w + " " + t.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", t.w), this.svgElement.setAttribute("height", t.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)"), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), void 0 !== this.renderConfig.focusable && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement);
            var e = this.globalData.defs;
            this.setupGlobalData(t, e), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = t;
            var n = createNS("clipPath"),
                i = createNS("rect");
            i.setAttribute("width", t.w), i.setAttribute("height", t.h), i.setAttribute("x", 0), i.setAttribute("y", 0);
            var r = createElementID();
            n.setAttribute("id", r), n.appendChild(i), this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + r + ")"), e.appendChild(n), this.layers = t.layers, this.elements = createSizedArray(t.layers.length)
        }, SVGRenderer.prototype.destroy = function () {
            this.animationItem.wrapper.innerHTML = "", this.layerElement = null, this.globalData.defs = null;
            var t, e = this.layers ? this.layers.length : 0;
            for (t = 0; t < e; t++) this.elements[t] && this.elements[t].destroy();
            this.elements.length = 0, this.destroyed = !0, this.animationItem = null
        }, SVGRenderer.prototype.updateContainerSize = function () {}, SVGRenderer.prototype.buildItem = function (t) {
            var e = this.elements;
            if (!e[t] && 99 != this.layers[t].ty) {
                e[t] = !0;
                var n = this.createItem(this.layers[t]);
                e[t] = n, expressionsPlugin && (0 === this.layers[t].ty && this.globalData.projectInterface.registerComposition(n), n.initExpressions()), this.appendElementInPos(n, t), this.layers[t].tt && (this.elements[t - 1] && !0 !== this.elements[t - 1] ? n.setMatte(e[t - 1].layerId) : (this.buildItem(t - 1), this.addPendingElement(n)))
            }
        }, SVGRenderer.prototype.checkPendingElements = function () {
            for (; this.pendingElements.length;) {
                var t = this.pendingElements.pop();
                if (t.checkParenting(), t.data.tt)
                    for (var e = 0, n = this.elements.length; e < n;) {
                        if (this.elements[e] === t) {
                            t.setMatte(this.elements[e - 1].layerId);
                            break
                        }
                        e += 1
                    }
            }
        }, SVGRenderer.prototype.renderFrame = function (t) {
            if (this.renderedFrame !== t && !this.destroyed) {
                null === t ? t = this.renderedFrame : this.renderedFrame = t, this.globalData.frameNum = t, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = t, this.globalData._mdf = !1;
                var e, n = this.layers.length;
                for (this.completeLayers || this.checkLayers(t), e = n - 1; e >= 0; e--)(this.completeLayers || this.elements[e]) && this.elements[e].prepareFrame(t - this.layers[e].st);
                if (this.globalData._mdf)
                    for (e = 0; e < n; e += 1)(this.completeLayers || this.elements[e]) && this.elements[e].renderFrame()
            }
        }, SVGRenderer.prototype.appendElementInPos = function (t, e) {
            var n = t.getBaseElement();
            if (n) {
                for (var i, r = 0; r < e;) this.elements[r] && !0 !== this.elements[r] && this.elements[r].getBaseElement() && (i = this.elements[r].getBaseElement()), r += 1;
                i ? this.layerElement.insertBefore(n, i) : this.layerElement.appendChild(n)
            }
        }, SVGRenderer.prototype.hide = function () {
            this.layerElement.style.display = "none"
        }, SVGRenderer.prototype.show = function () {
            this.layerElement.style.display = "block"
        }, extendPrototype([BaseRenderer], CanvasRenderer), CanvasRenderer.prototype.createShape = function (t) {
            return new CVShapeElement(t, this.globalData, this)
        }, CanvasRenderer.prototype.createText = function (t) {
            return new CVTextElement(t, this.globalData, this)
        }, CanvasRenderer.prototype.createImage = function (t) {
            return new CVImageElement(t, this.globalData, this)
        }, CanvasRenderer.prototype.createComp = function (t) {
            return new CVCompElement(t, this.globalData, this)
        }, CanvasRenderer.prototype.createSolid = function (t) {
            return new CVSolidElement(t, this.globalData, this)
        }, CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRenderer.prototype.ctxTransform = function (t) {
            if (1 !== t[0] || 0 !== t[1] || 0 !== t[4] || 1 !== t[5] || 0 !== t[12] || 0 !== t[13])
                if (this.renderConfig.clearCanvas) {
                    this.transformMat.cloneFromProps(t);
                    var e = this.contextData.cTr.props;
                    this.transformMat.transform(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]), this.contextData.cTr.cloneFromProps(this.transformMat.props);
                    var n = this.contextData.cTr.props;
                    this.canvasContext.setTransform(n[0], n[1], n[4], n[5], n[12], n[13])
                } else this.canvasContext.transform(t[0], t[1], t[4], t[5], t[12], t[13])
        }, CanvasRenderer.prototype.ctxOpacity = function (t) {
            if (!this.renderConfig.clearCanvas) return this.canvasContext.globalAlpha *= t < 0 ? 0 : t, void(this.globalData.currentGlobalAlpha = this.contextData.cO);
            this.contextData.cO *= t < 0 ? 0 : t, this.globalData.currentGlobalAlpha !== this.contextData.cO && (this.canvasContext.globalAlpha = this.contextData.cO, this.globalData.currentGlobalAlpha = this.contextData.cO)
        }, CanvasRenderer.prototype.reset = function () {
            this.renderConfig.clearCanvas ? this.contextData.reset() : this.canvasContext.restore()
        }, CanvasRenderer.prototype.save = function (t) {
            if (this.renderConfig.clearCanvas) {
                t && this.canvasContext.save();
                var e = this.contextData.cTr.props;
                this.contextData._length <= this.contextData.cArrPos && this.contextData.duplicate();
                var n, i = this.contextData.saved[this.contextData.cArrPos];
                for (n = 0; n < 16; n += 1) i[n] = e[n];
                this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO, this.contextData.cArrPos += 1
            } else this.canvasContext.save()
        }, CanvasRenderer.prototype.restore = function (t) {
            if (this.renderConfig.clearCanvas) {
                t && (this.canvasContext.restore(), this.globalData.blendMode = "source-over"), this.contextData.cArrPos -= 1;
                var e, n = this.contextData.saved[this.contextData.cArrPos],
                    i = this.contextData.cTr.props;
                for (e = 0; e < 16; e += 1) i[e] = n[e];
                this.canvasContext.setTransform(n[0], n[1], n[4], n[5], n[12], n[13]), n = this.contextData.savedOp[this.contextData.cArrPos], this.contextData.cO = n, this.globalData.currentGlobalAlpha !== n && (this.canvasContext.globalAlpha = n, this.globalData.currentGlobalAlpha = n)
            } else this.canvasContext.restore()
        }, CanvasRenderer.prototype.configAnimation = function (t) {
            this.animationItem.wrapper ? (this.animationItem.container = createTag("canvas"), this.animationItem.container.style.width = "100%", this.animationItem.container.style.height = "100%", this.animationItem.container.style.transformOrigin = this.animationItem.container.style.mozTransformOrigin = this.animationItem.container.style.webkitTransformOrigin = this.animationItem.container.style["-webkit-transform"] = "0px 0px 0px", this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)) : this.canvasContext = this.renderConfig.context, this.data = t, this.layers = t.layers, this.transformCanvas = {
                w: t.w,
                h: t.h,
                sx: 0,
                sy: 0,
                tx: 0,
                ty: 0
            }, this.setupGlobalData(t, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(t.layers.length), this.updateContainerSize()
        }, CanvasRenderer.prototype.updateContainerSize = function () {
            var t, e, n, i;
            if (this.reset(), this.animationItem.wrapper && this.animationItem.container ? (t = this.animationItem.wrapper.offsetWidth, e = this.animationItem.wrapper.offsetHeight, this.animationItem.container.setAttribute("width", t * this.renderConfig.dpr), this.animationItem.container.setAttribute("height", e * this.renderConfig.dpr)) : (t = this.canvasContext.canvas.width * this.renderConfig.dpr, e = this.canvasContext.canvas.height * this.renderConfig.dpr), -1 !== this.renderConfig.preserveAspectRatio.indexOf("meet") || -1 !== this.renderConfig.preserveAspectRatio.indexOf("slice")) {
                var r = this.renderConfig.preserveAspectRatio.split(" "),
                    a = r[1] || "meet",
                    s = r[0] || "xMidYMid",
                    o = s.substr(0, 4),
                    l = s.substr(4);
                n = t / e, (i = this.transformCanvas.w / this.transformCanvas.h) > n && "meet" === a || i < n && "slice" === a ? (this.transformCanvas.sx = t / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = t / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = e / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = e / (this.transformCanvas.h / this.renderConfig.dpr)), this.transformCanvas.tx = "xMid" === o && (i < n && "meet" === a || i > n && "slice" === a) ? (t - this.transformCanvas.w * (e / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : "xMax" === o && (i < n && "meet" === a || i > n && "slice" === a) ? (t - this.transformCanvas.w * (e / this.transformCanvas.h)) * this.renderConfig.dpr : 0, this.transformCanvas.ty = "YMid" === l && (i > n && "meet" === a || i < n && "slice" === a) ? (e - this.transformCanvas.h * (t / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : "YMax" === l && (i > n && "meet" === a || i < n && "slice" === a) ? (e - this.transformCanvas.h * (t / this.transformCanvas.w)) * this.renderConfig.dpr : 0
            } else "none" == this.renderConfig.preserveAspectRatio ? (this.transformCanvas.sx = t / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = e / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0);
            this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0)
        }, CanvasRenderer.prototype.destroy = function () {
            var t;
            for (this.renderConfig.clearCanvas && (this.animationItem.wrapper.innerHTML = ""), t = (this.layers ? this.layers.length : 0) - 1; t >= 0; t -= 1) this.elements[t] && this.elements[t].destroy();
            this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0
        }, CanvasRenderer.prototype.renderFrame = function (t, e) {
            if ((this.renderedFrame !== t || !0 !== this.renderConfig.clearCanvas || e) && !this.destroyed && -1 !== t) {
                this.renderedFrame = t, this.globalData.frameNum = t - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || e, this.globalData.projectInterface.currentFrame = t;
                var n, i = this.layers.length;
                for (this.completeLayers || this.checkLayers(t), n = 0; n < i; n++)(this.completeLayers || this.elements[n]) && this.elements[n].prepareFrame(t - this.layers[n].st);
                if (this.globalData._mdf) {
                    for (!0 === this.renderConfig.clearCanvas ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), n = i - 1; n >= 0; n -= 1)(this.completeLayers || this.elements[n]) && this.elements[n].renderFrame();
                    !0 !== this.renderConfig.clearCanvas && this.restore()
                }
            }
        }, CanvasRenderer.prototype.buildItem = function (t) {
            var e = this.elements;
            if (!e[t] && 99 != this.layers[t].ty) {
                var n = this.createItem(this.layers[t], this, this.globalData);
                e[t] = n, n.initExpressions()
            }
        }, CanvasRenderer.prototype.checkPendingElements = function () {
            for (; this.pendingElements.length;) {
                this.pendingElements.pop().checkParenting()
            }
        }, CanvasRenderer.prototype.hide = function () {
            this.animationItem.container.style.display = "none"
        }, CanvasRenderer.prototype.show = function () {
            this.animationItem.container.style.display = "block"
        }, extendPrototype([BaseRenderer], HybridRenderer), HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRenderer.prototype.checkPendingElements = function () {
            for (; this.pendingElements.length;) {
                this.pendingElements.pop().checkParenting()
            }
        }, HybridRenderer.prototype.appendElementInPos = function (t, e) {
            var n = t.getBaseElement();
            if (n) {
                var i = this.layers[e];
                if (i.ddd && this.supports3d) this.addTo3dContainer(n, e);
                else if (this.threeDElements) this.addTo3dContainer(n, e);
                else {
                    for (var r, a, s = 0; s < e;) this.elements[s] && !0 !== this.elements[s] && this.elements[s].getBaseElement && (a = this.elements[s], r = (this.layers[s].ddd ? this.getThreeDContainerByPos(s) : a.getBaseElement()) || r), s += 1;
                    r ? i.ddd && this.supports3d || this.layerElement.insertBefore(n, r) : i.ddd && this.supports3d || this.layerElement.appendChild(n)
                }
            }
        }, HybridRenderer.prototype.createShape = function (t) {
            return this.supports3d ? new HShapeElement(t, this.globalData, this) : new SVGShapeElement(t, this.globalData, this)
        }, HybridRenderer.prototype.createText = function (t) {
            return this.supports3d ? new HTextElement(t, this.globalData, this) : new SVGTextElement(t, this.globalData, this)
        }, HybridRenderer.prototype.createCamera = function (t) {
            return this.camera = new HCameraElement(t, this.globalData, this), this.camera
        }, HybridRenderer.prototype.createImage = function (t) {
            return this.supports3d ? new HImageElement(t, this.globalData, this) : new IImageElement(t, this.globalData, this)
        }, HybridRenderer.prototype.createComp = function (t) {
            return this.supports3d ? new HCompElement(t, this.globalData, this) : new SVGCompElement(t, this.globalData, this)
        }, HybridRenderer.prototype.createSolid = function (t) {
            return this.supports3d ? new HSolidElement(t, this.globalData, this) : new ISolidElement(t, this.globalData, this)
        }, HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull, HybridRenderer.prototype.getThreeDContainerByPos = function (t) {
            for (var e = 0, n = this.threeDElements.length; e < n;) {
                if (this.threeDElements[e].startPos <= t && this.threeDElements[e].endPos >= t) return this.threeDElements[e].perspectiveElem;
                e += 1
            }
        }, HybridRenderer.prototype.createThreeDContainer = function (t, e) {
            var n = createTag("div");
            styleDiv(n);
            var i = createTag("div");
            styleDiv(i), "3d" === e && (n.style.width = this.globalData.compSize.w + "px", n.style.height = this.globalData.compSize.h + "px", n.style.transformOrigin = n.style.mozTransformOrigin = n.style.webkitTransformOrigin = "50% 50%", i.style.transform = i.style.webkitTransform = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)"), n.appendChild(i);
            var r = {
                container: i,
                perspectiveElem: n,
                startPos: t,
                endPos: t,
                type: e
            };
            return this.threeDElements.push(r), r
        }, HybridRenderer.prototype.build3dContainers = function () {
            var t, e, n = this.layers.length,
                i = "";
            for (t = 0; t < n; t += 1) this.layers[t].ddd && 3 !== this.layers[t].ty ? ("3d" !== i && (i = "3d", e = this.createThreeDContainer(t, "3d")), e.endPos = Math.max(e.endPos, t)) : ("2d" !== i && (i = "2d", e = this.createThreeDContainer(t, "2d")), e.endPos = Math.max(e.endPos, t));
            for (t = (n = this.threeDElements.length) - 1; t >= 0; t--) this.resizerElem.appendChild(this.threeDElements[t].perspectiveElem)
        }, HybridRenderer.prototype.addTo3dContainer = function (t, e) {
            for (var n = 0, i = this.threeDElements.length; n < i;) {
                if (e <= this.threeDElements[n].endPos) {
                    for (var r, a = this.threeDElements[n].startPos; a < e;) this.elements[a] && this.elements[a].getBaseElement && (r = this.elements[a].getBaseElement()), a += 1;
                    r ? this.threeDElements[n].container.insertBefore(t, r) : this.threeDElements[n].container.appendChild(t);
                    break
                }
                n += 1
            }
        }, HybridRenderer.prototype.configAnimation = function (t) {
            var e = createTag("div"),
                n = this.animationItem.wrapper;
            e.style.width = t.w + "px", e.style.height = t.h + "px", this.resizerElem = e, styleDiv(e), e.style.transformStyle = e.style.webkitTransformStyle = e.style.mozTransformStyle = "flat", this.renderConfig.className && e.setAttribute("class", this.renderConfig.className), n.appendChild(e), e.style.overflow = "hidden";
            var i = createNS("svg");
            i.setAttribute("width", "1"), i.setAttribute("height", "1"), styleDiv(i), this.resizerElem.appendChild(i);
            var r = createNS("defs");
            i.appendChild(r), this.data = t, this.setupGlobalData(t, i), this.globalData.defs = r, this.layers = t.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize()
        }, HybridRenderer.prototype.destroy = function () {
            this.animationItem.wrapper.innerHTML = "", this.animationItem.container = null, this.globalData.defs = null;
            var t, e = this.layers ? this.layers.length : 0;
            for (t = 0; t < e; t++) this.elements[t].destroy();
            this.elements.length = 0, this.destroyed = !0, this.animationItem = null
        }, HybridRenderer.prototype.updateContainerSize = function () {
            var t, e, n, i, r = this.animationItem.wrapper.offsetWidth,
                a = this.animationItem.wrapper.offsetHeight,
                s = r / a;
            this.globalData.compSize.w / this.globalData.compSize.h > s ? (t = r / this.globalData.compSize.w, e = r / this.globalData.compSize.w, n = 0, i = (a - this.globalData.compSize.h * (r / this.globalData.compSize.w)) / 2) : (t = a / this.globalData.compSize.h, e = a / this.globalData.compSize.h, n = (r - this.globalData.compSize.w * (a / this.globalData.compSize.h)) / 2, i = 0), this.resizerElem.style.transform = this.resizerElem.style.webkitTransform = "matrix3d(" + t + ",0,0,0,0," + e + ",0,0,0,0,1,0," + n + "," + i + ",0,1)"
        }, HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRenderer.prototype.hide = function () {
            this.resizerElem.style.display = "none"
        }, HybridRenderer.prototype.show = function () {
            this.resizerElem.style.display = "block"
        }, HybridRenderer.prototype.initItems = function () {
            if (this.buildAllItems(), this.camera) this.camera.setup();
            else {
                var t, e = this.globalData.compSize.w,
                    n = this.globalData.compSize.h,
                    i = this.threeDElements.length;
                for (t = 0; t < i; t += 1) this.threeDElements[t].perspectiveElem.style.perspective = this.threeDElements[t].perspectiveElem.style.webkitPerspective = Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2)) + "px"
            }
        }, HybridRenderer.prototype.searchExtraCompositions = function (t) {
            var e, n = t.length,
                i = createTag("div");
            for (e = 0; e < n; e += 1)
                if (t[e].xt) {
                    var r = this.createComp(t[e], i, this.globalData.comp, null);
                    r.initExpressions(), this.globalData.projectInterface.registerComposition(r)
                }
        }, MaskElement.prototype.getMaskProperty = function (t) {
            return this.viewData[t].prop
        }, MaskElement.prototype.renderFrame = function (t) {
            var e, n = this.element.finalTransform.mat,
                i = this.masksProperties.length;
            for (e = 0; e < i; e++)
                if ((this.viewData[e].prop._mdf || t) && this.drawPath(this.masksProperties[e], this.viewData[e].prop.v, this.viewData[e]), (this.viewData[e].op._mdf || t) && this.viewData[e].elem.setAttribute("fill-opacity", this.viewData[e].op.v), "n" !== this.masksProperties[e].mode && (this.viewData[e].invRect && (this.element.finalTransform.mProp._mdf || t) && this.viewData[e].invRect.setAttribute("transform", n.getInverseMatrix().to2dCSS()), this.storedData[e].x && (this.storedData[e].x._mdf || t))) {
                    var r = this.storedData[e].expan;
                    this.storedData[e].x.v < 0 ? ("erode" !== this.storedData[e].lastOperator && (this.storedData[e].lastOperator = "erode", this.storedData[e].elem.setAttribute("filter", "url(" + locationHref + "#" + this.storedData[e].filterId + ")")), r.setAttribute("radius", -this.storedData[e].x.v)) : ("dilate" !== this.storedData[e].lastOperator && (this.storedData[e].lastOperator = "dilate", this.storedData[e].elem.setAttribute("filter", null)), this.storedData[e].elem.setAttribute("stroke-width", 2 * this.storedData[e].x.v))
                }
        }, MaskElement.prototype.getMaskelement = function () {
            return this.maskElement
        }, MaskElement.prototype.createLayerSolidPath = function () {
            var t = "M0,0 ";
            return t += " h" + this.globalData.compSize.w, t += " v" + this.globalData.compSize.h, t += " h-" + this.globalData.compSize.w, t += " v-" + this.globalData.compSize.h + " "
        }, MaskElement.prototype.drawPath = function (t, e, n) {
            var i, r, a = " M" + e.v[0][0] + "," + e.v[0][1];
            for (r = e._length, i = 1; i < r; i += 1) a += " C" + e.o[i - 1][0] + "," + e.o[i - 1][1] + " " + e.i[i][0] + "," + e.i[i][1] + " " + e.v[i][0] + "," + e.v[i][1];
            if (e.c && r > 1 && (a += " C" + e.o[i - 1][0] + "," + e.o[i - 1][1] + " " + e.i[0][0] + "," + e.i[0][1] + " " + e.v[0][0] + "," + e.v[0][1]), n.lastPath !== a) {
                var s = "";
                n.elem && (e.c && (s = t.inv ? this.solidPath + a : a), n.elem.setAttribute("d", s)), n.lastPath = a
            }
        }, MaskElement.prototype.destroy = function () {
            this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null
        }, HierarchyElement.prototype = {
            initHierarchy: function () {
                this.hierarchy = [], this._isParent = !1, this.checkParenting()
            },
            setHierarchy: function (t) {
                this.hierarchy = t
            },
            setAsParent: function () {
                this._isParent = !0
            },
            checkParenting: function () {
                void 0 !== this.data.parent && this.comp.buildElementParenting(this, this.data.parent, [])
            }
        }, FrameElement.prototype = {
            initFrame: function () {
                this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1
            },
            prepareProperties: function (t, e) {
                var n, i = this.dynamicProperties.length;
                for (n = 0; n < i; n += 1)(e || this._isParent && "transform" === this.dynamicProperties[n].propType) && (this.dynamicProperties[n].getValue(), this.dynamicProperties[n]._mdf && (this.globalData._mdf = !0, this._mdf = !0))
            },
            addDynamicProperty: function (t) {
                -1 === this.dynamicProperties.indexOf(t) && this.dynamicProperties.push(t)
            }
        }, TransformElement.prototype = {
            initTransform: function () {
                this.finalTransform = {
                    mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                        o: 0
                    },
                    _matMdf: !1,
                    _opMdf: !1,
                    mat: new Matrix
                }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty
            },
            renderTransform: function () {
                if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) {
                    var t, e = this.finalTransform.mat,
                        n = 0,
                        i = this.hierarchy.length;
                    if (!this.finalTransform._matMdf)
                        for (; n < i;) {
                            if (this.hierarchy[n].finalTransform.mProp._mdf) {
                                this.finalTransform._matMdf = !0;
                                break
                            }
                            n += 1
                        }
                    if (this.finalTransform._matMdf)
                        for (t = this.finalTransform.mProp.v.props, e.cloneFromProps(t), n = 0; n < i; n += 1) t = this.hierarchy[n].finalTransform.mProp.v.props, e.transform(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15])
                }
            },
            globalToLocal: function (t) {
                var e = [];
                e.push(this.finalTransform);
                for (var n = !0, i = this.comp; n;) i.finalTransform ? (i.data.hasMask && e.splice(0, 0, i.finalTransform), i = i.comp) : n = !1;
                var r, a, s = e.length;
                for (r = 0; r < s; r += 1) a = e[r].mat.applyToPointArray(0, 0, 0), t = [t[0] - a[0], t[1] - a[1], 0];
                return t
            },
            mHelper: new Matrix
        }, RenderableElement.prototype = {
            initRenderable: function () {
                this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = []
            },
            addRenderableComponent: function (t) {
                -1 === this.renderableComponents.indexOf(t) && this.renderableComponents.push(t)
            },
            removeRenderableComponent: function (t) {
                -1 !== this.renderableComponents.indexOf(t) && this.renderableComponents.splice(this.renderableComponents.indexOf(t), 1)
            },
            prepareRenderableFrame: function (t) {
                this.checkLayerLimits(t)
            },
            checkTransparency: function () {
                this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show())
            },
            checkLayerLimits: function (t) {
                this.data.ip - this.data.st <= t && this.data.op - this.data.st > t ? !0 !== this.isInRange && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : !1 !== this.isInRange && (this.globalData._mdf = !0, this.isInRange = !1, this.hide())
            },
            renderRenderable: function () {
                var t, e = this.renderableComponents.length;
                for (t = 0; t < e; t += 1) this.renderableComponents[t].renderFrame(this._isFirstFrame)
            },
            sourceRectAtTime: function () {
                return {
                    top: 0,
                    left: 0,
                    width: 100,
                    height: 100
                }
            },
            getLayerSize: function () {
                return 5 === this.data.ty ? {
                    w: this.data.textData.width,
                    h: this.data.textData.height
                } : {
                    w: this.data.width,
                    h: this.data.height
                }
            }
        }, extendPrototype([RenderableElement, createProxyFunction({
            initElement: function (t, e, n) {
                this.initFrame(), this.initBaseData(t, e, n), this.initTransform(t, e, n), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide()
            },
            hide: function () {
                this.hidden || this.isInRange && !this.isTransparent || ((this.baseElement || this.layerElement).style.display = "none", this.hidden = !0)
            },
            show: function () {
                this.isInRange && !this.isTransparent && (this.data.hd || ((this.baseElement || this.layerElement).style.display = "block"), this.hidden = !1, this._isFirstFrame = !0)
            },
            renderFrame: function () {
                this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
            },
            renderInnerContent: function () {},
            prepareFrame: function (t) {
                this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.checkTransparency()
            },
            destroy: function () {
                this.innerElem = null, this.destroyBaseElement()
            }
        })], RenderableDOMElement), SVGStyleData.prototype.reset = function () {
            this.d = "", this._mdf = !1
        }, SVGShapeData.prototype.setAsAnimated = function () {
            this._isAnimated = !0
        }, extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData), extendPrototype([DynamicPropertyContainer], SVGFillStyleData), SVGGradientFillStyleData.prototype.initGradientData = function (t, e, n) {
            this.o = PropertyFactory.getProp(t, e.o, 0, .01, this), this.s = PropertyFactory.getProp(t, e.s, 1, null, this), this.e = PropertyFactory.getProp(t, e.e, 1, null, this), this.h = PropertyFactory.getProp(t, e.h || {
                k: 0
            }, 0, .01, this), this.a = PropertyFactory.getProp(t, e.a || {
                k: 0
            }, 0, degToRads, this), this.g = new GradientProperty(t, e.g, this), this.style = n, this.stops = [], this.setGradientData(n.pElem, e), this.setGradientOpacity(e, n), this._isAnimated = !!this._isAnimated
        }, SVGGradientFillStyleData.prototype.setGradientData = function (t, e) {
            var n = createElementID(),
                i = createNS(1 === e.t ? "linearGradient" : "radialGradient");
            i.setAttribute("id", n), i.setAttribute("spreadMethod", "pad"), i.setAttribute("gradientUnits", "userSpaceOnUse");
            var r, a, s, o = [];
            for (s = 4 * e.g.p, a = 0; a < s; a += 4) r = createNS("stop"), i.appendChild(r), o.push(r);
            t.setAttribute("gf" === e.ty ? "fill" : "stroke", "url(" + locationHref + "#" + n + ")"), this.gf = i, this.cst = o
        }, SVGGradientFillStyleData.prototype.setGradientOpacity = function (t, e) {
            if (this.g._hasOpacity && !this.g._collapsable) {
                var n, i, r, a = createNS("mask"),
                    s = createNS("path");
                a.appendChild(s);
                var o = createElementID(),
                    l = createElementID();
                a.setAttribute("id", l);
                var h = createNS(1 === t.t ? "linearGradient" : "radialGradient");
                h.setAttribute("id", o), h.setAttribute("spreadMethod", "pad"), h.setAttribute("gradientUnits", "userSpaceOnUse"), r = t.g.k.k[0].s ? t.g.k.k[0].s.length : t.g.k.k.length;
                var u = this.stops;
                for (i = 4 * t.g.p; i < r; i += 2)(n = createNS("stop")).setAttribute("stop-color", "rgb(255,255,255)"), h.appendChild(n), u.push(n);
                s.setAttribute("gf" === t.ty ? "fill" : "stroke", "url(" + locationHref + "#" + o + ")"), this.of = h, this.ms = a, this.ost = u, this.maskId = l, e.msElem = s
            }
        }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData), extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
        var SVGElementsRenderer = function () {
            var t = new Matrix,
                e = new Matrix;

            function n(t, e, n) {
                (n || e.transform.op._mdf) && e.transform.container.setAttribute("opacity", e.transform.op.v), (n || e.transform.mProps._mdf) && e.transform.container.setAttribute("transform", e.transform.mProps.v.to2dCSS())
            }

            function i(n, i, r) {
                var a, s, o, l, h, u, c, p, f, d, m, g = i.styles.length,
                    v = i.lvl;
                for (u = 0; u < g; u += 1) {
                    if (l = i.sh._mdf || r, i.styles[u].lvl < v) {
                        for (p = e.reset(), d = v - i.styles[u].lvl, m = i.transformers.length - 1; !l && d > 0;) l = i.transformers[m].mProps._mdf || l, d--, m--;
                        if (l)
                            for (d = v - i.styles[u].lvl, m = i.transformers.length - 1; d > 0;) f = i.transformers[m].mProps.v.props, p.transform(f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9], f[10], f[11], f[12], f[13], f[14], f[15]), d--, m--
                    } else p = t;
                    if (s = (c = i.sh.paths)._length, l) {
                        for (o = "", a = 0; a < s; a += 1)(h = c.shapes[a]) && h._length && (o += buildShapeString(h, h._length, h.c, p));
                        i.caches[u] = o
                    } else o = i.caches[u];
                    i.styles[u].d += !0 === n.hd ? "" : o, i.styles[u]._mdf = l || i.styles[u]._mdf
                }
            }

            function r(t, e, n) {
                var i = e.style;
                (e.c._mdf || n) && i.pElem.setAttribute("fill", "rgb(" + bm_floor(e.c.v[0]) + "," + bm_floor(e.c.v[1]) + "," + bm_floor(e.c.v[2]) + ")"), (e.o._mdf || n) && i.pElem.setAttribute("fill-opacity", e.o.v)
            }

            function a(t, e, n) {
                s(t, e, n), o(t, e, n)
            }

            function s(t, e, n) {
                var i, r, a, s, o, l = e.gf,
                    h = e.g._hasOpacity,
                    u = e.s.v,
                    c = e.e.v;
                if (e.o._mdf || n) {
                    var p = "gf" === t.ty ? "fill-opacity" : "stroke-opacity";
                    e.style.pElem.setAttribute(p, e.o.v)
                }
                if (e.s._mdf || n) {
                    var f = 1 === t.t ? "x1" : "cx",
                        d = "x1" === f ? "y1" : "cy";
                    l.setAttribute(f, u[0]), l.setAttribute(d, u[1]), h && !e.g._collapsable && (e.of.setAttribute(f, u[0]), e.of.setAttribute(d, u[1]))
                }
                if (e.g._cmdf || n) {
                    i = e.cst;
                    var m = e.g.c;
                    for (a = i.length, r = 0; r < a; r += 1)(s = i[r]).setAttribute("offset", m[4 * r] + "%"), s.setAttribute("stop-color", "rgb(" + m[4 * r + 1] + "," + m[4 * r + 2] + "," + m[4 * r + 3] + ")")
                }
                if (h && (e.g._omdf || n)) {
                    var g = e.g.o;
                    for (a = (i = e.g._collapsable ? e.cst : e.ost).length, r = 0; r < a; r += 1) s = i[r], e.g._collapsable || s.setAttribute("offset", g[2 * r] + "%"), s.setAttribute("stop-opacity", g[2 * r + 1])
                }
                if (1 === t.t)(e.e._mdf || n) && (l.setAttribute("x2", c[0]), l.setAttribute("y2", c[1]), h && !e.g._collapsable && (e.of.setAttribute("x2", c[0]), e.of.setAttribute("y2", c[1])));
                else if ((e.s._mdf || e.e._mdf || n) && (o = Math.sqrt(Math.pow(u[0] - c[0], 2) + Math.pow(u[1] - c[1], 2)), l.setAttribute("r", o), h && !e.g._collapsable && e.of.setAttribute("r", o)), e.e._mdf || e.h._mdf || e.a._mdf || n) {
                    o || (o = Math.sqrt(Math.pow(u[0] - c[0], 2) + Math.pow(u[1] - c[1], 2)));
                    var v = Math.atan2(c[1] - u[1], c[0] - u[0]),
                        y = o * (e.h.v >= 1 ? .99 : e.h.v <= -1 ? -.99 : e.h.v),
                        _ = Math.cos(v + e.a.v) * y + u[0],
                        x = Math.sin(v + e.a.v) * y + u[1];
                    l.setAttribute("fx", _), l.setAttribute("fy", x), h && !e.g._collapsable && (e.of.setAttribute("fx", _), e.of.setAttribute("fy", x))
                }
            }

            function o(t, e, n) {
                var i = e.style,
                    r = e.d;
                r && (r._mdf || n) && r.dashStr && (i.pElem.setAttribute("stroke-dasharray", r.dashStr), i.pElem.setAttribute("stroke-dashoffset", r.dashoffset[0])), e.c && (e.c._mdf || n) && i.pElem.setAttribute("stroke", "rgb(" + bm_floor(e.c.v[0]) + "," + bm_floor(e.c.v[1]) + "," + bm_floor(e.c.v[2]) + ")"), (e.o._mdf || n) && i.pElem.setAttribute("stroke-opacity", e.o.v), (e.w._mdf || n) && (i.pElem.setAttribute("stroke-width", e.w.v), i.msElem && i.msElem.setAttribute("stroke-width", e.w.v))
            }
            return {
                createRenderFunction: function (t) {
                    t.ty;
                    switch (t.ty) {
                        case "fl":
                            return r;
                        case "gf":
                            return s;
                        case "gs":
                            return a;
                        case "st":
                            return o;
                        case "sh":
                        case "el":
                        case "rc":
                        case "sr":
                            return i;
                        case "tr":
                            return n
                    }
                }
            }
        }();

        function ShapeTransformManager() {
            this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0
        }

        function CVShapeData(t, e, n, i) {
            this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0];
            var r = 4;
            "rc" == e.ty ? r = 5 : "el" == e.ty ? r = 6 : "sr" == e.ty && (r = 7), this.sh = ShapePropertyFactory.getShapeProp(t, e, r, t);
            var a, s, o = n.length;
            for (a = 0; a < o; a += 1) n[a].closed || (s = {
                transforms: i.addTransformSequence(n[a].transforms),
                trNodes: []
            }, this.styledShapes.push(s), n[a].elements.push(s))
        }

        function BaseElement() {}

        function NullElement(t, e, n) {
            this.initFrame(), this.initBaseData(t, e, n), this.initFrame(), this.initTransform(t, e, n), this.initHierarchy()
        }

        function SVGBaseElement() {}

        function IShapeElement() {}

        function ITextElement() {}

        function ICompElement() {}

        function IImageElement(t, e, n) {
            this.assetData = e.getAssetData(t.refId), this.initElement(t, e, n), this.sourceRect = {
                top: 0,
                left: 0,
                width: this.assetData.w,
                height: this.assetData.h
            }
        }

        function ISolidElement(t, e, n) {
            this.initElement(t, e, n)
        }

        function SVGCompElement(t, e, n) {
            this.layers = t.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(t, e, n), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {
                _placeholder: !0
            }
        }

        function SVGTextElement(t, e, n) {
            this.textSpans = [], this.renderType = "svg", this.initElement(t, e, n)
        }

        function SVGShapeElement(t, e, n) {
            this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(t, e, n), this.prevViewData = []
        }

        function SVGTintFilter(t, e) {
            this.filterManager = e;
            var n = createNS("feColorMatrix");
            if (n.setAttribute("type", "matrix"), n.setAttribute("color-interpolation-filters", "linearRGB"), n.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), n.setAttribute("result", "f1"), t.appendChild(n), (n = createNS("feColorMatrix")).setAttribute("type", "matrix"), n.setAttribute("color-interpolation-filters", "sRGB"), n.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), n.setAttribute("result", "f2"), t.appendChild(n), this.matrixFilter = n, 100 !== e.effectElements[2].p.v || e.effectElements[2].p.k) {
                var i, r = createNS("feMerge");
                t.appendChild(r), (i = createNS("feMergeNode")).setAttribute("in", "SourceGraphic"), r.appendChild(i), (i = createNS("feMergeNode")).setAttribute("in", "f2"), r.appendChild(i)
            }
        }

        function SVGFillFilter(t, e) {
            this.filterManager = e;
            var n = createNS("feColorMatrix");
            n.setAttribute("type", "matrix"), n.setAttribute("color-interpolation-filters", "sRGB"), n.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), t.appendChild(n), this.matrixFilter = n
        }

        function SVGGaussianBlurEffect(t, e) {
            t.setAttribute("x", "-100%"), t.setAttribute("y", "-100%"), t.setAttribute("width", "300%"), t.setAttribute("height", "300%"), this.filterManager = e;
            var n = createNS("feGaussianBlur");
            t.appendChild(n), this.feGaussianBlur = n
        }

        function SVGStrokeEffect(t, e) {
            this.initialized = !1, this.filterManager = e, this.elem = t, this.paths = []
        }

        function SVGTritoneFilter(t, e) {
            this.filterManager = e;
            var n = createNS("feColorMatrix");
            n.setAttribute("type", "matrix"), n.setAttribute("color-interpolation-filters", "linearRGB"), n.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), n.setAttribute("result", "f1"), t.appendChild(n);
            var i = createNS("feComponentTransfer");
            i.setAttribute("color-interpolation-filters", "sRGB"), t.appendChild(i), this.matrixFilter = i;
            var r = createNS("feFuncR");
            r.setAttribute("type", "table"), i.appendChild(r), this.feFuncR = r;
            var a = createNS("feFuncG");
            a.setAttribute("type", "table"), i.appendChild(a), this.feFuncG = a;
            var s = createNS("feFuncB");
            s.setAttribute("type", "table"), i.appendChild(s), this.feFuncB = s
        }

        function SVGProLevelsFilter(t, e) {
            this.filterManager = e;
            var n = this.filterManager.effectElements,
                i = createNS("feComponentTransfer");
            (n[10].p.k || 0 !== n[10].p.v || n[11].p.k || 1 !== n[11].p.v || n[12].p.k || 1 !== n[12].p.v || n[13].p.k || 0 !== n[13].p.v || n[14].p.k || 1 !== n[14].p.v) && (this.feFuncR = this.createFeFunc("feFuncR", i)), (n[17].p.k || 0 !== n[17].p.v || n[18].p.k || 1 !== n[18].p.v || n[19].p.k || 1 !== n[19].p.v || n[20].p.k || 0 !== n[20].p.v || n[21].p.k || 1 !== n[21].p.v) && (this.feFuncG = this.createFeFunc("feFuncG", i)), (n[24].p.k || 0 !== n[24].p.v || n[25].p.k || 1 !== n[25].p.v || n[26].p.k || 1 !== n[26].p.v || n[27].p.k || 0 !== n[27].p.v || n[28].p.k || 1 !== n[28].p.v) && (this.feFuncB = this.createFeFunc("feFuncB", i)), (n[31].p.k || 0 !== n[31].p.v || n[32].p.k || 1 !== n[32].p.v || n[33].p.k || 1 !== n[33].p.v || n[34].p.k || 0 !== n[34].p.v || n[35].p.k || 1 !== n[35].p.v) && (this.feFuncA = this.createFeFunc("feFuncA", i)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (i.setAttribute("color-interpolation-filters", "sRGB"), t.appendChild(i), i = createNS("feComponentTransfer")), (n[3].p.k || 0 !== n[3].p.v || n[4].p.k || 1 !== n[4].p.v || n[5].p.k || 1 !== n[5].p.v || n[6].p.k || 0 !== n[6].p.v || n[7].p.k || 1 !== n[7].p.v) && (i.setAttribute("color-interpolation-filters", "sRGB"), t.appendChild(i), this.feFuncRComposed = this.createFeFunc("feFuncR", i), this.feFuncGComposed = this.createFeFunc("feFuncG", i), this.feFuncBComposed = this.createFeFunc("feFuncB", i))
        }

        function SVGDropShadowEffect(t, e) {
            var n = e.container.globalData.renderConfig.filterSize;
            t.setAttribute("x", n.x), t.setAttribute("y", n.y), t.setAttribute("width", n.width), t.setAttribute("height", n.height), this.filterManager = e;
            var i = createNS("feGaussianBlur");
            i.setAttribute("in", "SourceAlpha"), i.setAttribute("result", "drop_shadow_1"), i.setAttribute("stdDeviation", "0"), this.feGaussianBlur = i, t.appendChild(i);
            var r = createNS("feOffset");
            r.setAttribute("dx", "25"), r.setAttribute("dy", "0"), r.setAttribute("in", "drop_shadow_1"), r.setAttribute("result", "drop_shadow_2"), this.feOffset = r, t.appendChild(r);
            var a = createNS("feFlood");
            a.setAttribute("flood-color", "#00ff00"), a.setAttribute("flood-opacity", "1"), a.setAttribute("result", "drop_shadow_3"), this.feFlood = a, t.appendChild(a);
            var s = createNS("feComposite");
            s.setAttribute("in", "drop_shadow_3"), s.setAttribute("in2", "drop_shadow_2"), s.setAttribute("operator", "in"), s.setAttribute("result", "drop_shadow_4"), t.appendChild(s);
            var o, l = createNS("feMerge");
            t.appendChild(l), o = createNS("feMergeNode"), l.appendChild(o), (o = createNS("feMergeNode")).setAttribute("in", "SourceGraphic"), this.feMergeNode = o, this.feMerge = l, this.originalNodeAdded = !1, l.appendChild(o)
        }
        ShapeTransformManager.prototype = {
            addTransformSequence: function (t) {
                var e, n = t.length,
                    i = "_";
                for (e = 0; e < n; e += 1) i += t[e].transform.key + "_";
                var r = this.sequences[i];
                return r || (r = {
                    transforms: [].concat(t),
                    finalTransform: new Matrix,
                    _mdf: !1
                }, this.sequences[i] = r, this.sequenceList.push(r)), r
            },
            processSequence: function (t, e) {
                for (var n, i = 0, r = t.transforms.length, a = e; i < r && !e;) {
                    if (t.transforms[i].transform.mProps._mdf) {
                        a = !0;
                        break
                    }
                    i += 1
                }
                if (a)
                    for (t.finalTransform.reset(), i = r - 1; i >= 0; i -= 1) n = t.transforms[i].transform.mProps.v.props, t.finalTransform.transform(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8], n[9], n[10], n[11], n[12], n[13], n[14], n[15]);
                t._mdf = a
            },
            processSequences: function (t) {
                var e, n = this.sequenceList.length;
                for (e = 0; e < n; e += 1) this.processSequence(this.sequenceList[e], t)
            },
            getNewKey: function () {
                return "_" + this.transform_key_count++
            }
        }, CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated, BaseElement.prototype = {
            checkMasks: function () {
                if (!this.data.hasMask) return !1;
                for (var t = 0, e = this.data.masksProperties.length; t < e;) {
                    if ("n" !== this.data.masksProperties[t].mode && !1 !== this.data.masksProperties[t].cl) return !0;
                    t += 1
                }
                return !1
            },
            initExpressions: function () {
                this.layerInterface = LayerExpressionInterface(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
                var t = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
                this.layerInterface.registerEffectsInterface(t), 0 === this.data.ty || this.data.xt ? this.compInterface = CompExpressionInterface(this) : 4 === this.data.ty ? (this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : 5 === this.data.ty && (this.layerInterface.textInterface = TextExpressionInterface(this), this.layerInterface.text = this.layerInterface.textInterface)
            },
            setBlendMode: function () {
                var t = getBlendMode(this.data.bm);
                (this.baseElement || this.layerElement).style["mix-blend-mode"] = t
            },
            initBaseData: function (t, e, n) {
                this.globalData = e, this.comp = n, this.data = t, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties)
            },
            getType: function () {
                return this.type
            },
            sourceRectAtTime: function () {}
        }, NullElement.prototype.prepareFrame = function (t) {
            this.prepareProperties(t, !0)
        }, NullElement.prototype.renderFrame = function () {}, NullElement.prototype.getBaseElement = function () {
            return null
        }, NullElement.prototype.destroy = function () {}, NullElement.prototype.sourceRectAtTime = function () {}, NullElement.prototype.hide = function () {}, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement), SVGBaseElement.prototype = {
            initRendererElement: function () {
                this.layerElement = createNS("g")
            },
            createContainerElements: function () {
                this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1;
                var t, e, n, i = null;
                if (this.data.td) {
                    if (3 == this.data.td || 1 == this.data.td) {
                        var r = createNS("mask");
                        r.setAttribute("id", this.layerId), r.setAttribute("mask-type", 3 == this.data.td ? "luminance" : "alpha"), r.appendChild(this.layerElement), i = r, this.globalData.defs.appendChild(r), featureSupport.maskType || 1 != this.data.td || (r.setAttribute("mask-type", "luminance"), t = createElementID(), e = filtersFactory.createFilter(t), this.globalData.defs.appendChild(e), e.appendChild(filtersFactory.createAlphaToLuminanceFilter()), (n = createNS("g")).appendChild(this.layerElement), i = n, r.appendChild(n), n.setAttribute("filter", "url(" + locationHref + "#" + t + ")"))
                    } else if (2 == this.data.td) {
                        var a = createNS("mask");
                        a.setAttribute("id", this.layerId), a.setAttribute("mask-type", "alpha");
                        var s = createNS("g");
                        a.appendChild(s), t = createElementID(), e = filtersFactory.createFilter(t);
                        var o = createNS("feComponentTransfer");
                        o.setAttribute("in", "SourceGraphic"), e.appendChild(o);
                        var l = createNS("feFuncA");
                        l.setAttribute("type", "table"), l.setAttribute("tableValues", "1.0 0.0"), o.appendChild(l), this.globalData.defs.appendChild(e);
                        var h = createNS("rect");
                        h.setAttribute("width", this.comp.data.w), h.setAttribute("height", this.comp.data.h), h.setAttribute("x", "0"), h.setAttribute("y", "0"), h.setAttribute("fill", "#ffffff"), h.setAttribute("opacity", "0"), s.setAttribute("filter", "url(" + locationHref + "#" + t + ")"), s.appendChild(h), s.appendChild(this.layerElement), i = s, featureSupport.maskType || (a.setAttribute("mask-type", "luminance"), e.appendChild(filtersFactory.createAlphaToLuminanceFilter()), n = createNS("g"), s.appendChild(h), n.appendChild(this.layerElement), i = n, s.appendChild(n)), this.globalData.defs.appendChild(a)
                    }
                } else this.data.tt ? (this.matteElement.appendChild(this.layerElement), i = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
                if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 === this.data.ty && !this.data.hd) {
                    var u = createNS("clipPath"),
                        c = createNS("path");
                    c.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                    var p = createElementID();
                    if (u.setAttribute("id", p), u.appendChild(c), this.globalData.defs.appendChild(u), this.checkMasks()) {
                        var f = createNS("g");
                        f.setAttribute("clip-path", "url(" + locationHref + "#" + p + ")"), f.appendChild(this.layerElement), this.transformedElement = f, i ? i.appendChild(this.transformedElement) : this.baseElement = this.transformedElement
                    } else this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + p + ")")
                }
                0 !== this.data.bm && this.setBlendMode()
            },
            renderElement: function () {
                this.finalTransform._matMdf && this.transformedElement.setAttribute("transform", this.finalTransform.mat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.mProp.o.v)
            },
            destroyBaseElement: function () {
                this.layerElement = null, this.matteElement = null, this.maskManager.destroy()
            },
            getBaseElement: function () {
                return this.data.hd ? null : this.baseElement
            },
            createRenderableComponents: function () {
                this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this)
            },
            setMatte: function (t) {
                this.matteElement && this.matteElement.setAttribute("mask", "url(" + locationHref + "#" + t + ")")
            }
        }, IShapeElement.prototype = {
            addShapeToModifiers: function (t) {
                var e, n = this.shapeModifiers.length;
                for (e = 0; e < n; e += 1) this.shapeModifiers[e].addShape(t)
            },
            isShapeInAnimatedModifiers: function (t) {
                for (var e = this.shapeModifiers.length; 0 < e;)
                    if (this.shapeModifiers[0].isAnimatedWithShape(t)) return !0;
                return !1
            },
            renderModifiers: function () {
                if (this.shapeModifiers.length) {
                    var t, e = this.shapes.length;
                    for (t = 0; t < e; t += 1) this.shapes[t].sh.reset();
                    for (t = (e = this.shapeModifiers.length) - 1; t >= 0; t -= 1) this.shapeModifiers[t].processShapes(this._isFirstFrame)
                }
            },
            lcEnum: {
                1: "butt",
                2: "round",
                3: "square"
            },
            ljEnum: {
                1: "miter",
                2: "round",
                3: "bevel"
            },
            searchProcessedElement: function (t) {
                for (var e = this.processedElements, n = 0, i = e.length; n < i;) {
                    if (e[n].elem === t) return e[n].pos;
                    n += 1
                }
                return 0
            },
            addProcessedElement: function (t, e) {
                for (var n = this.processedElements, i = n.length; i;)
                    if (n[i -= 1].elem === t) return void(n[i].pos = e);
                n.push(new ProcessedElement(t, e))
            },
            prepareFrame: function (t) {
                this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange)
            }
        }, ITextElement.prototype.initElement = function (t, e, n) {
            this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(t, e, n), this.textProperty = new TextProperty(this, t.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(t.t, this.renderType, this), this.initTransform(t, e, n), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties)
        }, ITextElement.prototype.prepareFrame = function (t) {
            this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1)
        }, ITextElement.prototype.createPathShape = function (t, e) {
            var n, i, r = e.length,
                a = "";
            for (n = 0; n < r; n += 1) i = e[n].ks.k, a += buildShapeString(i, i.i.length, !0, t);
            return a
        }, ITextElement.prototype.updateDocumentData = function (t, e) {
            this.textProperty.updateDocumentData(t, e)
        }, ITextElement.prototype.canResizeFont = function (t) {
            this.textProperty.canResizeFont(t)
        }, ITextElement.prototype.setMinimumFontSize = function (t) {
            this.textProperty.setMinimumFontSize(t)
        }, ITextElement.prototype.applyTextPropertiesToMatrix = function (t, e, n, i, r) {
            switch (t.ps && e.translate(t.ps[0], t.ps[1] + t.ascent, 0), e.translate(0, -t.ls, 0), t.j) {
                case 1:
                    e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[n]), 0, 0);
                    break;
                case 2:
                    e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[n]) / 2, 0, 0)
            }
            e.translate(i, r, 0)
        }, ITextElement.prototype.buildColor = function (t) {
            return "rgb(" + Math.round(255 * t[0]) + "," + Math.round(255 * t[1]) + "," + Math.round(255 * t[2]) + ")"
        }, ITextElement.prototype.emptyProp = new LetterProps, ITextElement.prototype.destroy = function () {}, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function (t, e, n) {
            this.initFrame(), this.initBaseData(t, e, n), this.initTransform(t, e, n), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), !this.data.xt && e.progressiveLoad || this.buildAllItems(), this.hide()
        }, ICompElement.prototype.prepareFrame = function (t) {
            if (this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.isInRange || this.data.xt) {
                if (this.tm._placeholder) this.renderedFrame = t / this.data.sr;
                else {
                    var e = this.tm.v;
                    e === this.data.op && (e = this.data.op - 1), this.renderedFrame = e
                }
                var n, i = this.elements.length;
                for (this.completeLayers || this.checkLayers(this.renderedFrame), n = i - 1; n >= 0; n -= 1)(this.completeLayers || this.elements[n]) && (this.elements[n].prepareFrame(this.renderedFrame - this.layers[n].st), this.elements[n]._mdf && (this._mdf = !0))
            }
        }, ICompElement.prototype.renderInnerContent = function () {
            var t, e = this.layers.length;
            for (t = 0; t < e; t += 1)(this.completeLayers || this.elements[t]) && this.elements[t].renderFrame()
        }, ICompElement.prototype.setElements = function (t) {
            this.elements = t
        }, ICompElement.prototype.getElements = function () {
            return this.elements
        }, ICompElement.prototype.destroyElements = function () {
            var t, e = this.layers.length;
            for (t = 0; t < e; t += 1) this.elements[t] && this.elements[t].destroy()
        }, ICompElement.prototype.destroy = function () {
            this.destroyElements(), this.destroyBaseElement()
        }, extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function () {
            var t = this.globalData.getAssetsPath(this.assetData);
            this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", t), this.layerElement.appendChild(this.innerElem)
        }, IImageElement.prototype.sourceRectAtTime = function () {
            return this.sourceRect
        }, extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function () {
            var t = createNS("rect");
            t.setAttribute("width", this.data.sw), t.setAttribute("height", this.data.sh), t.setAttribute("fill", this.data.sc), this.layerElement.appendChild(t)
        }, extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement), extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextElement), SVGTextElement.prototype.createContent = function () {
            this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
        }, SVGTextElement.prototype.buildTextContents = function (t) {
            for (var e = 0, n = t.length, i = [], r = ""; e < n;) t[e] === String.fromCharCode(13) || t[e] === String.fromCharCode(3) ? (i.push(r), r = "") : r += t[e], e += 1;
            return i.push(r), i
        }, SVGTextElement.prototype.buildNewText = function () {
            var t, e, n = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(n ? n.l.length : 0), n.fc ? this.layerElement.setAttribute("fill", this.buildColor(n.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), n.sc && (this.layerElement.setAttribute("stroke", this.buildColor(n.sc)), this.layerElement.setAttribute("stroke-width", n.sw)), this.layerElement.setAttribute("font-size", n.finalSize);
            var i = this.globalData.fontManager.getFontByName(n.f);
            if (i.fClass) this.layerElement.setAttribute("class", i.fClass);
            else {
                this.layerElement.setAttribute("font-family", i.fFamily);
                var r = n.fWeight,
                    a = n.fStyle;
                this.layerElement.setAttribute("font-style", a), this.layerElement.setAttribute("font-weight", r)
            }
            this.layerElement.setAttribute("aria-label", n.t);
            var s, o = n.l || [],
                l = !!this.globalData.fontManager.chars;
            e = o.length;
            var h, u = this.mHelper,
                c = "",
                p = this.data.singleShape,
                f = 0,
                d = 0,
                m = !0,
                g = n.tr / 1e3 * n.finalSize;
            if (!p || l || n.sz) {
                var v, y, _ = this.textSpans.length;
                for (t = 0; t < e; t += 1) l && p && 0 !== t || (s = _ > t ? this.textSpans[t] : createNS(l ? "path" : "text"), _ <= t && (s.setAttribute("stroke-linecap", "butt"), s.setAttribute("stroke-linejoin", "round"), s.setAttribute("stroke-miterlimit", "4"), this.textSpans[t] = s, this.layerElement.appendChild(s)), s.style.display = "inherit"), u.reset(), u.scale(n.finalSize / 100, n.finalSize / 100), p && (o[t].n && (f = -g, d += n.yOffset, d += m ? 1 : 0, m = !1), this.applyTextPropertiesToMatrix(n, u, o[t].line, f, d), f += o[t].l || 0, f += g), l ? (h = (v = (y = this.globalData.fontManager.getCharData(n.finalText[t], i.fStyle, this.globalData.fontManager.getFontByName(n.f).fFamily)) && y.data || {}).shapes ? v.shapes[0].it : [], p ? c += this.createPathShape(u, h) : s.setAttribute("d", this.createPathShape(u, h))) : (p && s.setAttribute("transform", "translate(" + u.props[12] + "," + u.props[13] + ")"), s.textContent = o[t].val, s.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"));
                p && s && s.setAttribute("d", c)
            } else {
                var x = this.textContainer,
                    b = "start";
                switch (n.j) {
                    case 1:
                        b = "end";
                        break;
                    case 2:
                        b = "middle"
                }
                x.setAttribute("text-anchor", b), x.setAttribute("letter-spacing", g);
                var E = this.buildTextContents(n.finalText);
                for (e = E.length, d = n.ps ? n.ps[1] + n.ascent : 0, t = 0; t < e; t += 1)(s = this.textSpans[t] || createNS("tspan")).textContent = E[t], s.setAttribute("x", 0), s.setAttribute("y", d), s.style.display = "inherit", x.appendChild(s), this.textSpans[t] = s, d += n.finalLineHeight;
                this.layerElement.appendChild(x)
            }
            for (; t < this.textSpans.length;) this.textSpans[t].style.display = "none", t += 1;
            this._sizeChanged = !0
        }, SVGTextElement.prototype.sourceRectAtTime = function (t) {
            if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) {
                this._sizeChanged = !1;
                var e = this.layerElement.getBBox();
                this.bbox = {
                    top: e.y,
                    left: e.x,
                    width: e.width,
                    height: e.height
                }
            }
            return this.bbox
        }, SVGTextElement.prototype.renderInnerContent = function () {
            if (!this.data.singleShape && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
                var t, e;
                this._sizeChanged = !0;
                var n, i, r = this.textAnimator.renderedLetters,
                    a = this.textProperty.currentData.l;
                for (e = a.length, t = 0; t < e; t += 1) a[t].n || (n = r[t], i = this.textSpans[t], n._mdf.m && i.setAttribute("transform", n.m), n._mdf.o && i.setAttribute("opacity", n.o), n._mdf.sw && i.setAttribute("stroke-width", n.sw), n._mdf.sc && i.setAttribute("stroke", n.sc), n._mdf.fc && i.setAttribute("fill", n.fc))
            }
        }, extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function () {}, SVGShapeElement.prototype.identityMatrix = new Matrix, SVGShapeElement.prototype.buildExpressionInterface = function () {}, SVGShapeElement.prototype.createContent = function () {
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes()
        }, SVGShapeElement.prototype.filterUniqueShapes = function () {
            var t, e, n, i, r = this.shapes.length,
                a = this.stylesList.length,
                s = [],
                o = !1;
            for (n = 0; n < a; n += 1) {
                for (i = this.stylesList[n], o = !1, s.length = 0, t = 0; t < r; t += 1) - 1 !== (e = this.shapes[t]).styles.indexOf(i) && (s.push(e), o = e._isAnimated || o);
                s.length > 1 && o && this.setShapesAsAnimated(s)
            }
        }, SVGShapeElement.prototype.setShapesAsAnimated = function (t) {
            var e, n = t.length;
            for (e = 0; e < n; e += 1) t[e].setAsAnimated()
        }, SVGShapeElement.prototype.createStyleElement = function (t, e) {
            var n, i = new SVGStyleData(t, e),
                r = i.pElem;
            if ("st" === t.ty) n = new SVGStrokeStyleData(this, t, i);
            else if ("fl" === t.ty) n = new SVGFillStyleData(this, t, i);
            else if ("gf" === t.ty || "gs" === t.ty) {
                n = new("gf" === t.ty ? SVGGradientFillStyleData : SVGGradientStrokeStyleData)(this, t, i), this.globalData.defs.appendChild(n.gf), n.maskId && (this.globalData.defs.appendChild(n.ms), this.globalData.defs.appendChild(n.of), r.setAttribute("mask", "url(" + locationHref + "#" + n.maskId + ")"))
            }
            return "st" !== t.ty && "gs" !== t.ty || (r.setAttribute("stroke-linecap", this.lcEnum[t.lc] || "round"), r.setAttribute("stroke-linejoin", this.ljEnum[t.lj] || "round"), r.setAttribute("fill-opacity", "0"), 1 === t.lj && r.setAttribute("stroke-miterlimit", t.ml)), 2 === t.r && r.setAttribute("fill-rule", "evenodd"), t.ln && r.setAttribute("id", t.ln), t.cl && r.setAttribute("class", t.cl), t.bm && (r.style["mix-blend-mode"] = getBlendMode(t.bm)), this.stylesList.push(i), this.addToAnimatedContents(t, n), n
        }, SVGShapeElement.prototype.createGroupElement = function (t) {
            var e = new ShapeGroupData;
            return t.ln && e.gr.setAttribute("id", t.ln), t.cl && e.gr.setAttribute("class", t.cl), t.bm && (e.gr.style["mix-blend-mode"] = getBlendMode(t.bm)), e
        }, SVGShapeElement.prototype.createTransformElement = function (t, e) {
            var n = TransformPropertyFactory.getTransformProperty(this, t, this),
                i = new SVGTransformData(n, n.o, e);
            return this.addToAnimatedContents(t, i), i
        }, SVGShapeElement.prototype.createShapeElement = function (t, e, n) {
            var i = 4;
            "rc" === t.ty ? i = 5 : "el" === t.ty ? i = 6 : "sr" === t.ty && (i = 7);
            var r = new SVGShapeData(e, n, ShapePropertyFactory.getShapeProp(this, t, i, this));
            return this.shapes.push(r), this.addShapeToModifiers(r), this.addToAnimatedContents(t, r), r
        }, SVGShapeElement.prototype.addToAnimatedContents = function (t, e) {
            for (var n = 0, i = this.animatedContents.length; n < i;) {
                if (this.animatedContents[n].element === e) return;
                n += 1
            }
            this.animatedContents.push({
                fn: SVGElementsRenderer.createRenderFunction(t),
                element: e,
                data: t
            })
        }, SVGShapeElement.prototype.setElementStyles = function (t) {
            var e, n = t.styles,
                i = this.stylesList.length;
            for (e = 0; e < i; e += 1) this.stylesList[e].closed || n.push(this.stylesList[e])
        }, SVGShapeElement.prototype.reloadShapes = function () {
            this._isFirstFrame = !0;
            var t, e = this.itemsData.length;
            for (t = 0; t < e; t += 1) this.prevViewData[t] = this.itemsData[t];
            for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), e = this.dynamicProperties.length, t = 0; t < e; t += 1) this.dynamicProperties[t].getValue();
            this.renderModifiers()
        }, SVGShapeElement.prototype.searchShapes = function (t, e, n, i, r, a, s) {
            var o, l, h, u, c, p, f = [].concat(a),
                d = t.length - 1,
                m = [],
                g = [];
            for (o = d; o >= 0; o -= 1) {
                if ((p = this.searchProcessedElement(t[o])) ? e[o] = n[p - 1] : t[o]._render = s, "fl" == t[o].ty || "st" == t[o].ty || "gf" == t[o].ty || "gs" == t[o].ty) p ? e[o].style.closed = !1 : e[o] = this.createStyleElement(t[o], r), t[o]._render && i.appendChild(e[o].style.pElem), m.push(e[o].style);
                else if ("gr" == t[o].ty) {
                    if (p)
                        for (h = e[o].it.length, l = 0; l < h; l += 1) e[o].prevViewData[l] = e[o].it[l];
                    else e[o] = this.createGroupElement(t[o]);
                    this.searchShapes(t[o].it, e[o].it, e[o].prevViewData, e[o].gr, r + 1, f, s), t[o]._render && i.appendChild(e[o].gr)
                } else "tr" == t[o].ty ? (p || (e[o] = this.createTransformElement(t[o], i)), u = e[o].transform, f.push(u)) : "sh" == t[o].ty || "rc" == t[o].ty || "el" == t[o].ty || "sr" == t[o].ty ? (p || (e[o] = this.createShapeElement(t[o], f, r)), this.setElementStyles(e[o])) : "tm" == t[o].ty || "rd" == t[o].ty || "ms" == t[o].ty ? (p ? (c = e[o]).closed = !1 : ((c = ShapeModifiers.getModifier(t[o].ty)).init(this, t[o]), e[o] = c, this.shapeModifiers.push(c)), g.push(c)) : "rp" == t[o].ty && (p ? (c = e[o]).closed = !0 : (c = ShapeModifiers.getModifier(t[o].ty), e[o] = c, c.init(this, t, o, e), this.shapeModifiers.push(c), s = !1), g.push(c));
                this.addProcessedElement(t[o], o + 1)
            }
            for (d = m.length, o = 0; o < d; o += 1) m[o].closed = !0;
            for (d = g.length, o = 0; o < d; o += 1) g[o].closed = !0
        }, SVGShapeElement.prototype.renderInnerContent = function () {
            this.renderModifiers();
            var t, e = this.stylesList.length;
            for (t = 0; t < e; t += 1) this.stylesList[t].reset();
            for (this.renderShape(), t = 0; t < e; t += 1)(this.stylesList[t]._mdf || this._isFirstFrame) && (this.stylesList[t].msElem && (this.stylesList[t].msElem.setAttribute("d", this.stylesList[t].d), this.stylesList[t].d = "M0 0" + this.stylesList[t].d), this.stylesList[t].pElem.setAttribute("d", this.stylesList[t].d || "M0 0"))
        }, SVGShapeElement.prototype.renderShape = function () {
            var t, e, n = this.animatedContents.length;
            for (t = 0; t < n; t += 1) e = this.animatedContents[t], (this._isFirstFrame || e.element._isAnimated) && !0 !== e.data && e.fn(e.data, e.element, this._isFirstFrame)
        }, SVGShapeElement.prototype.destroy = function () {
            this.destroyBaseElement(), this.shapesData = null, this.itemsData = null
        }, SVGTintFilter.prototype.renderFrame = function (t) {
            if (t || this.filterManager._mdf) {
                var e = this.filterManager.effectElements[0].p.v,
                    n = this.filterManager.effectElements[1].p.v,
                    i = this.filterManager.effectElements[2].p.v / 100;
                this.matrixFilter.setAttribute("values", n[0] - e[0] + " 0 0 0 " + e[0] + " " + (n[1] - e[1]) + " 0 0 0 " + e[1] + " " + (n[2] - e[2]) + " 0 0 0 " + e[2] + " 0 0 0 " + i + " 0")
            }
        }, SVGFillFilter.prototype.renderFrame = function (t) {
            if (t || this.filterManager._mdf) {
                var e = this.filterManager.effectElements[2].p.v,
                    n = this.filterManager.effectElements[6].p.v;
                this.matrixFilter.setAttribute("values", "0 0 0 0 " + e[0] + " 0 0 0 0 " + e[1] + " 0 0 0 0 " + e[2] + " 0 0 0 " + n + " 0")
            }
        }, SVGGaussianBlurEffect.prototype.renderFrame = function (t) {
            if (t || this.filterManager._mdf) {
                var e = .3 * this.filterManager.effectElements[0].p.v,
                    n = this.filterManager.effectElements[1].p.v,
                    i = 3 == n ? 0 : e,
                    r = 2 == n ? 0 : e;
                this.feGaussianBlur.setAttribute("stdDeviation", i + " " + r);
                var a = 1 == this.filterManager.effectElements[2].p.v ? "wrap" : "duplicate";
                this.feGaussianBlur.setAttribute("edgeMode", a)
            }
        }, SVGStrokeEffect.prototype.initialize = function () {
            var t, e, n, i, r = this.elem.layerElement.children || this.elem.layerElement.childNodes;
            for (1 === this.filterManager.effectElements[1].p.v ? (i = this.elem.maskManager.masksProperties.length, n = 0) : i = (n = this.filterManager.effectElements[0].p.v - 1) + 1, (e = createNS("g")).setAttribute("fill", "none"), e.setAttribute("stroke-linecap", "round"), e.setAttribute("stroke-dashoffset", 1); n < i; n += 1) t = createNS("path"), e.appendChild(t), this.paths.push({
                p: t,
                m: n
            });
            if (3 === this.filterManager.effectElements[10].p.v) {
                var a = createNS("mask"),
                    s = createElementID();
                a.setAttribute("id", s), a.setAttribute("mask-type", "alpha"), a.appendChild(e), this.elem.globalData.defs.appendChild(a);
                var o = createNS("g");
                for (o.setAttribute("mask", "url(" + locationHref + "#" + s + ")"); r[0];) o.appendChild(r[0]);
                this.elem.layerElement.appendChild(o), this.masker = a, e.setAttribute("stroke", "#fff")
            } else if (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) {
                if (2 === this.filterManager.effectElements[10].p.v)
                    for (r = this.elem.layerElement.children || this.elem.layerElement.childNodes; r.length;) this.elem.layerElement.removeChild(r[0]);
                this.elem.layerElement.appendChild(e), this.elem.layerElement.removeAttribute("mask"), e.setAttribute("stroke", "#fff")
            }
            this.initialized = !0, this.pathMasker = e
        }, SVGStrokeEffect.prototype.renderFrame = function (t) {
            this.initialized || this.initialize();
            var e, n, i, r = this.paths.length;
            for (e = 0; e < r; e += 1)
                if (-1 !== this.paths[e].m && (n = this.elem.maskManager.viewData[this.paths[e].m], i = this.paths[e].p, (t || this.filterManager._mdf || n.prop._mdf) && i.setAttribute("d", n.lastPath), t || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || n.prop._mdf)) {
                    var a;
                    if (0 !== this.filterManager.effectElements[7].p.v || 100 !== this.filterManager.effectElements[8].p.v) {
                        var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) / 100,
                            o = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) / 100,
                            l = i.getTotalLength();
                        a = "0 0 0 " + l * s + " ";
                        var h, u = l * (o - s),
                            c = 1 + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v / 100,
                            p = Math.floor(u / c);
                        for (h = 0; h < p; h += 1) a += "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v / 100 + " ";
                        a += "0 " + 10 * l + " 0 0"
                    } else a = "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v / 100;
                    i.setAttribute("stroke-dasharray", a)
                } if ((t || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", 2 * this.filterManager.effectElements[4].p.v), (t || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) && (t || this.filterManager.effectElements[3].p._mdf)) {
                var f = this.filterManager.effectElements[3].p.v;
                this.pathMasker.setAttribute("stroke", "rgb(" + bm_floor(255 * f[0]) + "," + bm_floor(255 * f[1]) + "," + bm_floor(255 * f[2]) + ")")
            }
        }, SVGTritoneFilter.prototype.renderFrame = function (t) {
            if (t || this.filterManager._mdf) {
                var e = this.filterManager.effectElements[0].p.v,
                    n = this.filterManager.effectElements[1].p.v,
                    i = this.filterManager.effectElements[2].p.v,
                    r = i[0] + " " + n[0] + " " + e[0],
                    a = i[1] + " " + n[1] + " " + e[1],
                    s = i[2] + " " + n[2] + " " + e[2];
                this.feFuncR.setAttribute("tableValues", r), this.feFuncG.setAttribute("tableValues", a), this.feFuncB.setAttribute("tableValues", s)
            }
        }, SVGProLevelsFilter.prototype.createFeFunc = function (t, e) {
            var n = createNS(t);
            return n.setAttribute("type", "table"), e.appendChild(n), n
        }, SVGProLevelsFilter.prototype.getTableValue = function (t, e, n, i, r) {
            for (var a, s, o = 0, l = Math.min(t, e), h = Math.max(t, e), u = Array.call(null, {
                    length: 256
                }), c = 0, p = r - i, f = e - t; o <= 256;) s = (a = o / 256) <= l ? f < 0 ? r : i : a >= h ? f < 0 ? i : r : i + p * Math.pow((a - t) / f, 1 / n), u[c++] = s, o += 256 / 255;
            return u.join(" ")
        }, SVGProLevelsFilter.prototype.renderFrame = function (t) {
            if (t || this.filterManager._mdf) {
                var e, n = this.filterManager.effectElements;
                this.feFuncRComposed && (t || n[3].p._mdf || n[4].p._mdf || n[5].p._mdf || n[6].p._mdf || n[7].p._mdf) && (e = this.getTableValue(n[3].p.v, n[4].p.v, n[5].p.v, n[6].p.v, n[7].p.v), this.feFuncRComposed.setAttribute("tableValues", e), this.feFuncGComposed.setAttribute("tableValues", e), this.feFuncBComposed.setAttribute("tableValues", e)), this.feFuncR && (t || n[10].p._mdf || n[11].p._mdf || n[12].p._mdf || n[13].p._mdf || n[14].p._mdf) && (e = this.getTableValue(n[10].p.v, n[11].p.v, n[12].p.v, n[13].p.v, n[14].p.v), this.feFuncR.setAttribute("tableValues", e)), this.feFuncG && (t || n[17].p._mdf || n[18].p._mdf || n[19].p._mdf || n[20].p._mdf || n[21].p._mdf) && (e = this.getTableValue(n[17].p.v, n[18].p.v, n[19].p.v, n[20].p.v, n[21].p.v), this.feFuncG.setAttribute("tableValues", e)), this.feFuncB && (t || n[24].p._mdf || n[25].p._mdf || n[26].p._mdf || n[27].p._mdf || n[28].p._mdf) && (e = this.getTableValue(n[24].p.v, n[25].p.v, n[26].p.v, n[27].p.v, n[28].p.v), this.feFuncB.setAttribute("tableValues", e)), this.feFuncA && (t || n[31].p._mdf || n[32].p._mdf || n[33].p._mdf || n[34].p._mdf || n[35].p._mdf) && (e = this.getTableValue(n[31].p.v, n[32].p.v, n[33].p.v, n[34].p.v, n[35].p.v), this.feFuncA.setAttribute("tableValues", e))
            }
        }, SVGDropShadowEffect.prototype.renderFrame = function (t) {
            if (t || this.filterManager._mdf) {
                if ((t || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), t || this.filterManager.effectElements[0].p._mdf) {
                    var e = this.filterManager.effectElements[0].p.v;
                    this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(255 * e[0]), Math.round(255 * e[1]), Math.round(255 * e[2])))
                }
                if ((t || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), t || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                    var n = this.filterManager.effectElements[3].p.v,
                        i = (this.filterManager.effectElements[2].p.v - 90) * degToRads,
                        r = n * Math.cos(i),
                        a = n * Math.sin(i);
                    this.feOffset.setAttribute("dx", r), this.feOffset.setAttribute("dy", a)
                }
            }
        };
        var _svgMatteSymbols = [];

        function SVGMatte3Effect(t, e, n) {
            this.initialized = !1, this.filterManager = e, this.filterElem = t, this.elem = n, n.matteElement = createNS("g"), n.matteElement.appendChild(n.layerElement), n.matteElement.appendChild(n.transformedElement), n.baseElement = n.matteElement
        }

        function SVGEffects(t) {
            var e, n, i = t.data.ef ? t.data.ef.length : 0,
                r = createElementID(),
                a = filtersFactory.createFilter(r),
                s = 0;
            for (this.filters = [], e = 0; e < i; e += 1) n = null, 20 === t.data.ef[e].ty ? (s += 1, n = new SVGTintFilter(a, t.effectsManager.effectElements[e])) : 21 === t.data.ef[e].ty ? (s += 1, n = new SVGFillFilter(a, t.effectsManager.effectElements[e])) : 22 === t.data.ef[e].ty ? n = new SVGStrokeEffect(t, t.effectsManager.effectElements[e]) : 23 === t.data.ef[e].ty ? (s += 1, n = new SVGTritoneFilter(a, t.effectsManager.effectElements[e])) : 24 === t.data.ef[e].ty ? (s += 1, n = new SVGProLevelsFilter(a, t.effectsManager.effectElements[e])) : 25 === t.data.ef[e].ty ? (s += 1, n = new SVGDropShadowEffect(a, t.effectsManager.effectElements[e])) : 28 === t.data.ef[e].ty ? n = new SVGMatte3Effect(a, t.effectsManager.effectElements[e], t) : 29 === t.data.ef[e].ty && (s += 1, n = new SVGGaussianBlurEffect(a, t.effectsManager.effectElements[e])), n && this.filters.push(n);
            s && (t.globalData.defs.appendChild(a), t.layerElement.setAttribute("filter", "url(" + locationHref + "#" + r + ")")), this.filters.length && t.addRenderableComponent(this)
        }

        function CVContextData() {
            this.saved = [], this.cArrPos = 0, this.cTr = new Matrix, this.cO = 1;
            var t;
            for (this.savedOp = createTypedArray("float32", 15), t = 0; t < 15; t += 1) this.saved[t] = createTypedArray("float32", 16);
            this._length = 15
        }

        function CVBaseElement() {}

        function CVImageElement(t, e, n) {
            this.assetData = e.getAssetData(t.refId), this.img = e.imageLoader.getImage(this.assetData), this.initElement(t, e, n)
        }

        function CVCompElement(t, e, n) {
            this.completeLayers = !1, this.layers = t.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(t, e, n), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {
                _placeholder: !0
            }
        }

        function CVMaskElement(t, e) {
            this.data = t, this.element = e, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length);
            var n, i = this.masksProperties.length,
                r = !1;
            for (n = 0; n < i; n++) "n" !== this.masksProperties[n].mode && (r = !0), this.viewData[n] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[n], 3);
            this.hasMasks = r, r && this.element.addRenderableComponent(this)
        }

        function CVShapeElement(t, e, n) {
            this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager, this.initElement(t, e, n)
        }

        function CVSolidElement(t, e, n) {
            this.initElement(t, e, n)
        }

        function CVTextElement(t, e, n) {
            this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = {
                fill: "rgba(0,0,0,0)",
                stroke: "rgba(0,0,0,0)",
                sWidth: 0,
                fValue: ""
            }, this.initElement(t, e, n)
        }

        function CVEffects() {}

        function HBaseElement(t, e, n) {}

        function HSolidElement(t, e, n) {
            this.initElement(t, e, n)
        }

        function HCompElement(t, e, n) {
            this.layers = t.layers, this.supports3d = !t.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(t, e, n), this.tm = t.tm ? PropertyFactory.getProp(this, t.tm, 0, e.frameRate, this) : {
                _placeholder: !0
            }
        }

        function HShapeElement(t, e, n) {
            this.shapes = [], this.shapesData = t.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(t, e, n), this.prevViewData = [], this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
            }
        }

        function HTextElement(t, e, n) {
            this.textSpans = [], this.textPaths = [], this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
            }, this.renderType = "svg", this.isMasked = !1, this.initElement(t, e, n)
        }

        function HImageElement(t, e, n) {
            this.assetData = e.getAssetData(t.refId), this.initElement(t, e, n)
        }

        function HCameraElement(t, e, n) {
            this.initFrame(), this.initBaseData(t, e, n), this.initHierarchy();
            var i = PropertyFactory.getProp;
            if (this.pe = i(this, t.pe, 0, 0, this), t.ks.p.s ? (this.px = i(this, t.ks.p.x, 1, 0, this), this.py = i(this, t.ks.p.y, 1, 0, this), this.pz = i(this, t.ks.p.z, 1, 0, this)) : this.p = i(this, t.ks.p, 1, 0, this), t.ks.a && (this.a = i(this, t.ks.a, 1, 0, this)), t.ks.or.k.length && t.ks.or.k[0].to) {
                var r, a = t.ks.or.k.length;
                for (r = 0; r < a; r += 1) t.ks.or.k[r].to = null, t.ks.or.k[r].ti = null
            }
            this.or = i(this, t.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = i(this, t.ks.rx, 0, degToRads, this), this.ry = i(this, t.ks.ry, 0, degToRads, this), this.rz = i(this, t.ks.rz, 0, degToRads, this), this.mat = new Matrix, this._prevMat = new Matrix, this._isFirstFrame = !0, this.finalTransform = {
                mProp: this
            }
        }

        function HEffects() {}
        SVGMatte3Effect.prototype.findSymbol = function (t) {
            for (var e = 0, n = _svgMatteSymbols.length; e < n;) {
                if (_svgMatteSymbols[e] === t) return _svgMatteSymbols[e];
                e += 1
            }
            return null
        }, SVGMatte3Effect.prototype.replaceInParent = function (t, e) {
            var n = t.layerElement.parentNode;
            if (n) {
                for (var i, r = n.children, a = 0, s = r.length; a < s && r[a] !== t.layerElement;) a += 1;
                a <= s - 2 && (i = r[a + 1]);
                var o = createNS("use");
                o.setAttribute("href", "#" + e), i ? n.insertBefore(o, i) : n.appendChild(o)
            }
        }, SVGMatte3Effect.prototype.setElementAsMask = function (t, e) {
            if (!this.findSymbol(e)) {
                var n = createElementID(),
                    i = createNS("mask");
                i.setAttribute("id", e.layerId), i.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(e);
                var r = t.globalData.defs;
                r.appendChild(i);
                var a = createNS("symbol");
                a.setAttribute("id", n), this.replaceInParent(e, n), a.appendChild(e.layerElement), r.appendChild(a);
                var s = createNS("use");
                s.setAttribute("href", "#" + n), i.appendChild(s), e.data.hd = !1, e.show()
            }
            t.setMatte(e.layerId)
        }, SVGMatte3Effect.prototype.initialize = function () {
            for (var t = this.filterManager.effectElements[0].p.v, e = this.elem.comp.elements, n = 0, i = e.length; n < i;) e[n] && e[n].data.ind === t && this.setElementAsMask(this.elem, e[n]), n += 1;
            this.initialized = !0
        }, SVGMatte3Effect.prototype.renderFrame = function () {
            this.initialized || this.initialize()
        }, SVGEffects.prototype.renderFrame = function (t) {
            var e, n = this.filters.length;
            for (e = 0; e < n; e += 1) this.filters[e].renderFrame(t)
        }, CVContextData.prototype.duplicate = function () {
            var t = 2 * this._length,
                e = this.savedOp;
            this.savedOp = createTypedArray("float32", t), this.savedOp.set(e);
            var n = 0;
            for (n = this._length; n < t; n += 1) this.saved[n] = createTypedArray("float32", 16);
            this._length = t
        }, CVContextData.prototype.reset = function () {
            this.cArrPos = 0, this.cTr.reset(), this.cO = 1
        }, CVBaseElement.prototype = {
            createElements: function () {},
            initRendererElement: function () {},
            createContainerElements: function () {
                this.canvasContext = this.globalData.canvasContext, this.renderableEffectsManager = new CVEffects(this)
            },
            createContent: function () {},
            setBlendMode: function () {
                var t = this.globalData;
                if (t.blendMode !== this.data.bm) {
                    t.blendMode = this.data.bm;
                    var e = getBlendMode(this.data.bm);
                    t.canvasContext.globalCompositeOperation = e
                }
            },
            createRenderableComponents: function () {
                this.maskManager = new CVMaskElement(this.data, this)
            },
            hideElement: function () {
                this.hidden || this.isInRange && !this.isTransparent || (this.hidden = !0)
            },
            showElement: function () {
                this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0)
            },
            renderFrame: function () {
                if (!this.hidden && !this.data.hd) {
                    this.renderTransform(), this.renderRenderable(), this.setBlendMode();
                    var t = 0 === this.data.ty;
                    this.globalData.renderer.save(t), this.globalData.renderer.ctxTransform(this.finalTransform.mat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v), this.renderInnerContent(), this.globalData.renderer.restore(t), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1)
                }
            },
            destroy: function () {
                this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy()
            },
            mHelper: new Matrix
        }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function () {
            if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
                var t = createTag("canvas");
                t.width = this.assetData.w, t.height = this.assetData.h;
                var e, n, i = t.getContext("2d"),
                    r = this.img.width,
                    a = this.img.height,
                    s = r / a,
                    o = this.assetData.w / this.assetData.h,
                    l = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
                s > o && "xMidYMid slice" === l || s < o && "xMidYMid slice" !== l ? e = (n = a) * o : n = (e = r) / o, i.drawImage(this.img, (r - e) / 2, (a - n) / 2, e, n, 0, 0, this.assetData.w, this.assetData.h), this.img = t
            }
        }, CVImageElement.prototype.renderInnerContent = function (t) {
            this.canvasContext.drawImage(this.img, 0, 0)
        }, CVImageElement.prototype.destroy = function () {
            this.img = null
        }, extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function () {
            var t, e = this.canvasContext;
            for (e.beginPath(), e.moveTo(0, 0), e.lineTo(this.data.w, 0), e.lineTo(this.data.w, this.data.h), e.lineTo(0, this.data.h), e.lineTo(0, 0), e.clip(), t = this.layers.length - 1; t >= 0; t -= 1)(this.completeLayers || this.elements[t]) && this.elements[t].renderFrame()
        }, CVCompElement.prototype.destroy = function () {
            var t;
            for (t = this.layers.length - 1; t >= 0; t -= 1) this.elements[t] && this.elements[t].destroy();
            this.layers = null, this.elements = null
        }, CVMaskElement.prototype.renderFrame = function () {
            if (this.hasMasks) {
                var t, e, n, i, r = this.element.finalTransform.mat,
                    a = this.element.canvasContext,
                    s = this.masksProperties.length;
                for (a.beginPath(), t = 0; t < s; t++)
                    if ("n" !== this.masksProperties[t].mode) {
                        this.masksProperties[t].inv && (a.moveTo(0, 0), a.lineTo(this.element.globalData.compSize.w, 0), a.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), a.lineTo(0, this.element.globalData.compSize.h), a.lineTo(0, 0)), i = this.viewData[t].v, e = r.applyToPointArray(i.v[0][0], i.v[0][1], 0), a.moveTo(e[0], e[1]);
                        var o, l = i._length;
                        for (o = 1; o < l; o++) n = r.applyToTriplePoints(i.o[o - 1], i.i[o], i.v[o]), a.bezierCurveTo(n[0], n[1], n[2], n[3], n[4], n[5]);
                        n = r.applyToTriplePoints(i.o[o - 1], i.i[0], i.v[0]), a.bezierCurveTo(n[0], n[1], n[2], n[3], n[4], n[5])
                    } this.element.globalData.renderer.save(!0), a.clip()
            }
        }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function () {
            this.element = null
        }, extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = {
            opacity: 1,
            _opMdf: !1
        }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function () {
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
        }, CVShapeElement.prototype.createStyleElement = function (t, e) {
            var n = {
                    data: t,
                    type: t.ty,
                    preTransforms: this.transformsManager.addTransformSequence(e),
                    transforms: [],
                    elements: [],
                    closed: !0 === t.hd
                },
                i = {};
            if ("fl" == t.ty || "st" == t.ty ? (i.c = PropertyFactory.getProp(this, t.c, 1, 255, this), i.c.k || (n.co = "rgb(" + bm_floor(i.c.v[0]) + "," + bm_floor(i.c.v[1]) + "," + bm_floor(i.c.v[2]) + ")")) : "gf" !== t.ty && "gs" !== t.ty || (i.s = PropertyFactory.getProp(this, t.s, 1, null, this), i.e = PropertyFactory.getProp(this, t.e, 1, null, this), i.h = PropertyFactory.getProp(this, t.h || {
                    k: 0
                }, 0, .01, this), i.a = PropertyFactory.getProp(this, t.a || {
                    k: 0
                }, 0, degToRads, this), i.g = new GradientProperty(this, t.g, this)), i.o = PropertyFactory.getProp(this, t.o, 0, .01, this), "st" == t.ty || "gs" == t.ty) {
                if (n.lc = this.lcEnum[t.lc] || "round", n.lj = this.ljEnum[t.lj] || "round", 1 == t.lj && (n.ml = t.ml), i.w = PropertyFactory.getProp(this, t.w, 0, null, this), i.w.k || (n.wi = i.w.v), t.d) {
                    var r = new DashProperty(this, t.d, "canvas", this);
                    i.d = r, i.d.k || (n.da = i.d.dashArray, n.do = i.d.dashoffset[0])
                }
            } else n.r = 2 === t.r ? "evenodd" : "nonzero";
            return this.stylesList.push(n), i.style = n, i
        }, CVShapeElement.prototype.createGroupElement = function (t) {
            return {
                it: [],
                prevViewData: []
            }
        }, CVShapeElement.prototype.createTransformElement = function (t) {
            return {
                transform: {
                    opacity: 1,
                    _opMdf: !1,
                    key: this.transformsManager.getNewKey(),
                    op: PropertyFactory.getProp(this, t.o, 0, .01, this),
                    mProps: TransformPropertyFactory.getTransformProperty(this, t, this)
                }
            }
        }, CVShapeElement.prototype.createShapeElement = function (t) {
            var e = new CVShapeData(this, t, this.stylesList, this.transformsManager);
            return this.shapes.push(e), this.addShapeToModifiers(e), e
        }, CVShapeElement.prototype.reloadShapes = function () {
            this._isFirstFrame = !0;
            var t, e = this.itemsData.length;
            for (t = 0; t < e; t += 1) this.prevViewData[t] = this.itemsData[t];
            for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), e = this.dynamicProperties.length, t = 0; t < e; t += 1) this.dynamicProperties[t].getValue();
            this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame)
        }, CVShapeElement.prototype.addTransformToStyleList = function (t) {
            var e, n = this.stylesList.length;
            for (e = 0; e < n; e += 1) this.stylesList[e].closed || this.stylesList[e].transforms.push(t)
        }, CVShapeElement.prototype.removeTransformFromStyleList = function () {
            var t, e = this.stylesList.length;
            for (t = 0; t < e; t += 1) this.stylesList[t].closed || this.stylesList[t].transforms.pop()
        }, CVShapeElement.prototype.closeStyles = function (t) {
            var e, n = t.length;
            for (e = 0; e < n; e += 1) t[e].closed = !0
        }, CVShapeElement.prototype.searchShapes = function (t, e, n, i, r) {
            var a, s, o, l, h, u, c = t.length - 1,
                p = [],
                f = [],
                d = [].concat(r);
            for (a = c; a >= 0; a -= 1) {
                if ((l = this.searchProcessedElement(t[a])) ? e[a] = n[l - 1] : t[a]._shouldRender = i, "fl" == t[a].ty || "st" == t[a].ty || "gf" == t[a].ty || "gs" == t[a].ty) l ? e[a].style.closed = !1 : e[a] = this.createStyleElement(t[a], d), p.push(e[a].style);
                else if ("gr" == t[a].ty) {
                    if (l)
                        for (o = e[a].it.length, s = 0; s < o; s += 1) e[a].prevViewData[s] = e[a].it[s];
                    else e[a] = this.createGroupElement(t[a]);
                    this.searchShapes(t[a].it, e[a].it, e[a].prevViewData, i, d)
                } else "tr" == t[a].ty ? (l || (u = this.createTransformElement(t[a]), e[a] = u), d.push(e[a]), this.addTransformToStyleList(e[a])) : "sh" == t[a].ty || "rc" == t[a].ty || "el" == t[a].ty || "sr" == t[a].ty ? l || (e[a] = this.createShapeElement(t[a])) : "tm" == t[a].ty || "rd" == t[a].ty ? (l ? (h = e[a]).closed = !1 : ((h = ShapeModifiers.getModifier(t[a].ty)).init(this, t[a]), e[a] = h, this.shapeModifiers.push(h)), f.push(h)) : "rp" == t[a].ty && (l ? (h = e[a]).closed = !0 : (h = ShapeModifiers.getModifier(t[a].ty), e[a] = h, h.init(this, t, a, e), this.shapeModifiers.push(h), i = !1), f.push(h));
                this.addProcessedElement(t[a], a + 1)
            }
            for (this.removeTransformFromStyleList(), this.closeStyles(p), c = f.length, a = 0; a < c; a += 1) f[a].closed = !0
        }, CVShapeElement.prototype.renderInnerContent = function () {
            this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
        }, CVShapeElement.prototype.renderShapeTransform = function (t, e) {
            (t._opMdf || e.op._mdf || this._isFirstFrame) && (e.opacity = t.opacity, e.opacity *= e.op.v, e._opMdf = !0)
        }, CVShapeElement.prototype.drawLayer = function () {
            var t, e, n, i, r, a, s, o, l, h = this.stylesList.length,
                u = this.globalData.renderer,
                c = this.globalData.canvasContext;
            for (t = 0; t < h; t += 1)
                if (("st" !== (o = (l = this.stylesList[t]).type) && "gs" !== o || 0 !== l.wi) && l.data._shouldRender && 0 !== l.coOp && 0 !== this.globalData.currentGlobalAlpha) {
                    for (u.save(), a = l.elements, "st" === o || "gs" === o ? (c.strokeStyle = "st" === o ? l.co : l.grd, c.lineWidth = l.wi, c.lineCap = l.lc, c.lineJoin = l.lj, c.miterLimit = l.ml || 0) : c.fillStyle = "fl" === o ? l.co : l.grd, u.ctxOpacity(l.coOp), "st" !== o && "gs" !== o && c.beginPath(), u.ctxTransform(l.preTransforms.finalTransform.props), n = a.length, e = 0; e < n; e += 1) {
                        for ("st" !== o && "gs" !== o || (c.beginPath(), l.da && (c.setLineDash(l.da), c.lineDashOffset = l.do)), r = (s = a[e].trNodes).length, i = 0; i < r; i += 1) "m" == s[i].t ? c.moveTo(s[i].p[0], s[i].p[1]) : "c" == s[i].t ? c.bezierCurveTo(s[i].pts[0], s[i].pts[1], s[i].pts[2], s[i].pts[3], s[i].pts[4], s[i].pts[5]) : c.closePath();
                        "st" !== o && "gs" !== o || (c.stroke(), l.da && c.setLineDash(this.dashResetter))
                    }
                    "st" !== o && "gs" !== o && c.fill(l.r), u.restore()
                }
        }, CVShapeElement.prototype.renderShape = function (t, e, n, i) {
            var r, a;
            for (a = t, r = e.length - 1; r >= 0; r -= 1) "tr" == e[r].ty ? (a = n[r].transform, this.renderShapeTransform(t, a)) : "sh" == e[r].ty || "el" == e[r].ty || "rc" == e[r].ty || "sr" == e[r].ty ? this.renderPath(e[r], n[r]) : "fl" == e[r].ty ? this.renderFill(e[r], n[r], a) : "st" == e[r].ty ? this.renderStroke(e[r], n[r], a) : "gf" == e[r].ty || "gs" == e[r].ty ? this.renderGradientFill(e[r], n[r], a) : "gr" == e[r].ty ? this.renderShape(a, e[r].it, n[r].it) : e[r].ty;
            i && this.drawLayer()
        }, CVShapeElement.prototype.renderStyledShape = function (t, e) {
            if (this._isFirstFrame || e._mdf || t.transforms._mdf) {
                var n, i, r, a = t.trNodes,
                    s = e.paths,
                    o = s._length;
                a.length = 0;
                var l = t.transforms.finalTransform;
                for (r = 0; r < o; r += 1) {
                    var h = s.shapes[r];
                    if (h && h.v) {
                        for (i = h._length, n = 1; n < i; n += 1) 1 === n && a.push({
                            t: "m",
                            p: l.applyToPointArray(h.v[0][0], h.v[0][1], 0)
                        }), a.push({
                            t: "c",
                            pts: l.applyToTriplePoints(h.o[n - 1], h.i[n], h.v[n])
                        });
                        1 === i && a.push({
                            t: "m",
                            p: l.applyToPointArray(h.v[0][0], h.v[0][1], 0)
                        }), h.c && i && (a.push({
                            t: "c",
                            pts: l.applyToTriplePoints(h.o[n - 1], h.i[0], h.v[0])
                        }), a.push({
                            t: "z"
                        }))
                    }
                }
                t.trNodes = a
            }
        }, CVShapeElement.prototype.renderPath = function (t, e) {
            if (!0 !== t.hd && t._shouldRender) {
                var n, i = e.styledShapes.length;
                for (n = 0; n < i; n += 1) this.renderStyledShape(e.styledShapes[n], e.sh)
            }
        }, CVShapeElement.prototype.renderFill = function (t, e, n) {
            var i = e.style;
            (e.c._mdf || this._isFirstFrame) && (i.co = "rgb(" + bm_floor(e.c.v[0]) + "," + bm_floor(e.c.v[1]) + "," + bm_floor(e.c.v[2]) + ")"), (e.o._mdf || n._opMdf || this._isFirstFrame) && (i.coOp = e.o.v * n.opacity)
        }, CVShapeElement.prototype.renderGradientFill = function (t, e, n) {
            var i = e.style;
            if (!i.grd || e.g._mdf || e.s._mdf || e.e._mdf || 1 !== t.t && (e.h._mdf || e.a._mdf)) {
                var r = this.globalData.canvasContext,
                    a = e.s.v,
                    s = e.e.v;
                if (1 === t.t) p = r.createLinearGradient(a[0], a[1], s[0], s[1]);
                else var o = Math.sqrt(Math.pow(a[0] - s[0], 2) + Math.pow(a[1] - s[1], 2)),
                    l = Math.atan2(s[1] - a[1], s[0] - a[0]),
                    h = o * (e.h.v >= 1 ? .99 : e.h.v <= -1 ? -.99 : e.h.v),
                    u = Math.cos(l + e.a.v) * h + a[0],
                    c = Math.sin(l + e.a.v) * h + a[1],
                    p = r.createRadialGradient(u, c, 0, a[0], a[1], o);
                var f, d = t.g.p,
                    m = e.g.c,
                    g = 1;
                for (f = 0; f < d; f += 1) e.g._hasOpacity && e.g._collapsable && (g = e.g.o[2 * f + 1]), p.addColorStop(m[4 * f] / 100, "rgba(" + m[4 * f + 1] + "," + m[4 * f + 2] + "," + m[4 * f + 3] + "," + g + ")");
                i.grd = p
            }
            i.coOp = e.o.v * n.opacity
        }, CVShapeElement.prototype.renderStroke = function (t, e, n) {
            var i = e.style,
                r = e.d;
            r && (r._mdf || this._isFirstFrame) && (i.da = r.dashArray, i.do = r.dashoffset[0]), (e.c._mdf || this._isFirstFrame) && (i.co = "rgb(" + bm_floor(e.c.v[0]) + "," + bm_floor(e.c.v[1]) + "," + bm_floor(e.c.v[2]) + ")"), (e.o._mdf || n._opMdf || this._isFirstFrame) && (i.coOp = e.o.v * n.opacity), (e.w._mdf || this._isFirstFrame) && (i.wi = e.w.v)
        }, CVShapeElement.prototype.destroy = function () {
            this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0
        }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function () {
            var t = this.canvasContext;
            t.fillStyle = this.data.sc, t.fillRect(0, 0, this.data.sw, this.data.sh)
        }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function () {
            var t = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(t.l ? t.l.length : 0);
            var e = !1;
            t.fc ? (e = !0, this.values.fill = this.buildColor(t.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = e;
            var n = !1;
            t.sc && (n = !0, this.values.stroke = this.buildColor(t.sc), this.values.sWidth = t.sw);
            var i, r, a = this.globalData.fontManager.getFontByName(t.f),
                s = t.l,
                o = this.mHelper;
            this.stroke = n, this.values.fValue = t.finalSize + "px " + this.globalData.fontManager.getFontByName(t.f).fFamily, r = t.finalText.length;
            var l, h, u, c, p, f, d, m, g, v, y = this.data.singleShape,
                _ = t.tr / 1e3 * t.finalSize,
                x = 0,
                b = 0,
                E = !0,
                w = 0;
            for (i = 0; i < r; i += 1) {
                for (h = (l = this.globalData.fontManager.getCharData(t.finalText[i], a.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily)) && l.data || {}, o.reset(), y && s[i].n && (x = -_, b += t.yOffset, b += E ? 1 : 0, E = !1), d = (p = h.shapes ? h.shapes[0].it : []).length, o.scale(t.finalSize / 100, t.finalSize / 100), y && this.applyTextPropertiesToMatrix(t, o, s[i].line, x, b), g = createSizedArray(d), f = 0; f < d; f += 1) {
                    for (c = p[f].ks.k.i.length, m = p[f].ks.k, v = [], u = 1; u < c; u += 1) 1 == u && v.push(o.applyToX(m.v[0][0], m.v[0][1], 0), o.applyToY(m.v[0][0], m.v[0][1], 0)), v.push(o.applyToX(m.o[u - 1][0], m.o[u - 1][1], 0), o.applyToY(m.o[u - 1][0], m.o[u - 1][1], 0), o.applyToX(m.i[u][0], m.i[u][1], 0), o.applyToY(m.i[u][0], m.i[u][1], 0), o.applyToX(m.v[u][0], m.v[u][1], 0), o.applyToY(m.v[u][0], m.v[u][1], 0));
                    v.push(o.applyToX(m.o[u - 1][0], m.o[u - 1][1], 0), o.applyToY(m.o[u - 1][0], m.o[u - 1][1], 0), o.applyToX(m.i[0][0], m.i[0][1], 0), o.applyToY(m.i[0][0], m.i[0][1], 0), o.applyToX(m.v[0][0], m.v[0][1], 0), o.applyToY(m.v[0][0], m.v[0][1], 0)), g[f] = v
                }
                y && (x += s[i].l, x += _), this.textSpans[w] ? this.textSpans[w].elem = g : this.textSpans[w] = {
                    elem: g
                }, w += 1
            }
        }, CVTextElement.prototype.renderInnerContent = function () {
            var t, e, n, i, r, a, s = this.canvasContext;
            this.finalTransform.mat.props;
            s.font = this.values.fValue, s.lineCap = "butt", s.lineJoin = "miter", s.miterLimit = 4, this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
            var o, l = this.textAnimator.renderedLetters,
                h = this.textProperty.currentData.l;
            e = h.length;
            var u, c, p = null,
                f = null,
                d = null;
            for (t = 0; t < e; t += 1)
                if (!h[t].n) {
                    if ((o = l[t]) && (this.globalData.renderer.save(), this.globalData.renderer.ctxTransform(o.p), this.globalData.renderer.ctxOpacity(o.o)), this.fill) {
                        for (o && o.fc ? p !== o.fc && (p = o.fc, s.fillStyle = o.fc) : p !== this.values.fill && (p = this.values.fill, s.fillStyle = this.values.fill), i = (u = this.textSpans[t].elem).length, this.globalData.canvasContext.beginPath(), n = 0; n < i; n += 1)
                            for (a = (c = u[n]).length, this.globalData.canvasContext.moveTo(c[0], c[1]), r = 2; r < a; r += 6) this.globalData.canvasContext.bezierCurveTo(c[r], c[r + 1], c[r + 2], c[r + 3], c[r + 4], c[r + 5]);
                        this.globalData.canvasContext.closePath(), this.globalData.canvasContext.fill()
                    }
                    if (this.stroke) {
                        for (o && o.sw ? d !== o.sw && (d = o.sw, s.lineWidth = o.sw) : d !== this.values.sWidth && (d = this.values.sWidth, s.lineWidth = this.values.sWidth), o && o.sc ? f !== o.sc && (f = o.sc, s.strokeStyle = o.sc) : f !== this.values.stroke && (f = this.values.stroke, s.strokeStyle = this.values.stroke), i = (u = this.textSpans[t].elem).length, this.globalData.canvasContext.beginPath(), n = 0; n < i; n += 1)
                            for (a = (c = u[n]).length, this.globalData.canvasContext.moveTo(c[0], c[1]), r = 2; r < a; r += 6) this.globalData.canvasContext.bezierCurveTo(c[r], c[r + 1], c[r + 2], c[r + 3], c[r + 4], c[r + 5]);
                        this.globalData.canvasContext.closePath(), this.globalData.canvasContext.stroke()
                    }
                    o && this.globalData.renderer.restore()
                }
        }, CVEffects.prototype.renderFrame = function () {}, HBaseElement.prototype = {
            checkBlendMode: function () {},
            initRendererElement: function () {
                this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement)
            },
            createContainerElements: function () {
                this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 !== this.data.bm && this.setBlendMode()
            },
            renderElement: function () {
                this.finalTransform._matMdf && (this.transformedElement.style.transform = this.transformedElement.style.webkitTransform = this.finalTransform.mat.toCSS()), this.finalTransform._opMdf && (this.transformedElement.style.opacity = this.finalTransform.mProp.o.v)
            },
            renderFrame: function () {
                this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
            },
            destroy: function () {
                this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null)
            },
            createRenderableComponents: function () {
                this.maskManager = new MaskElement(this.data, this, this.globalData)
            },
            addEffects: function () {},
            setMatte: function () {}
        }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function () {
            var t;
            this.data.hasMask ? ((t = createNS("rect")).setAttribute("width", this.data.sw), t.setAttribute("height", this.data.sh), t.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : ((t = createTag("div")).style.width = this.data.sw + "px", t.style.height = this.data.sh + "px", t.style.backgroundColor = this.data.sc), this.layerElement.appendChild(t)
        }, extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function () {
            this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
        }, HCompElement.prototype.addTo3dContainer = function (t, e) {
            for (var n, i = 0; i < e;) this.elements[i] && this.elements[i].getBaseElement && (n = this.elements[i].getBaseElement()), i += 1;
            n ? this.layerElement.insertBefore(t, n) : this.layerElement.appendChild(t)
        }, extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function () {
            var t;
            if (this.baseElement.style.fontSize = 0, this.data.hasMask) this.layerElement.appendChild(this.shapesContainer), t = this.svgElement;
            else {
                t = createNS("svg");
                var e = this.comp.data ? this.comp.data : this.globalData.compSize;
                t.setAttribute("width", e.w), t.setAttribute("height", e.h), t.appendChild(this.shapesContainer), this.layerElement.appendChild(t)
            }
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = t
        }, HShapeElement.prototype.getTransformedPoint = function (t, e) {
            var n, i = t.length;
            for (n = 0; n < i; n += 1) e = t[n].mProps.v.applyToPointArray(e[0], e[1], 0);
            return e
        }, HShapeElement.prototype.calculateShapeBoundingBox = function (t, e) {
            var n, i, r, a, s, o = t.sh.v,
                l = t.transformers,
                h = o._length;
            if (!(h <= 1)) {
                for (n = 0; n < h - 1; n += 1) i = this.getTransformedPoint(l, o.v[n]), r = this.getTransformedPoint(l, o.o[n]), a = this.getTransformedPoint(l, o.i[n + 1]), s = this.getTransformedPoint(l, o.v[n + 1]), this.checkBounds(i, r, a, s, e);
                o.c && (i = this.getTransformedPoint(l, o.v[n]), r = this.getTransformedPoint(l, o.o[n]), a = this.getTransformedPoint(l, o.i[0]), s = this.getTransformedPoint(l, o.v[0]), this.checkBounds(i, r, a, s, e))
            }
        }, HShapeElement.prototype.checkBounds = function (t, e, n, i, r) {
            this.getBoundsOfCurve(t, e, n, i);
            var a = this.shapeBoundingBox;
            r.x = bm_min(a.left, r.x), r.xMax = bm_max(a.right, r.xMax), r.y = bm_min(a.top, r.y), r.yMax = bm_max(a.bottom, r.yMax)
        }, HShapeElement.prototype.shapeBoundingBox = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        }, HShapeElement.prototype.tempBoundingBox = {
            x: 0,
            xMax: 0,
            y: 0,
            yMax: 0,
            width: 0,
            height: 0
        }, HShapeElement.prototype.getBoundsOfCurve = function (t, e, n, i) {
            for (var r, a, s, o, l, h, u, c = [[t[0], i[0]], [t[1], i[1]]], p = 0; p < 2; ++p)
                if (a = 6 * t[p] - 12 * e[p] + 6 * n[p], r = -3 * t[p] + 9 * e[p] - 9 * n[p] + 3 * i[p], s = 3 * e[p] - 3 * t[p], a |= 0, s |= 0, 0 !== (r |= 0))(l = a * a - 4 * s * r) < 0 || (0 < (h = (-a + bm_sqrt(l)) / (2 * r)) && h < 1 && c[p].push(this.calculateF(h, t, e, n, i, p)), 0 < (u = (-a - bm_sqrt(l)) / (2 * r)) && u < 1 && c[p].push(this.calculateF(u, t, e, n, i, p)));
                else {
                    if (0 === a) continue;
                    0 < (o = -s / a) && o < 1 && c[p].push(this.calculateF(o, t, e, n, i, p))
                } this.shapeBoundingBox.left = bm_min.apply(null, c[0]), this.shapeBoundingBox.top = bm_min.apply(null, c[1]), this.shapeBoundingBox.right = bm_max.apply(null, c[0]), this.shapeBoundingBox.bottom = bm_max.apply(null, c[1])
        }, HShapeElement.prototype.calculateF = function (t, e, n, i, r, a) {
            return bm_pow(1 - t, 3) * e[a] + 3 * bm_pow(1 - t, 2) * t * n[a] + 3 * (1 - t) * bm_pow(t, 2) * i[a] + bm_pow(t, 3) * r[a]
        }, HShapeElement.prototype.calculateBoundingBox = function (t, e) {
            var n, i = t.length;
            for (n = 0; n < i; n += 1) t[n] && t[n].sh ? this.calculateShapeBoundingBox(t[n], e) : t[n] && t[n].it && this.calculateBoundingBox(t[n].it, e)
        }, HShapeElement.prototype.currentBoxContains = function (t) {
            return this.currentBBox.x <= t.x && this.currentBBox.y <= t.y && this.currentBBox.width + this.currentBBox.x >= t.x + t.width && this.currentBBox.height + this.currentBBox.y >= t.y + t.height
        }, HShapeElement.prototype.renderInnerContent = function () {
            if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) {
                var t = this.tempBoundingBox,
                    e = 999999;
                if (t.x = e, t.xMax = -e, t.y = e, t.yMax = -e, this.calculateBoundingBox(this.itemsData, t), t.width = t.xMax < t.x ? 0 : t.xMax - t.x, t.height = t.yMax < t.y ? 0 : t.yMax - t.y, this.currentBoxContains(t)) return;
                var n = !1;
                this.currentBBox.w !== t.width && (this.currentBBox.w = t.width, this.shapeCont.setAttribute("width", t.width), n = !0), this.currentBBox.h !== t.height && (this.currentBBox.h = t.height, this.shapeCont.setAttribute("height", t.height), n = !0), (n || this.currentBBox.x !== t.x || this.currentBBox.y !== t.y) && (this.currentBBox.w = t.width, this.currentBBox.h = t.height, this.currentBBox.x = t.x, this.currentBBox.y = t.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), this.shapeCont.style.transform = this.shapeCont.style.webkitTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)")
            }
        }, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function () {
            if (this.isMasked = this.checkMasks(), this.isMasked) {
                this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH);
                var t = createNS("g");
                this.maskedElement.appendChild(t), this.innerElem = t
            } else this.renderType = "html", this.innerElem = this.layerElement;
            this.checkParenting()
        }, HTextElement.prototype.buildNewText = function () {
            var t = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(t.l ? t.l.length : 0);
            var e = this.innerElem.style;
            e.color = e.fill = t.fc ? this.buildColor(t.fc) : "rgba(0,0,0,0)", t.sc && (e.stroke = this.buildColor(t.sc), e.strokeWidth = t.sw + "px");
            var n, i, r = this.globalData.fontManager.getFontByName(t.f);
            if (!this.globalData.fontManager.chars)
                if (e.fontSize = t.finalSize + "px", e.lineHeight = t.finalSize + "px", r.fClass) this.innerElem.className = r.fClass;
                else {
                    e.fontFamily = r.fFamily;
                    var a = t.fWeight,
                        s = t.fStyle;
                    e.fontStyle = s, e.fontWeight = a
                } var o, l, h, u = t.l;
            i = u.length;
            var c, p = this.mHelper,
                f = "",
                d = 0;
            for (n = 0; n < i; n += 1) {
                if (this.globalData.fontManager.chars ? (this.textPaths[d] ? o = this.textPaths[d] : ((o = createNS("path")).setAttribute("stroke-linecap", "butt"), o.setAttribute("stroke-linejoin", "round"), o.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[d] ? h = (l = this.textSpans[d]).children[0] : ((l = createTag("div")).style.lineHeight = 0, (h = createNS("svg")).appendChild(o), styleDiv(l)))) : this.isMasked ? o = this.textPaths[d] ? this.textPaths[d] : createNS("text") : this.textSpans[d] ? (l = this.textSpans[d], o = this.textPaths[d]) : (styleDiv(l = createTag("span")), styleDiv(o = createTag("span")), l.appendChild(o)), this.globalData.fontManager.chars) {
                    var m, g = this.globalData.fontManager.getCharData(t.finalText[n], r.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily);
                    if (m = g ? g.data : null, p.reset(), m && m.shapes && (c = m.shapes[0].it, p.scale(t.finalSize / 100, t.finalSize / 100), f = this.createPathShape(p, c), o.setAttribute("d", f)), this.isMasked) this.innerElem.appendChild(o);
                    else {
                        if (this.innerElem.appendChild(l), m && m.shapes) {
                            document.body.appendChild(h);
                            var v = h.getBBox();
                            h.setAttribute("width", v.width + 2), h.setAttribute("height", v.height + 2), h.setAttribute("viewBox", v.x - 1 + " " + (v.y - 1) + " " + (v.width + 2) + " " + (v.height + 2)), h.style.transform = h.style.webkitTransform = "translate(" + (v.x - 1) + "px," + (v.y - 1) + "px)", u[n].yOffset = v.y - 1
                        } else h.setAttribute("width", 1), h.setAttribute("height", 1);
                        l.appendChild(h)
                    }
                } else o.textContent = u[n].val, o.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked ? this.innerElem.appendChild(o) : (this.innerElem.appendChild(l), o.style.transform = o.style.webkitTransform = "translate3d(0," + -t.finalSize / 1.2 + "px,0)");
                this.isMasked ? this.textSpans[d] = o : this.textSpans[d] = l, this.textSpans[d].style.display = "block", this.textPaths[d] = o, d += 1
            }
            for (; d < this.textSpans.length;) this.textSpans[d].style.display = "none", d += 1
        }, HTextElement.prototype.renderInnerContent = function () {
            if (this.data.singleShape) {
                if (!this._isFirstFrame && !this.lettersChangedFlag) return;
                this.isMasked && this.finalTransform._matMdf && (this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), this.svgElement.style.transform = this.svgElement.style.webkitTransform = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)")
            }
            if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
                var t, e, n, i, r, a = 0,
                    s = this.textAnimator.renderedLetters,
                    o = this.textProperty.currentData.l;
                for (e = o.length, t = 0; t < e; t += 1) o[t].n ? a += 1 : (i = this.textSpans[t], r = this.textPaths[t], n = s[a], a += 1, n._mdf.m && (this.isMasked ? i.setAttribute("transform", n.m) : i.style.transform = i.style.webkitTransform = n.m), i.style.opacity = n.o, n.sw && n._mdf.sw && r.setAttribute("stroke-width", n.sw), n.sc && n._mdf.sc && r.setAttribute("stroke", n.sc), n.fc && n._mdf.fc && (r.setAttribute("fill", n.fc), r.style.color = n.fc));
                if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                    var l = this.innerElem.getBBox();
                    this.currentBBox.w !== l.width && (this.currentBBox.w = l.width, this.svgElement.setAttribute("width", l.width)), this.currentBBox.h !== l.height && (this.currentBBox.h = l.height, this.svgElement.setAttribute("height", l.height));
                    this.currentBBox.w === l.width + 2 && this.currentBBox.h === l.height + 2 && this.currentBBox.x === l.x - 1 && this.currentBBox.y === l.y - 1 || (this.currentBBox.w = l.width + 2, this.currentBBox.h = l.height + 2, this.currentBBox.x = l.x - 1, this.currentBBox.y = l.y - 1, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), this.svgElement.style.transform = this.svgElement.style.webkitTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)")
                }
            }
        }, extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function () {
            var t = this.globalData.getAssetsPath(this.assetData),
                e = new Image;
            this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", t), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(e), e.src = t, this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
        }, extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function () {
            var t, e, n = this.comp.threeDElements.length;
            for (t = 0; t < n; t += 1) "3d" === (e = this.comp.threeDElements[t]).type && (e.perspectiveElem.style.perspective = e.perspectiveElem.style.webkitPerspective = this.pe.v + "px", e.container.style.transformOrigin = e.container.style.mozTransformOrigin = e.container.style.webkitTransformOrigin = "0px 0px 0px", e.perspectiveElem.style.transform = e.perspectiveElem.style.webkitTransform = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)")
        }, HCameraElement.prototype.createElements = function () {}, HCameraElement.prototype.hide = function () {}, HCameraElement.prototype.renderFrame = function () {
            var t, e, n = this._isFirstFrame;
            if (this.hierarchy)
                for (e = this.hierarchy.length, t = 0; t < e; t += 1) n = this.hierarchy[t].finalTransform.mProp._mdf || n;
            if (n || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
                if (this.mat.reset(), this.hierarchy)
                    for (t = e = this.hierarchy.length - 1; t >= 0; t -= 1) {
                        var i = this.hierarchy[t].finalTransform.mProp;
                        this.mat.translate(-i.p.v[0], -i.p.v[1], i.p.v[2]), this.mat.rotateX(-i.or.v[0]).rotateY(-i.or.v[1]).rotateZ(i.or.v[2]), this.mat.rotateX(-i.rx.v).rotateY(-i.ry.v).rotateZ(i.rz.v), this.mat.scale(1 / i.s.v[0], 1 / i.s.v[1], 1 / i.s.v[2]), this.mat.translate(i.a.v[0], i.a.v[1], i.a.v[2])
                    }
                if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) {
                    var r;
                    r = this.p ? [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                    var a = Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2) + Math.pow(r[2], 2)),
                        s = [r[0] / a, r[1] / a, r[2] / a],
                        o = Math.sqrt(s[2] * s[2] + s[0] * s[0]),
                        l = Math.atan2(s[1], o),
                        h = Math.atan2(s[0], -s[2]);
                    this.mat.rotateY(h).rotateX(-l)
                }
                this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v);
                var u = !this._prevMat.equals(this.mat);
                if ((u || this.pe._mdf) && this.comp.threeDElements) {
                    var c;
                    for (e = this.comp.threeDElements.length, t = 0; t < e; t += 1) "3d" === (c = this.comp.threeDElements[t]).type && (u && (c.container.style.transform = c.container.style.webkitTransform = this.mat.toCSS()), this.pe._mdf && (c.perspectiveElem.style.perspective = c.perspectiveElem.style.webkitPerspective = this.pe.v + "px"));
                    this.mat.clone(this._prevMat)
                }
            }
            this._isFirstFrame = !1
        }, HCameraElement.prototype.prepareFrame = function (t) {
            this.prepareProperties(t, !0)
        }, HCameraElement.prototype.destroy = function () {}, HCameraElement.prototype.getBaseElement = function () {
            return null
        }, HEffects.prototype.renderFrame = function () {};
        var animationManager = function () {
                var t = {},
                    e = [],
                    n = 0,
                    i = 0,
                    r = 0,
                    a = !0,
                    s = !1;

                function o(t) {
                    for (var n = 0, r = t.target; n < i;) e[n].animation === r && (e.splice(n, 1), n -= 1, i -= 1, r.isPaused || u()), n += 1
                }

                function l(t, n) {
                    if (!t) return null;
                    for (var r = 0; r < i;) {
                        if (e[r].elem == t && null !== e[r].elem) return e[r].animation;
                        r += 1
                    }
                    var a = new AnimationItem;
                    return c(a, t), a.setData(t, n), a
                }

                function h() {
                    r += 1, d()
                }

                function u() {
                    r -= 1
                }

                function c(t, n) {
                    t.addEventListener("destroy", o), t.addEventListener("_active", h), t.addEventListener("_idle", u), e.push({
                        elem: n,
                        animation: t
                    }), i += 1
                }

                function p(t) {
                    var o, l = t - n;
                    for (o = 0; o < i; o += 1) e[o].animation.advanceTime(l);
                    n = t, r && !s ? window.requestAnimationFrame(p) : a = !0
                }

                function f(t) {
                    n = t, window.requestAnimationFrame(p)
                }

                function d() {
                    !s && r && a && (window.requestAnimationFrame(f), a = !1)
                }
                return t.registerAnimation = l, t.loadAnimation = function (t) {
                    var e = new AnimationItem;
                    return c(e, null), e.setParams(t), e
                }, t.setSpeed = function (t, n) {
                    var r;
                    for (r = 0; r < i; r += 1) e[r].animation.setSpeed(t, n)
                }, t.setDirection = function (t, n) {
                    var r;
                    for (r = 0; r < i; r += 1) e[r].animation.setDirection(t, n)
                }, t.play = function (t) {
                    var n;
                    for (n = 0; n < i; n += 1) e[n].animation.play(t)
                }, t.pause = function (t) {
                    var n;
                    for (n = 0; n < i; n += 1) e[n].animation.pause(t)
                }, t.stop = function (t) {
                    var n;
                    for (n = 0; n < i; n += 1) e[n].animation.stop(t)
                }, t.togglePause = function (t) {
                    var n;
                    for (n = 0; n < i; n += 1) e[n].animation.togglePause(t)
                }, t.searchAnimations = function (t, e, n) {
                    var i, r = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))),
                        a = r.length;
                    for (i = 0; i < a; i += 1) n && r[i].setAttribute("data-bm-type", n), l(r[i], t);
                    if (e && 0 === a) {
                        n || (n = "svg");
                        var s = document.getElementsByTagName("body")[0];
                        s.innerHTML = "";
                        var o = createTag("div");
                        o.style.width = "100%", o.style.height = "100%", o.setAttribute("data-bm-type", n), s.appendChild(o), l(o, t)
                    }
                }, t.resize = function () {
                    var t;
                    for (t = 0; t < i; t += 1) e[t].animation.resize()
                }, t.goToAndStop = function (t, n, r) {
                    var a;
                    for (a = 0; a < i; a += 1) e[a].animation.goToAndStop(t, n, r)
                }, t.destroy = function (t) {
                    var n;
                    for (n = i - 1; n >= 0; n -= 1) e[n].animation.destroy(t)
                }, t.freeze = function () {
                    s = !0
                }, t.unfreeze = function () {
                    s = !1, d()
                }, t.getRegisteredAnimations = function () {
                    var t, n = e.length,
                        i = [];
                    for (t = 0; t < n; t += 1) i.push(e[t].animation);
                    return i
                }, t
            }(),
            AnimationItem = function () {
                this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.subframeEnabled = subframeEnabled, this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader
            };
        extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function (t) {
            t.context && (this.context = t.context), (t.wrapper || t.container) && (this.wrapper = t.wrapper || t.container);
            var e = t.animType ? t.animType : t.renderer ? t.renderer : "svg";
            switch (e) {
                case "canvas":
                    this.renderer = new CanvasRenderer(this, t.rendererSettings);
                    break;
                case "svg":
                    this.renderer = new SVGRenderer(this, t.rendererSettings);
                    break;
                default:
                    this.renderer = new HybridRenderer(this, t.rendererSettings)
            }
            this.renderer.setProjectInterface(this.projectInterface), this.animType = e, "" === t.loop || null === t.loop || (!1 === t.loop ? this.loop = !1 : !0 === t.loop ? this.loop = !0 : this.loop = parseInt(t.loop)), this.autoplay = !("autoplay" in t) || t.autoplay, this.name = t.name ? t.name : "", this.autoloadSegments = !t.hasOwnProperty("autoloadSegments") || t.autoloadSegments, this.assetsPath = t.assetsPath, this.initialSegment = t.initialSegment, t.animationData ? this.configAnimation(t.animationData) : t.path && (-1 !== t.path.lastIndexOf("\\") ? this.path = t.path.substr(0, t.path.lastIndexOf("\\") + 1) : this.path = t.path.substr(0, t.path.lastIndexOf("/") + 1), this.fileName = t.path.substr(t.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json"))
            
//            , assetLoader.load(t.path, this.configAnimation.bind(this), function () {
//                this.trigger("data_failed")
//            }.bind(this))
            )
        }, AnimationItem.prototype.setData = function (t, e) {
            var n = {
                    wrapper: t,
                    animationData: e ? "object" == typeof e ? e : JSON.parse(e) : null
                },
                i = t.attributes;
            n.path = i.getNamedItem("data-animation-path") ? i.getNamedItem("data-animation-path").value : i.getNamedItem("data-bm-path") ? i.getNamedItem("data-bm-path").value : i.getNamedItem("bm-path") ? i.getNamedItem("bm-path").value : "", n.animType = i.getNamedItem("data-anim-type") ? i.getNamedItem("data-anim-type").value : i.getNamedItem("data-bm-type") ? i.getNamedItem("data-bm-type").value : i.getNamedItem("bm-type") ? i.getNamedItem("bm-type").value : i.getNamedItem("data-bm-renderer") ? i.getNamedItem("data-bm-renderer").value : i.getNamedItem("bm-renderer") ? i.getNamedItem("bm-renderer").value : "canvas";
            var r = i.getNamedItem("data-anim-loop") ? i.getNamedItem("data-anim-loop").value : i.getNamedItem("data-bm-loop") ? i.getNamedItem("data-bm-loop").value : i.getNamedItem("bm-loop") ? i.getNamedItem("bm-loop").value : "";
            "" === r || (n.loop = "false" !== r && ("true" === r || parseInt(r)));
            var a = i.getNamedItem("data-anim-autoplay") ? i.getNamedItem("data-anim-autoplay").value : i.getNamedItem("data-bm-autoplay") ? i.getNamedItem("data-bm-autoplay").value : !i.getNamedItem("bm-autoplay") || i.getNamedItem("bm-autoplay").value;
            n.autoplay = "false" !== a, n.name = i.getNamedItem("data-name") ? i.getNamedItem("data-name").value : i.getNamedItem("data-bm-name") ? i.getNamedItem("data-bm-name").value : i.getNamedItem("bm-name") ? i.getNamedItem("bm-name").value : "", "false" === (i.getNamedItem("data-anim-prerender") ? i.getNamedItem("data-anim-prerender").value : i.getNamedItem("data-bm-prerender") ? i.getNamedItem("data-bm-prerender").value : i.getNamedItem("bm-prerender") ? i.getNamedItem("bm-prerender").value : "") && (n.prerender = !1), this.setParams(n)
        }, AnimationItem.prototype.includeLayers = function (t) {
            t.op > this.animationData.op && (this.animationData.op = t.op, this.totalFrames = Math.floor(t.op - this.animationData.ip));
            var e, n, i = this.animationData.layers,
                r = i.length,
                a = t.layers,
                s = a.length;
            for (n = 0; n < s; n += 1)
                for (e = 0; e < r;) {
                    if (i[e].id == a[n].id) {
                        i[e] = a[n];
                        break
                    }
                    e += 1
                }
            if ((t.chars || t.fonts) && (this.renderer.globalData.fontManager.addChars(t.chars), this.renderer.globalData.fontManager.addFonts(t.fonts, this.renderer.globalData.defs)), t.assets)
                for (r = t.assets.length, e = 0; e < r; e += 1) this.animationData.assets.push(t.assets[e]);
            this.animationData.__complete = !1, dataManager.completeData(this.animationData, this.renderer.globalData.fontManager), this.renderer.includeLayers(t.layers), expressionsPlugin && expressionsPlugin.initExpressions(this), this.loadNextSegment()
        }, AnimationItem.prototype.loadNextSegment = function () {
            var t = this.animationData.segments;
            if (!t || 0 === t.length || !this.autoloadSegments) return this.trigger("data_ready"), void(this.timeCompleted = this.totalFrames);
            var e = t.shift();
            this.timeCompleted = e.time * this.frameRate;
            var n = this.path + this.fileName + "_" + this.segmentPos + ".json";
            this.segmentPos += 1, assetLoader.load(n, this.includeLayers.bind(this), function () {
                this.trigger("data_failed")
            }.bind(this))
        }, AnimationItem.prototype.loadSegments = function () {
            this.animationData.segments || (this.timeCompleted = this.totalFrames), this.loadNextSegment()
        }, AnimationItem.prototype.imagesLoaded = function () {
            this.trigger("loaded_images"), this.checkLoaded()
        }, AnimationItem.prototype.preloadImages = function () {
            this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
        }, AnimationItem.prototype.configAnimation = function (t) {
            if (this.renderer) try {
                this.animationData = t, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(t), t.assets || (t.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(t.assets), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded()
            } catch (t) {
                this.triggerConfigError(t)
            }
        }, AnimationItem.prototype.waitForFontsLoaded = function () {
            this.renderer && (this.renderer.globalData.fontManager.loaded() ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
        }, AnimationItem.prototype.checkLoaded = function () {
            this.isLoaded || !this.renderer.globalData.fontManager.loaded() || !this.imagePreloader.loaded() && "canvas" === this.renderer.rendererType || (this.isLoaded = !0, dataManager.completeData(this.animationData, this.renderer.globalData.fontManager), expressionsPlugin && expressionsPlugin.initExpressions(this), this.renderer.initItems(), setTimeout(function () {
                this.trigger("DOMLoaded")
            }.bind(this), 0), this.gotoFrame(), this.autoplay && this.play())
        }, AnimationItem.prototype.resize = function () {
            this.renderer.updateContainerSize()
        }, AnimationItem.prototype.setSubframe = function (t) {
            this.subframeEnabled = !!t
        }, AnimationItem.prototype.gotoFrame = function () {
            this.currentFrame = this.subframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame()
        }, AnimationItem.prototype.renderFrame = function () {
            if (!1 !== this.isLoaded) try {
                this.renderer.renderFrame(this.currentFrame + this.firstFrame)
            } catch (t) {
                this.triggerRenderFrameError(t)
            }
        }, AnimationItem.prototype.play = function (t) {
            t && this.name != t || !0 === this.isPaused && (this.isPaused = !1, this._idle && (this._idle = !1, this.trigger("_active")))
        }, AnimationItem.prototype.pause = function (t) {
            t && this.name != t || !1 === this.isPaused && (this.isPaused = !0, this._idle = !0, this.trigger("_idle"))
        }, AnimationItem.prototype.togglePause = function (t) {
            t && this.name != t || (!0 === this.isPaused ? this.play() : this.pause())
        }, AnimationItem.prototype.stop = function (t) {
            t && this.name != t || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0))
        }, AnimationItem.prototype.goToAndStop = function (t, e, n) {
            n && this.name != n || (e ? this.setCurrentRawFrameValue(t) : this.setCurrentRawFrameValue(t * this.frameModifier), this.pause())
        }, AnimationItem.prototype.goToAndPlay = function (t, e, n) {
            this.goToAndStop(t, e, n), this.play()
        }, AnimationItem.prototype.advanceTime = function (t) {
            if (!0 !== this.isPaused && !1 !== this.isLoaded) {
                var e = this.currentRawFrame + t * this.frameModifier,
                    n = !1;
                e >= this.totalFrames - 1 && this.frameModifier > 0 ? this.loop && this.playCount !== this.loop ? e >= this.totalFrames ? (this.playCount += 1, this.checkSegments(e % this.totalFrames) || (this.setCurrentRawFrameValue(e % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(e) : this.checkSegments(e > this.totalFrames ? e % this.totalFrames : 0) || (n = !0, e = this.totalFrames - 1) : e < 0 ? this.checkSegments(e % this.totalFrames) || (!this.loop || this.playCount-- <= 0 && !0 !== this.loop ? (n = !0, e = 0) : (this.setCurrentRawFrameValue(this.totalFrames + e % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0)) : this.setCurrentRawFrameValue(e), n && (this.setCurrentRawFrameValue(e), this.pause(), this.trigger("complete"))
            }
        }, AnimationItem.prototype.adjustSegment = function (t, e) {
            this.playCount = 0, t[1] < t[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.timeCompleted = this.totalFrames = t[0] - t[1], this.firstFrame = t[1], this.setCurrentRawFrameValue(this.totalFrames - .001 - e)) : t[1] > t[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.timeCompleted = this.totalFrames = t[1] - t[0], this.firstFrame = t[0], this.setCurrentRawFrameValue(.001 + e)), this.trigger("segmentStart")
        }, AnimationItem.prototype.setSegment = function (t, e) {
            var n = -1;
            this.isPaused && (this.currentRawFrame + this.firstFrame < t ? n = t : this.currentRawFrame + this.firstFrame > e && (n = e - t)), this.firstFrame = t, this.timeCompleted = this.totalFrames = e - t, -1 !== n && this.goToAndStop(n, !0)
        }, AnimationItem.prototype.playSegments = function (t, e) {
            if (e && (this.segments.length = 0), "object" == typeof t[0]) {
                var n, i = t.length;
                for (n = 0; n < i; n += 1) this.segments.push(t[n])
            } else this.segments.push(t);
            this.segments.length && e && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play()
        }, AnimationItem.prototype.resetSegments = function (t) {
            this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), t && this.checkSegments(0)
        }, AnimationItem.prototype.checkSegments = function (t) {
            return !!this.segments.length && (this.adjustSegment(this.segments.shift(), t), !0)
        }, AnimationItem.prototype.destroy = function (t) {
            t && this.name != t || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = this.onLoopComplete = this.onComplete = this.onSegmentStart = this.onDestroy = null, this.renderer = null)
        }, AnimationItem.prototype.setCurrentRawFrameValue = function (t) {
            this.currentRawFrame = t, this.gotoFrame()
        }, AnimationItem.prototype.setSpeed = function (t) {
            this.playSpeed = t, this.updaFrameModifier()
        }, AnimationItem.prototype.setDirection = function (t) {
            this.playDirection = t < 0 ? -1 : 1, this.updaFrameModifier()
        }, AnimationItem.prototype.updaFrameModifier = function () {
            this.frameModifier = this.frameMult * this.playSpeed * this.playDirection
        }, AnimationItem.prototype.getPath = function () {
            return this.path
        }, AnimationItem.prototype.getAssetsPath = function (t) {
            var e = "";
            if (t.e) e = t.p;
            else if (this.assetsPath) {
                var n = t.p; - 1 !== n.indexOf("images/") && (n = n.split("/")[1]), e = this.assetsPath + n
            } else e = this.path, e += t.u ? t.u : "", e += t.p;
            return e
        }, AnimationItem.prototype.getAssetData = function (t) {
            for (var e = 0, n = this.assets.length; e < n;) {
                if (t == this.assets[e].id) return this.assets[e];
                e += 1
            }
        }, AnimationItem.prototype.hide = function () {
            this.renderer.hide()
        }, AnimationItem.prototype.show = function () {
            this.renderer.show()
        }, AnimationItem.prototype.getDuration = function (t) {
            return t ? this.totalFrames : this.totalFrames / this.frameRate
        }, AnimationItem.prototype.trigger = function (t) {
            if (this._cbs && this._cbs[t]) switch (t) {
                case "enterFrame":
                    this.triggerEvent(t, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameModifier));
                    break;
                case "loopComplete":
                    this.triggerEvent(t, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult));
                    break;
                case "complete":
                    this.triggerEvent(t, new BMCompleteEvent(t, this.frameMult));
                    break;
                case "segmentStart":
                    this.triggerEvent(t, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames));
                    break;
                case "destroy":
                    this.triggerEvent(t, new BMDestroyEvent(t, this));
                    break;
                default:
                    this.triggerEvent(t)
            }
            "enterFrame" === t && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameMult)), "loopComplete" === t && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult)), "complete" === t && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(t, this.frameMult)), "segmentStart" === t && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames)), "destroy" === t && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(t, this))
        }, AnimationItem.prototype.triggerRenderFrameError = function (t) {
            var e = new BMRenderFrameErrorEvent(t, this.currentFrame);
            this.triggerEvent("error", e), this.onError && this.onError.call(this, e)
        }, AnimationItem.prototype.triggerConfigError = function (t) {
            var e = new BMConfigErrorEvent(t, this.currentFrame);
            this.triggerEvent("error", e), this.onError && this.onError.call(this, e)
        };
        var Expressions = function () {
            var t = {};
            return t.initExpressions = function (t) {
                var e = 0,
                    n = [];
                t.renderer.compInterface = CompExpressionInterface(t.renderer), t.renderer.globalData.projectInterface.registerComposition(t.renderer), t.renderer.globalData.pushExpression = function () {
                    e += 1
                }, t.renderer.globalData.popExpression = function () {
                    0 === (e -= 1) && function () {
                        var t, e = n.length;
                        for (t = 0; t < e; t += 1) n[t].release();
                        n.length = 0
                    }()
                }, t.renderer.globalData.registerExpressionProperty = function (t) {
                    -1 === n.indexOf(t) && n.push(t)
                }
            }, t
        }();
        expressionsPlugin = Expressions;
        var ExpressionManager = function () {
                var ob = {},
                    Math = BMMath,
                    window = null,
                    document = null;

                function $bm_isInstanceOfArray(t) {
                    return t.constructor === Array || t.constructor === Float32Array
                }

                function isNumerable(t, e) {
                    return "number" === t || "boolean" === t || "string" === t || e instanceof Number
                }

                function $bm_neg(t) {
                    var e = typeof t;
                    if ("number" === e || "boolean" === e || t instanceof Number) return -t;
                    if ($bm_isInstanceOfArray(t)) {
                        var n, i = t.length,
                            r = [];
                        for (n = 0; n < i; n += 1) r[n] = -t[n];
                        return r
                    }
                    return t.propType ? t.v : void 0
                }
                var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get,
                    easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get,
                    easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;

                function sum(t, e) {
                    var n = typeof t,
                        i = typeof e;
                    if ("string" === n || "string" === i) return t + e;
                    if (isNumerable(n, t) && isNumerable(i, e)) return t + e;
                    if ($bm_isInstanceOfArray(t) && isNumerable(i, e)) return (t = t.slice(0))[0] = t[0] + e, t;
                    if (isNumerable(n, t) && $bm_isInstanceOfArray(e)) return (e = e.slice(0))[0] = t + e[0], e;
                    if ($bm_isInstanceOfArray(t) && $bm_isInstanceOfArray(e)) {
                        for (var r = 0, a = t.length, s = e.length, o = []; r < a || r < s;)("number" == typeof t[r] || t[r] instanceof Number) && ("number" == typeof e[r] || e[r] instanceof Number) ? o[r] = t[r] + e[r] : o[r] = void 0 === e[r] ? t[r] : t[r] || e[r], r += 1;
                        return o
                    }
                    return 0
                }
                var add = sum;

                function sub(t, e) {
                    var n = typeof t,
                        i = typeof e;
                    if (isNumerable(n, t) && isNumerable(i, e)) return "string" === n && (t = parseInt(t)), "string" === i && (e = parseInt(e)), t - e;
                    if ($bm_isInstanceOfArray(t) && isNumerable(i, e)) return (t = t.slice(0))[0] = t[0] - e, t;
                    if (isNumerable(n, t) && $bm_isInstanceOfArray(e)) return (e = e.slice(0))[0] = t - e[0], e;
                    if ($bm_isInstanceOfArray(t) && $bm_isInstanceOfArray(e)) {
                        for (var r = 0, a = t.length, s = e.length, o = []; r < a || r < s;)("number" == typeof t[r] || t[r] instanceof Number) && ("number" == typeof e[r] || e[r] instanceof Number) ? o[r] = t[r] - e[r] : o[r] = void 0 === e[r] ? t[r] : t[r] || e[r], r += 1;
                        return o
                    }
                    return 0
                }

                function mul(t, e) {
                    var n, i, r, a = typeof t,
                        s = typeof e;
                    if (isNumerable(a, t) && isNumerable(s, e)) return t * e;
                    if ($bm_isInstanceOfArray(t) && isNumerable(s, e)) {
                        for (r = t.length, n = createTypedArray("float32", r), i = 0; i < r; i += 1) n[i] = t[i] * e;
                        return n
                    }
                    if (isNumerable(a, t) && $bm_isInstanceOfArray(e)) {
                        for (r = e.length, n = createTypedArray("float32", r), i = 0; i < r; i += 1) n[i] = t * e[i];
                        return n
                    }
                    return 0
                }

                function div(t, e) {
                    var n, i, r, a = typeof t,
                        s = typeof e;
                    if (isNumerable(a, t) && isNumerable(s, e)) return t / e;
                    if ($bm_isInstanceOfArray(t) && isNumerable(s, e)) {
                        for (r = t.length, n = createTypedArray("float32", r), i = 0; i < r; i += 1) n[i] = t[i] / e;
                        return n
                    }
                    if (isNumerable(a, t) && $bm_isInstanceOfArray(e)) {
                        for (r = e.length, n = createTypedArray("float32", r), i = 0; i < r; i += 1) n[i] = t / e[i];
                        return n
                    }
                    return 0
                }

                function mod(t, e) {
                    return "string" == typeof t && (t = parseInt(t)), "string" == typeof e && (e = parseInt(e)), t % e
                }
                var $bm_sum = sum,
                    $bm_sub = sub,
                    $bm_mul = mul,
                    $bm_div = div,
                    $bm_mod = mod;

                function clamp(t, e, n) {
                    if (e > n) {
                        var i = n;
                        n = e, e = i
                    }
                    return Math.min(Math.max(t, e), n)
                }

                function radiansToDegrees(t) {
                    return t / degToRads
                }
                var radians_to_degrees = radiansToDegrees;

                function degreesToRadians(t) {
                    return t * degToRads
                }
                var degrees_to_radians = radiansToDegrees,
                    helperLengthArray = [0, 0, 0, 0, 0, 0];

                function length(t, e) {
                    if ("number" == typeof t || t instanceof Number) return e = e || 0, Math.abs(t - e);
                    e || (e = helperLengthArray);
                    var n, i = Math.min(t.length, e.length),
                        r = 0;
                    for (n = 0; n < i; n += 1) r += Math.pow(e[n] - t[n], 2);
                    return Math.sqrt(r)
                }

                function normalize(t) {
                    return div(t, length(t))
                }

                function rgbToHsl(t) {
                    var e, n, i = t[0],
                        r = t[1],
                        a = t[2],
                        s = Math.max(i, r, a),
                        o = Math.min(i, r, a),
                        l = (s + o) / 2;
                    if (s == o) e = n = 0;
                    else {
                        var h = s - o;
                        switch (n = l > .5 ? h / (2 - s - o) : h / (s + o), s) {
                            case i:
                                e = (r - a) / h + (r < a ? 6 : 0);
                                break;
                            case r:
                                e = (a - i) / h + 2;
                                break;
                            case a:
                                e = (i - r) / h + 4
                        }
                        e /= 6
                    }
                    return [e, n, l, t[3]]
                }

                function hue2rgb(t, e, n) {
                    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
                }

                function hslToRgb(t) {
                    var e, n, i, r = t[0],
                        a = t[1],
                        s = t[2];
                    if (0 === a) e = n = i = s;
                    else {
                        var o = s < .5 ? s * (1 + a) : s + a - s * a,
                            l = 2 * s - o;
                        e = hue2rgb(l, o, r + 1 / 3), n = hue2rgb(l, o, r), i = hue2rgb(l, o, r - 1 / 3)
                    }
                    return [e, n, i, t[3]]
                }

                function linear(t, e, n, i, r) {
                    if (void 0 !== i && void 0 !== r || (i = e, r = n, e = 0, n = 1), n < e) {
                        var a = n;
                        n = e, e = a
                    }
                    if (t <= e) return i;
                    if (t >= n) return r;
                    var s = n === e ? 0 : (t - e) / (n - e);
                    if (!i.length) return i + (r - i) * s;
                    var o, l = i.length,
                        h = createTypedArray("float32", l);
                    for (o = 0; o < l; o += 1) h[o] = i[o] + (r[o] - i[o]) * s;
                    return h
                }

                function random(t, e) {
                    if (void 0 === e && (void 0 === t ? (t = 0, e = 1) : (e = t, t = void 0)), e.length) {
                        var n, i = e.length;
                        t || (t = createTypedArray("float32", i));
                        var r = createTypedArray("float32", i),
                            a = BMMath.random();
                        for (n = 0; n < i; n += 1) r[n] = t[n] + a * (e[n] - t[n]);
                        return r
                    }
                    return void 0 === t && (t = 0), t + BMMath.random() * (e - t)
                }

                function createPath(t, e, n, i) {
                    var r, a = t.length,
                        s = shape_pool.newElement();
                    s.setPathData(!!i, a);
                    var o, l, h = [0, 0];
                    for (r = 0; r < a; r += 1) o = e && e[r] ? e[r] : h, l = n && n[r] ? n[r] : h, s.setTripleAt(t[r][0], t[r][1], l[0] + t[r][0], l[1] + t[r][1], o[0] + t[r][0], o[1] + t[r][1], r, !0);
                    return s
                }

                function initiateExpression(elem, data, property) {
                    var val = data.x,
                        needsVelocity = /velocity(?![\w\d])/.test(val),
                        _needsRandom = -1 !== val.indexOf("random"),
                        elemType = elem.data.ty,
                        transform, $bm_transform, content, effect, thisProperty = property;
                    thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", {
                        get: function () {
                            return thisProperty.v
                        }
                    }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0;
                    var inPoint = elem.data.ip / elem.comp.globalData.frameRate,
                        outPoint = elem.data.op / elem.comp.globalData.frameRate,
                        width = elem.data.sw ? elem.data.sw : 0,
                        height = elem.data.sh ? elem.data.sh : 0,
                        name = elem.data.nm,
                        loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, __expression_functions = [],
                        scoped_bm_rt;
                    if (data.xf) {
                        var i, len = data.xf.length;
                        for (i = 0; i < len; i += 1) __expression_functions[i] = eval("(function(){ return " + data.xf[i] + "}())")
                    }
                    var expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0],
                        numKeys = property.kf ? data.k.length : 0,
                        active = !this.data || !0 !== this.data.hd,
                        wiggle = function (t, e) {
                            var n, i, r = this.pv.length ? this.pv.length : 1,
                                a = createTypedArray("float32", r);
                            var s = Math.floor(5 * time);
                            for (n = 0, i = 0; n < s;) {
                                for (i = 0; i < r; i += 1) a[i] += -e + 2 * e * BMMath.random();
                                n += 1
                            }
                            var o = 5 * time,
                                l = o - Math.floor(o),
                                h = createTypedArray("float32", r);
                            if (r > 1) {
                                for (i = 0; i < r; i += 1) h[i] = this.pv[i] + a[i] + (-e + 2 * e * BMMath.random()) * l;
                                return h
                            }
                            return this.pv + a[0] + (-e + 2 * e * BMMath.random()) * l
                        }.bind(this);

                    function loopInDuration(t, e) {
                        return loopIn(t, e, !0)
                    }

                    function loopOutDuration(t, e) {
                        return loopOut(t, e, !0)
                    }
                    thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty)), this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
                    var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface),
                        time, velocity, value, text, textIndex, textTotal, selectorValue;

                    function lookAt(t, e) {
                        var n = [e[0] - t[0], e[1] - t[1], e[2] - t[2]],
                            i = Math.atan2(n[0], Math.sqrt(n[1] * n[1] + n[2] * n[2])) / degToRads;
                        return [-Math.atan2(n[1], n[2]) / degToRads, i, 0]
                    }

                    function easeOut(t, e, n, i, r) {
                        return applyEase(easeOutBez, t, e, n, i, r)
                    }

                    function easeIn(t, e, n, i, r) {
                        return applyEase(easeInBez, t, e, n, i, r)
                    }

                    function ease(t, e, n, i, r) {
                        return applyEase(easeInOutBez, t, e, n, i, r)
                    }

                    function applyEase(t, e, n, i, r, a) {
                        void 0 === r ? (r = n, a = i) : e = (e - n) / (i - n);
                        var s = t(e = e > 1 ? 1 : e < 0 ? 0 : e);
                        if ($bm_isInstanceOfArray(r)) {
                            var o, l = r.length,
                                h = createTypedArray("float32", l);
                            for (o = 0; o < l; o += 1) h[o] = (a[o] - r[o]) * s + r[o];
                            return h
                        }
                        return (a - r) * s + r
                    }

                    function nearestKey(t) {
                        var e, n, i, r = data.k.length;
                        if (data.k.length && "number" != typeof data.k[0])
                            if (n = -1, (t *= elem.comp.globalData.frameRate) < data.k[0].t) n = 1, i = data.k[0].t;
                            else {
                                for (e = 0; e < r - 1; e += 1) {
                                    if (t === data.k[e].t) {
                                        n = e + 1, i = data.k[e].t;
                                        break
                                    }
                                    if (t > data.k[e].t && t < data.k[e + 1].t) {
                                        t - data.k[e].t > data.k[e + 1].t - t ? (n = e + 2, i = data.k[e + 1].t) : (n = e + 1, i = data.k[e].t);
                                        break
                                    }
                                } - 1 === n && (n = e + 1, i = data.k[e].t)
                            }
                        else n = 0, i = 0;
                        var a = {};
                        return a.index = n, a.time = i / elem.comp.globalData.frameRate, a
                    }

                    function key(t) {
                        var e, n, i;
                        if (!data.k.length || "number" == typeof data.k[0]) throw new Error("The property has no keyframe at index " + t);
                        t -= 1, e = {
                            time: data.k[t].t / elem.comp.globalData.frameRate,
                            value: []
                        };
                        var r = data.k[t].hasOwnProperty("s") ? data.k[t].s : data.k[t - 1].e;
                        for (i = r.length, n = 0; n < i; n += 1) e[n] = r[n], e.value[n] = r[n];
                        return e
                    }

                    function framesToTime(t, e) {
                        return e || (e = elem.comp.globalData.frameRate), t / e
                    }

                    function timeToFrames(t, e) {
                        return t || 0 === t || (t = time), e || (e = elem.comp.globalData.frameRate), t * e
                    }

                    function seedRandom(t) {
                        BMMath.seedrandom(randSeed + t)
                    }

                    function sourceRectAtTime() {
                        return elem.sourceRectAtTime()
                    }

                    function substring(t, e) {
                        return "string" == typeof value ? void 0 === e ? value.substring(t) : value.substring(t, e) : ""
                    }

                    function substr(t, e) {
                        return "string" == typeof value ? void 0 === e ? value.substr(t) : value.substr(t, e) : ""
                    }

                    function posterizeTime(t) {
                        time = 0 === t ? 0 : Math.floor(time * t) / t, value = valueAtTime(time)
                    }
                    var index = elem.data.ind,
                        hasParent = !(!elem.hierarchy || !elem.hierarchy.length),
                        parent, randSeed = Math.floor(1e6 * Math.random()),
                        globalData = elem.globalData;

                    function executeExpression(t) {
                        return value = t, _needsRandom && seedRandom(randSeed), this.frameExpressionId === elem.globalData.frameId && "textSelector" !== this.propType ? value : ("textSelector" === this.propType && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), 4 !== elemType || content || (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), (hasParent = !(!elem.hierarchy || !elem.hierarchy.length)) && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, "shape" === scoped_bm_rt.propType && (scoped_bm_rt = scoped_bm_rt.v), scoped_bm_rt)
                    }
                    return executeExpression
                }
                return ob.initiateExpression = initiateExpression, ob
            }(),
            expressionHelpers = {
                searchExpressions: function (t, e, n) {
                    e.x && (n.k = !0, n.x = !0, n.initiateExpression = ExpressionManager.initiateExpression, n.effectsSequence.push(n.initiateExpression(t, e, n).bind(n)))
                },
                getSpeedAtTime: function (t) {
                    var e = this.getValueAtTime(t),
                        n = this.getValueAtTime(t + -.01),
                        i = 0;
                    if (e.length) {
                        var r;
                        for (r = 0; r < e.length; r += 1) i += Math.pow(n[r] - e[r], 2);
                        i = 100 * Math.sqrt(i)
                    } else i = 0;
                    return i
                },
                getVelocityAtTime: function (t) {
                    if (void 0 !== this.vel) return this.vel;
                    var e, n, i = this.getValueAtTime(t),
                        r = this.getValueAtTime(t + -.001);
                    if (i.length)
                        for (e = createTypedArray("float32", i.length), n = 0; n < i.length; n += 1) e[n] = (r[n] - i[n]) / -.001;
                    else e = (r - i) / -.001;
                    return e
                },
                getValueAtTime: function (t) {
                    return t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < t ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(t, this._cachingAtTime), this._cachingAtTime.lastFrame = t), this._cachingAtTime.value
                },
                getStaticValueAtTime: function () {
                    return this.pv
                },
                setGroupProperty: function (t) {
                    this.propertyGroup = t
                }
            };
        ! function () {
            function t(t, e, n) {
                if (!this.k || !this.keyframes) return this.pv;
                t = t ? t.toLowerCase() : "";
                var i, r, a, s, o, l = this.comp.renderedFrame,
                    h = this.keyframes,
                    u = h[h.length - 1].t;
                if (l <= u) return this.pv;
                if (n ? r = u - (i = e ? Math.abs(u - elem.comp.globalData.frameRate * e) : Math.max(0, u - this.elem.data.ip)) : ((!e || e > h.length - 1) && (e = h.length - 1), i = u - (r = h[h.length - 1 - e].t)), "pingpong" === t) {
                    if (Math.floor((l - r) / i) % 2 != 0) return this.getValueAtTime((i - (l - r) % i + r) / this.comp.globalData.frameRate, 0)
                } else {
                    if ("offset" === t) {
                        var c = this.getValueAtTime(r / this.comp.globalData.frameRate, 0),
                            p = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                            f = this.getValueAtTime(((l - r) % i + r) / this.comp.globalData.frameRate, 0),
                            d = Math.floor((l - r) / i);
                        if (this.pv.length) {
                            for (s = (o = new Array(c.length)).length, a = 0; a < s; a += 1) o[a] = (p[a] - c[a]) * d + f[a];
                            return o
                        }
                        return (p - c) * d + f
                    }
                    if ("continue" === t) {
                        var m = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                            g = this.getValueAtTime((u - .001) / this.comp.globalData.frameRate, 0);
                        if (this.pv.length) {
                            for (s = (o = new Array(m.length)).length, a = 0; a < s; a += 1) o[a] = m[a] + (m[a] - g[a]) * ((l - u) / this.comp.globalData.frameRate) / 5e-4;
                            return o
                        }
                        return m + (l - u) / .001 * (m - g)
                    }
                }
                return this.getValueAtTime(((l - r) % i + r) / this.comp.globalData.frameRate, 0)
            }

            function e(t, e, n) {
                if (!this.k) return this.pv;
                t = t ? t.toLowerCase() : "";
                var i, r, a, s, o, l = this.comp.renderedFrame,
                    h = this.keyframes,
                    u = h[0].t;
                if (l >= u) return this.pv;
                if (n ? r = u + (i = e ? Math.abs(elem.comp.globalData.frameRate * e) : Math.max(0, this.elem.data.op - u)) : ((!e || e > h.length - 1) && (e = h.length - 1), i = (r = h[e].t) - u), "pingpong" === t) {
                    if (Math.floor((u - l) / i) % 2 == 0) return this.getValueAtTime(((u - l) % i + u) / this.comp.globalData.frameRate, 0)
                } else {
                    if ("offset" === t) {
                        var c = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                            p = this.getValueAtTime(r / this.comp.globalData.frameRate, 0),
                            f = this.getValueAtTime((i - (u - l) % i + u) / this.comp.globalData.frameRate, 0),
                            d = Math.floor((u - l) / i) + 1;
                        if (this.pv.length) {
                            for (s = (o = new Array(c.length)).length, a = 0; a < s; a += 1) o[a] = f[a] - (p[a] - c[a]) * d;
                            return o
                        }
                        return f - (p - c) * d
                    }
                    if ("continue" === t) {
                        var m = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                            g = this.getValueAtTime((u + .001) / this.comp.globalData.frameRate, 0);
                        if (this.pv.length) {
                            for (s = (o = new Array(m.length)).length, a = 0; a < s; a += 1) o[a] = m[a] + (m[a] - g[a]) * (u - l) / .001;
                            return o
                        }
                        return m + (m - g) * (u - l) / .001
                    }
                }
                return this.getValueAtTime((i - (u - l) % i + u) / this.comp.globalData.frameRate, 0)
            }

            function n(t, e) {
                if (!this.k) return this.pv;
                if (t = .5 * (t || .4), (e = Math.floor(e || 5)) <= 1) return this.pv;
                var n, i, r = this.comp.renderedFrame / this.comp.globalData.frameRate,
                    a = r - t,
                    s = e > 1 ? (r + t - a) / (e - 1) : 1,
                    o = 0,
                    l = 0;
                for (n = this.pv.length ? createTypedArray("float32", this.pv.length) : 0; o < e;) {
                    if (i = this.getValueAtTime(a + o * s), this.pv.length)
                        for (l = 0; l < this.pv.length; l += 1) n[l] += i[l];
                    else n += i;
                    o += 1
                }
                if (this.pv.length)
                    for (l = 0; l < this.pv.length; l += 1) n[l] /= e;
                else n /= e;
                return n
            }

            function i(t) {
                console.warn("Transform at time not supported")
            }

            function r(t) {}
            var a = TransformPropertyFactory.getTransformProperty;
            TransformPropertyFactory.getTransformProperty = function (t, e, n) {
                var s = a(t, e, n);
                return s.dynamicProperties.length ? s.getValueAtTime = i.bind(s) : s.getValueAtTime = r.bind(s), s.setGroupProperty = expressionHelpers.setGroupProperty, s
            };
            var s = PropertyFactory.getProp;
            PropertyFactory.getProp = function (i, r, a, o, l) {
                var h = s(i, r, a, o, l);
                h.kf ? h.getValueAtTime = expressionHelpers.getValueAtTime.bind(h) : h.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(h), h.setGroupProperty = expressionHelpers.setGroupProperty, h.loopOut = t, h.loopIn = e, h.smooth = n, h.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(h), h.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(h), h.numKeys = 1 === r.a ? r.k.length : 0, h.propertyIndex = r.ix;
                var u = 0;
                return 0 !== a && (u = createTypedArray("float32", 1 === r.a ? r.k[0].s.length : r.k.length)), h._cachingAtTime = {
                    lastFrame: initialDefaultFrame,
                    lastIndex: 0,
                    value: u
                }, expressionHelpers.searchExpressions(i, r, h), h.k && l.addDynamicProperty(h), h
            };
            var o = ShapePropertyFactory.getConstructorFunction(),
                l = ShapePropertyFactory.getKeyframedConstructorFunction();

            function h() {}
            h.prototype = {
                vertices: function (t, e) {
                    this.k && this.getValue();
                    var n = this.v;
                    void 0 !== e && (n = this.getValueAtTime(e, 0));
                    var i, r = n._length,
                        a = n[t],
                        s = n.v,
                        o = createSizedArray(r);
                    for (i = 0; i < r; i += 1) o[i] = "i" === t || "o" === t ? [a[i][0] - s[i][0], a[i][1] - s[i][1]] : [a[i][0], a[i][1]];
                    return o
                },
                points: function (t) {
                    return this.vertices("v", t)
                },
                inTangents: function (t) {
                    return this.vertices("i", t)
                },
                outTangents: function (t) {
                    return this.vertices("o", t)
                },
                isClosed: function () {
                    return this.v.c
                },
                pointOnPath: function (t, e) {
                    var n = this.v;
                    void 0 !== e && (n = this.getValueAtTime(e, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(n));
                    for (var i, r = this._segmentsLength, a = r.lengths, s = r.totalLength * t, o = 0, l = a.length, h = 0; o < l;) {
                        if (h + a[o].addedLength > s) {
                            var u = o,
                                c = n.c && o === l - 1 ? 0 : o + 1,
                                p = (s - h) / a[o].addedLength;
                            i = bez.getPointInSegment(n.v[u], n.v[c], n.o[u], n.i[c], p, a[o]);
                            break
                        }
                        h += a[o].addedLength, o += 1
                    }
                    return i || (i = n.c ? [n.v[0][0], n.v[0][1]] : [n.v[n._length - 1][0], n.v[n._length - 1][1]]), i
                },
                vectorOnPath: function (t, e, n) {
                    t = 1 == t ? this.v.c ? 0 : .999 : t;
                    var i = this.pointOnPath(t, e),
                        r = this.pointOnPath(t + .001, e),
                        a = r[0] - i[0],
                        s = r[1] - i[1],
                        o = Math.sqrt(Math.pow(a, 2) + Math.pow(s, 2));
                    return 0 === o ? [0, 0] : "tangent" === n ? [a / o, s / o] : [-s / o, a / o]
                },
                tangentOnPath: function (t, e) {
                    return this.vectorOnPath(t, e, "tangent")
                },
                normalOnPath: function (t, e) {
                    return this.vectorOnPath(t, e, "normal")
                },
                setGroupProperty: expressionHelpers.setGroupProperty,
                getValueAtTime: expressionHelpers.getStaticValueAtTime
            }, extendPrototype([h], o), extendPrototype([h], l), l.prototype.getValueAtTime = function (t) {
                return this._cachingAtTime || (this._cachingAtTime = {
                    shapeValue: shape_pool.clone(this.pv),
                    lastIndex: 0,
                    lastTime: initialDefaultFrame
                }), t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < t ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = t, this.interpolateShape(t, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue
            }, l.prototype.initiateExpression = ExpressionManager.initiateExpression;
            var u = ShapePropertyFactory.getShapeProp;
            ShapePropertyFactory.getShapeProp = function (t, e, n, i, r) {
                var a = u(t, e, n, i, r);
                return a.propertyIndex = e.ix, a.lock = !1, 3 === n ? expressionHelpers.searchExpressions(t, e.pt, a) : 4 === n && expressionHelpers.searchExpressions(t, e.ks, a), a.k && t.addDynamicProperty(a), a
            }
        }(), TextProperty.prototype.getExpressionValue = function (t, e) {
            var n = this.calculateExpression(e);
            if (t.t !== n) {
                var i = {};
                return this.copyData(i, t), i.t = n.toString(), i.__complete = !1, i
            }
            return t
        }, TextProperty.prototype.searchProperty = function () {
            var t = this.searchKeyframes(),
                e = this.searchExpressions();
            return this.kf = t || e, this.kf
        }, TextProperty.prototype.searchExpressions = function () {
            if (this.data.d.x) return this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0
        };
        var ShapeExpressionInterface = function () {
                function t(t, c, p) {
                    var f, d = [],
                        m = t ? t.length : 0;
                    for (f = 0; f < m; f += 1) "gr" == t[f].ty ? d.push(e(t[f], c[f], p)) : "fl" == t[f].ty ? d.push(n(t[f], c[f], p)) : "st" == t[f].ty ? d.push(i(t[f], c[f], p)) : "tm" == t[f].ty ? d.push(r(t[f], c[f], p)) : "tr" == t[f].ty || ("el" == t[f].ty ? d.push(a(t[f], c[f], p)) : "sr" == t[f].ty ? d.push(s(t[f], c[f], p)) : "sh" == t[f].ty ? d.push(u(t[f], c[f], p)) : "rc" == t[f].ty ? d.push(o(t[f], c[f], p)) : "rd" == t[f].ty ? d.push(l(t[f], c[f], p)) : "rp" == t[f].ty && d.push(h(t[f], c[f], p)));
                    return d
                }

                function e(e, n, i) {
                    var r = function (t) {
                        switch (t) {
                            case "ADBE Vectors Group":
                            case "Contents":
                            case 2:
                                return r.content;
                            default:
                                return r.transform
                        }
                    };
                    r.propertyGroup = function (t) {
                        return 1 === t ? r : i(t - 1)
                    };
                    var a = function (e, n, i) {
                            var r, a = function (t) {
                                for (var e = 0, n = r.length; e < n;) {
                                    if (r[e]._name === t || r[e].mn === t || r[e].propertyIndex === t || r[e].ix === t || r[e].ind === t) return r[e];
                                    e += 1
                                }
                                if ("number" == typeof t) return r[t - 1]
                            };
                            return a.propertyGroup = function (t) {
                                return 1 === t ? a : i(t - 1)
                            }, r = t(e.it, n.it, a.propertyGroup), a.numProperties = r.length, a.propertyIndex = e.cix, a._name = e.nm, a
                        }(e, n, r.propertyGroup),
                        s = function (t, e, n) {
                            function i(t) {
                                return 1 == t ? r : n(--t)
                            }
                            e.transform.mProps.o.setGroupProperty(i), e.transform.mProps.p.setGroupProperty(i), e.transform.mProps.a.setGroupProperty(i), e.transform.mProps.s.setGroupProperty(i), e.transform.mProps.r.setGroupProperty(i), e.transform.mProps.sk && (e.transform.mProps.sk.setGroupProperty(i), e.transform.mProps.sa.setGroupProperty(i));

                            function r(e) {
                                return t.a.ix === e || "Anchor Point" === e ? r.anchorPoint : t.o.ix === e || "Opacity" === e ? r.opacity : t.p.ix === e || "Position" === e ? r.position : t.r.ix === e || "Rotation" === e || "ADBE Vector Rotation" === e ? r.rotation : t.s.ix === e || "Scale" === e ? r.scale : t.sk && t.sk.ix === e || "Skew" === e ? r.skew : t.sa && t.sa.ix === e || "Skew Axis" === e ? r.skewAxis : void 0
                            }
                            return e.transform.op.setGroupProperty(i), Object.defineProperties(r, {
                                opacity: {
                                    get: ExpressionPropertyInterface(e.transform.mProps.o)
                                },
                                position: {
                                    get: ExpressionPropertyInterface(e.transform.mProps.p)
                                },
                                anchorPoint: {
                                    get: ExpressionPropertyInterface(e.transform.mProps.a)
                                },
                                scale: {
                                    get: ExpressionPropertyInterface(e.transform.mProps.s)
                                },
                                rotation: {
                                    get: ExpressionPropertyInterface(e.transform.mProps.r)
                                },
                                skew: {
                                    get: ExpressionPropertyInterface(e.transform.mProps.sk)
                                },
                                skewAxis: {
                                    get: ExpressionPropertyInterface(e.transform.mProps.sa)
                                },
                                _name: {
                                    value: t.nm
                                }
                            }), r.ty = "tr", r.mn = t.mn, r.propertyGroup = n, r
                        }(e.it[e.it.length - 1], n.it[n.it.length - 1], r.propertyGroup);
                    return r.content = a, r.transform = s, Object.defineProperty(r, "_name", {
                        get: function () {
                            return e.nm
                        }
                    }), r.numProperties = e.np, r.propertyIndex = e.ix, r.nm = e.nm, r.mn = e.mn, r
                }

                function n(t, e, n) {
                    function i(t) {
                        return "Color" === t || "color" === t ? i.color : "Opacity" === t || "opacity" === t ? i.opacity : void 0
                    }
                    return Object.defineProperties(i, {
                        color: {
                            get: ExpressionPropertyInterface(e.c)
                        },
                        opacity: {
                            get: ExpressionPropertyInterface(e.o)
                        },
                        _name: {
                            value: t.nm
                        },
                        mn: {
                            value: t.mn
                        }
                    }), e.c.setGroupProperty(n), e.o.setGroupProperty(n), i
                }

                function i(t, e, n) {
                    function i(t) {
                        return 1 === t ? ob : n(t - 1)
                    }

                    function r(t) {
                        return 1 === t ? l : i(t - 1)
                    }

                    function a(n) {
                        Object.defineProperty(l, t.d[n].nm, {
                            get: ExpressionPropertyInterface(e.d.dataProps[n].p)
                        })
                    }
                    var s, o = t.d ? t.d.length : 0,
                        l = {};
                    for (s = 0; s < o; s += 1) a(s), e.d.dataProps[s].p.setGroupProperty(r);

                    function h(t) {
                        return "Color" === t || "color" === t ? h.color : "Opacity" === t || "opacity" === t ? h.opacity : "Stroke Width" === t || "stroke width" === t ? h.strokeWidth : void 0
                    }
                    return Object.defineProperties(h, {
                        color: {
                            get: ExpressionPropertyInterface(e.c)
                        },
                        opacity: {
                            get: ExpressionPropertyInterface(e.o)
                        },
                        strokeWidth: {
                            get: ExpressionPropertyInterface(e.w)
                        },
                        dash: {
                            get: function () {
                                return l
                            }
                        },
                        _name: {
                            value: t.nm
                        },
                        mn: {
                            value: t.mn
                        }
                    }), e.c.setGroupProperty(i), e.o.setGroupProperty(i), e.w.setGroupProperty(i), h
                }

                function r(t, e, n) {
                    function i(t) {
                        return 1 == t ? r : n(--t)
                    }

                    function r(e) {
                        return e === t.e.ix || "End" === e || "end" === e ? r.end : e === t.s.ix ? r.start : e === t.o.ix ? r.offset : void 0
                    }
                    return r.propertyIndex = t.ix, e.s.setGroupProperty(i), e.e.setGroupProperty(i), e.o.setGroupProperty(i), r.propertyIndex = t.ix, r.propertyGroup = n, Object.defineProperties(r, {
                        start: {
                            get: ExpressionPropertyInterface(e.s)
                        },
                        end: {
                            get: ExpressionPropertyInterface(e.e)
                        },
                        offset: {
                            get: ExpressionPropertyInterface(e.o)
                        },
                        _name: {
                            value: t.nm
                        }
                    }), r.mn = t.mn, r
                }

                function a(t, e, n) {
                    function i(t) {
                        return 1 == t ? a : n(--t)
                    }
                    a.propertyIndex = t.ix;
                    var r = "tm" === e.sh.ty ? e.sh.prop : e.sh;

                    function a(e) {
                        return t.p.ix === e ? a.position : t.s.ix === e ? a.size : void 0
                    }
                    return r.s.setGroupProperty(i), r.p.setGroupProperty(i), Object.defineProperties(a, {
                        size: {
                            get: ExpressionPropertyInterface(r.s)
                        },
                        position: {
                            get: ExpressionPropertyInterface(r.p)
                        },
                        _name: {
                            value: t.nm
                        }
                    }), a.mn = t.mn, a
                }

                function s(t, e, n) {
                    function i(t) {
                        return 1 == t ? a : n(--t)
                    }
                    var r = "tm" === e.sh.ty ? e.sh.prop : e.sh;

                    function a(e) {
                        return t.p.ix === e ? a.position : t.r.ix === e ? a.rotation : t.pt.ix === e ? a.points : t.or.ix === e || "ADBE Vector Star Outer Radius" === e ? a.outerRadius : t.os.ix === e ? a.outerRoundness : !t.ir || t.ir.ix !== e && "ADBE Vector Star Inner Radius" !== e ? t.is && t.is.ix === e ? a.innerRoundness : void 0 : a.innerRadius
                    }
                    return a.propertyIndex = t.ix, r.or.setGroupProperty(i), r.os.setGroupProperty(i), r.pt.setGroupProperty(i), r.p.setGroupProperty(i), r.r.setGroupProperty(i), t.ir && (r.ir.setGroupProperty(i), r.is.setGroupProperty(i)), Object.defineProperties(a, {
                        position: {
                            get: ExpressionPropertyInterface(r.p)
                        },
                        rotation: {
                            get: ExpressionPropertyInterface(r.r)
                        },
                        points: {
                            get: ExpressionPropertyInterface(r.pt)
                        },
                        outerRadius: {
                            get: ExpressionPropertyInterface(r.or)
                        },
                        outerRoundness: {
                            get: ExpressionPropertyInterface(r.os)
                        },
                        innerRadius: {
                            get: ExpressionPropertyInterface(r.ir)
                        },
                        innerRoundness: {
                            get: ExpressionPropertyInterface(r.is)
                        },
                        _name: {
                            value: t.nm
                        }
                    }), a.mn = t.mn, a
                }

                function o(t, e, n) {
                    function i(t) {
                        return 1 == t ? a : n(--t)
                    }
                    var r = "tm" === e.sh.ty ? e.sh.prop : e.sh;

                    function a(e) {
                        return t.p.ix === e ? a.position : t.r.ix === e ? a.roundness : t.s.ix === e || "Size" === e || "ADBE Vector Rect Size" === e ? a.size : void 0
                    }
                    return a.propertyIndex = t.ix, r.p.setGroupProperty(i), r.s.setGroupProperty(i), r.r.setGroupProperty(i), Object.defineProperties(a, {
                        position: {
                            get: ExpressionPropertyInterface(r.p)
                        },
                        roundness: {
                            get: ExpressionPropertyInterface(r.r)
                        },
                        size: {
                            get: ExpressionPropertyInterface(r.s)
                        },
                        _name: {
                            value: t.nm
                        }
                    }), a.mn = t.mn, a
                }

                function l(t, e, n) {
                    var i = e;

                    function r(e) {
                        if (t.r.ix === e || "Round Corners 1" === e) return r.radius
                    }
                    return r.propertyIndex = t.ix, i.rd.setGroupProperty((function (t) {
                        return 1 == t ? r : n(--t)
                    })), Object.defineProperties(r, {
                        radius: {
                            get: ExpressionPropertyInterface(i.rd)
                        },
                        _name: {
                            value: t.nm
                        }
                    }), r.mn = t.mn, r
                }

                function h(t, e, n) {
                    function i(t) {
                        return 1 == t ? a : n(--t)
                    }
                    var r = e;

                    function a(e) {
                        return t.c.ix === e || "Copies" === e ? a.copies : t.o.ix === e || "Offset" === e ? a.offset : void 0
                    }
                    return a.propertyIndex = t.ix, r.c.setGroupProperty(i), r.o.setGroupProperty(i), Object.defineProperties(a, {
                        copies: {
                            get: ExpressionPropertyInterface(r.c)
                        },
                        offset: {
                            get: ExpressionPropertyInterface(r.o)
                        },
                        _name: {
                            value: t.nm
                        }
                    }), a.mn = t.mn, a
                }

                function u(t, e, n) {
                    var i = e.sh;

                    function r(t) {
                        if ("Shape" === t || "shape" === t || "Path" === t || "path" === t || "ADBE Vector Shape" === t || 2 === t) return r.path
                    }
                    return i.setGroupProperty((function (t) {
                        return 1 == t ? r : n(--t)
                    })), Object.defineProperties(r, {
                        path: {
                            get: function () {
                                return i.k && i.getValue(), i
                            }
                        },
                        shape: {
                            get: function () {
                                return i.k && i.getValue(), i
                            }
                        },
                        _name: {
                            value: t.nm
                        },
                        ix: {
                            value: t.ix
                        },
                        propertyIndex: {
                            value: t.ix
                        },
                        mn: {
                            value: t.mn
                        }
                    }), r
                }
                return function (e, n, i) {
                    var r;

                    function a(t) {
                        if ("number" == typeof t) return r[t - 1];
                        for (var e = 0, n = r.length; e < n;) {
                            if (r[e]._name === t) return r[e];
                            e += 1
                        }
                    }
                    return a.propertyGroup = i, r = t(e, n, a), a.numProperties = r.length, a
                }
            }(),
            TextExpressionInterface = function (t) {
                var e;

                function n() {}
                return Object.defineProperty(n, "sourceText", {
                    get: function () {
                        t.textProperty.getValue();
                        var n = t.textProperty.currentData.t;
                        return void 0 !== n && (t.textProperty.currentData.t = void 0, (e = new String(n)).value = n || new String(n)), e
                    }
                }), n
            },
            LayerExpressionInterface = function () {
                function t(t, e) {
                    var n = new Matrix;
                    if (n.reset(), this._elem.finalTransform.mProp.applyToMatrix(n), this._elem.hierarchy && this._elem.hierarchy.length) {
                        var i, r = this._elem.hierarchy.length;
                        for (i = 0; i < r; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(n);
                        return n.applyToPointArray(t[0], t[1], t[2] || 0)
                    }
                    return n.applyToPointArray(t[0], t[1], t[2] || 0)
                }

                function e(t, e) {
                    var n = new Matrix;
                    if (n.reset(), this._elem.finalTransform.mProp.applyToMatrix(n), this._elem.hierarchy && this._elem.hierarchy.length) {
                        var i, r = this._elem.hierarchy.length;
                        for (i = 0; i < r; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(n);
                        return n.inversePoint(t)
                    }
                    return n.inversePoint(t)
                }

                function n(t) {
                    var e = new Matrix;
                    if (e.reset(), this._elem.finalTransform.mProp.applyToMatrix(e), this._elem.hierarchy && this._elem.hierarchy.length) {
                        var n, i = this._elem.hierarchy.length;
                        for (n = 0; n < i; n += 1) this._elem.hierarchy[n].finalTransform.mProp.applyToMatrix(e);
                        return e.inversePoint(t)
                    }
                    return e.inversePoint(t)
                }

                function i() {
                    return [1, 1, 1, 1]
                }
                return function (r) {
                    var a;

                    function s(t) {
                        switch (t) {
                            case "ADBE Root Vectors Group":
                            case "Contents":
                            case 2:
                                return s.shapeInterface;
                            case 1:
                            case 6:
                            case "Transform":
                            case "transform":
                            case "ADBE Transform Group":
                                return a;
                            case 4:
                            case "ADBE Effect Parade":
                            case "effects":
                            case "Effects":
                                return s.effect
                        }
                    }
                    s.toWorld = t, s.fromWorld = e, s.toComp = t, s.fromComp = n, s.sampleImage = i, s.sourceRectAtTime = r.sourceRectAtTime.bind(r), s._elem = r;
                    var o = getDescriptor(a = TransformExpressionInterface(r.finalTransform.mProp), "anchorPoint");
                    return Object.defineProperties(s, {
                        hasParent: {
                            get: function () {
                                return r.hierarchy.length
                            }
                        },
                        parent: {
                            get: function () {
                                return r.hierarchy[0].layerInterface
                            }
                        },
                        rotation: getDescriptor(a, "rotation"),
                        scale: getDescriptor(a, "scale"),
                        position: getDescriptor(a, "position"),
                        opacity: getDescriptor(a, "opacity"),
                        anchorPoint: o,
                        anchor_point: o,
                        transform: {
                            get: function () {
                                return a
                            }
                        },
                        active: {
                            get: function () {
                                return r.isInRange
                            }
                        }
                    }), s.startTime = r.data.st, s.index = r.data.ind, s.source = r.data.refId, s.height = 0 === r.data.ty ? r.data.h : 100, s.width = 0 === r.data.ty ? r.data.w : 100, s.inPoint = r.data.ip / r.comp.globalData.frameRate, s.outPoint = r.data.op / r.comp.globalData.frameRate, s._name = r.data.nm, s.registerMaskInterface = function (t) {
                        s.mask = new MaskManagerInterface(t, r)
                    }, s.registerEffectsInterface = function (t) {
                        s.effect = t
                    }, s
                }
            }(),
            CompExpressionInterface = function (t) {
                function e(e) {
                    for (var n = 0, i = t.layers.length; n < i;) {
                        if (t.layers[n].nm === e || t.layers[n].ind === e) return t.elements[n].layerInterface;
                        n += 1
                    }
                    return null
                }
                return Object.defineProperty(e, "_name", {
                    value: t.data.nm
                }), e.layer = e, e.pixelAspect = 1, e.height = t.data.h || t.globalData.compSize.h, e.width = t.data.w || t.globalData.compSize.w, e.pixelAspect = 1, e.frameDuration = 1 / t.globalData.frameRate, e.displayStartTime = 0, e.numLayers = t.layers.length, e
            },
            TransformExpressionInterface = function (t) {
                function e(t) {
                    switch (t) {
                        case "scale":
                        case "Scale":
                        case "ADBE Scale":
                        case 6:
                            return e.scale;
                        case "rotation":
                        case "Rotation":
                        case "ADBE Rotation":
                        case "ADBE Rotate Z":
                        case 10:
                            return e.rotation;
                        case "ADBE Rotate X":
                            return e.xRotation;
                        case "ADBE Rotate Y":
                            return e.yRotation;
                        case "position":
                        case "Position":
                        case "ADBE Position":
                        case 2:
                            return e.position;
                        case "ADBE Position_0":
                            return e.xPosition;
                        case "ADBE Position_1":
                            return e.yPosition;
                        case "ADBE Position_2":
                            return e.zPosition;
                        case "anchorPoint":
                        case "AnchorPoint":
                        case "Anchor Point":
                        case "ADBE AnchorPoint":
                        case 1:
                            return e.anchorPoint;
                        case "opacity":
                        case "Opacity":
                        case 11:
                            return e.opacity
                    }
                }
                if (Object.defineProperty(e, "rotation", {
                        get: ExpressionPropertyInterface(t.r || t.rz)
                    }), Object.defineProperty(e, "zRotation", {
                        get: ExpressionPropertyInterface(t.rz || t.r)
                    }), Object.defineProperty(e, "xRotation", {
                        get: ExpressionPropertyInterface(t.rx)
                    }), Object.defineProperty(e, "yRotation", {
                        get: ExpressionPropertyInterface(t.ry)
                    }), Object.defineProperty(e, "scale", {
                        get: ExpressionPropertyInterface(t.s)
                    }), t.p) var n = ExpressionPropertyInterface(t.p);
                return Object.defineProperty(e, "position", {
                    get: function () {
                        return t.p ? n() : [t.px.v, t.py.v, t.pz ? t.pz.v : 0]
                    }
                }), Object.defineProperty(e, "xPosition", {
                    get: ExpressionPropertyInterface(t.px)
                }), Object.defineProperty(e, "yPosition", {
                    get: ExpressionPropertyInterface(t.py)
                }), Object.defineProperty(e, "zPosition", {
                    get: ExpressionPropertyInterface(t.pz)
                }), Object.defineProperty(e, "anchorPoint", {
                    get: ExpressionPropertyInterface(t.a)
                }), Object.defineProperty(e, "opacity", {
                    get: ExpressionPropertyInterface(t.o)
                }), Object.defineProperty(e, "skew", {
                    get: ExpressionPropertyInterface(t.sk)
                }), Object.defineProperty(e, "skewAxis", {
                    get: ExpressionPropertyInterface(t.sa)
                }), Object.defineProperty(e, "orientation", {
                    get: ExpressionPropertyInterface(t.or)
                }), e
            },
            ProjectInterface = function () {
                function t(t) {
                    this.compositions.push(t)
                }
                return function () {
                    function e(t) {
                        for (var e = 0, n = this.compositions.length; e < n;) {
                            if (this.compositions[e].data && this.compositions[e].data.nm === t) return this.compositions[e].prepareFrame && this.compositions[e].data.xt && this.compositions[e].prepareFrame(this.currentFrame), this.compositions[e].compInterface;
                            e += 1
                        }
                    }
                    return e.compositions = [], e.currentFrame = 0, e.registerComposition = t, e
                }
            }(),
            EffectsExpressionInterface = function () {
                function t(n, i, r, a) {
                    var s, o = [],
                        l = n.ef.length;
                    for (s = 0; s < l; s += 1) 5 === n.ef[s].ty ? o.push(t(n.ef[s], i.effectElements[s], i.effectElements[s].propertyGroup, a)) : o.push(e(i.effectElements[s], n.ef[s].ty, a, h));

                    function h(t) {
                        return 1 === t ? u : r(t - 1)
                    }
                    var u = function (t) {
                        for (var e = n.ef, i = 0, r = e.length; i < r;) {
                            if (t === e[i].nm || t === e[i].mn || t === e[i].ix) return 5 === e[i].ty ? o[i] : o[i]();
                            i += 1
                        }
                        return o[0]()
                    };
                    return u.propertyGroup = h, "ADBE Color Control" === n.mn && Object.defineProperty(u, "color", {
                        get: function () {
                            return o[0]()
                        }
                    }), Object.defineProperty(u, "numProperties", {
                        get: function () {
                            return n.np
                        }
                    }), u.active = u.enabled = 0 !== n.en, u
                }

                function e(t, e, n, i) {
                    var r = ExpressionPropertyInterface(t.p);
                    return t.p.setGroupProperty && t.p.setGroupProperty(i),
                        function () {
                            return 10 === e ? n.comp.compInterface(t.p.v) : r()
                        }
                }
                return {
                    createEffectsInterface: function (e, n) {
                        if (e.effectsManager) {
                            var i, r = [],
                                a = e.data.ef,
                                s = e.effectsManager.effectElements.length;
                            for (i = 0; i < s; i += 1) r.push(t(a[i], e.effectsManager.effectElements[i], n, e));
                            return function (t) {
                                for (var n = e.data.ef || [], i = 0, a = n.length; i < a;) {
                                    if (t === n[i].nm || t === n[i].mn || t === n[i].ix) return r[i];
                                    i += 1
                                }
                            }
                        }
                    }
                }
            }(),
            MaskManagerInterface = function () {
                function t(t, e) {
                    this._mask = t, this._data = e
                }
                Object.defineProperty(t.prototype, "maskPath", {
                    get: function () {
                        return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop
                    }
                }), Object.defineProperty(t.prototype, "maskOpacity", {
                    get: function () {
                        return this._mask.op.k && this._mask.op.getValue(), 100 * this._mask.op.v
                    }
                });
                return function (e, n) {
                    var i, r = createSizedArray(e.viewData.length),
                        a = e.viewData.length;
                    for (i = 0; i < a; i += 1) r[i] = new t(e.viewData[i], e.masksProperties[i]);
                    return function (t) {
                        for (i = 0; i < a;) {
                            if (e.masksProperties[i].nm === t) return r[i];
                            i += 1
                        }
                    }
                }
            }(),
            ExpressionPropertyInterface = function () {
                var t = {
                        pv: 0,
                        v: 0,
                        mult: 1
                    },
                    e = {
                        pv: [0, 0, 0],
                        v: [0, 0, 0],
                        mult: 1
                    };

                function n(t, e, n) {
                    Object.defineProperty(t, "velocity", {
                        get: function () {
                            return e.getVelocityAtTime(e.comp.currentFrame)
                        }
                    }), t.numKeys = e.keyframes ? e.keyframes.length : 0, t.key = function (i) {
                        if (t.numKeys) {
                            var r = "";
                            r = "s" in e.keyframes[i - 1] ? e.keyframes[i - 1].s : "e" in e.keyframes[i - 2] ? e.keyframes[i - 2].e : e.keyframes[i - 2].s;
                            var a = "unidimensional" === n ? new Number(r) : Object.assign({}, r);
                            return a.time = e.keyframes[i - 1].t / e.elem.comp.globalData.frameRate, a
                        }
                        return 0
                    }, t.valueAtTime = e.getValueAtTime, t.speedAtTime = e.getSpeedAtTime, t.velocityAtTime = e.getVelocityAtTime, t.propertyGroup = e.propertyGroup
                }

                function i() {
                    return t
                }
                return function (r) {
                    return r ? "unidimensional" === r.propType ? function (e) {
                        e && "pv" in e || (e = t);
                        var i = 1 / e.mult,
                            r = e.pv * i,
                            a = new Number(r);
                        return a.value = r, n(a, e, "unidimensional"),
                            function () {
                                return e.k && e.getValue(), r = e.v * i, a.value !== r && ((a = new Number(r)).value = r, n(a, e, "unidimensional")), a
                            }
                    }(r) : function (t) {
                        t && "pv" in t || (t = e);
                        var i = 1 / t.mult,
                            r = t.pv.length,
                            a = createTypedArray("float32", r),
                            s = createTypedArray("float32", r);
                        return a.value = s, n(a, t, "multidimensional"),
                            function () {
                                t.k && t.getValue();
                                for (var e = 0; e < r; e += 1) a[e] = s[e] = t.v[e] * i;
                                return a
                            }
                    }(r) : i
                }
            }(),
            TextExpressionSelectorProp, propertyGetTextProp;

        function SliderEffect(t, e, n) {
            this.p = PropertyFactory.getProp(e, t.v, 0, 0, n)
        }

        function AngleEffect(t, e, n) {
            this.p = PropertyFactory.getProp(e, t.v, 0, 0, n)
        }

        function ColorEffect(t, e, n) {
            this.p = PropertyFactory.getProp(e, t.v, 1, 0, n)
        }

        function PointEffect(t, e, n) {
            this.p = PropertyFactory.getProp(e, t.v, 1, 0, n)
        }

        function LayerIndexEffect(t, e, n) {
            this.p = PropertyFactory.getProp(e, t.v, 0, 0, n)
        }

        function MaskIndexEffect(t, e, n) {
            this.p = PropertyFactory.getProp(e, t.v, 0, 0, n)
        }

        function CheckboxEffect(t, e, n) {
            this.p = PropertyFactory.getProp(e, t.v, 0, 0, n)
        }

        function NoValueEffect() {
            this.p = {}
        }

        function EffectsManager() {}

        function EffectsManager(t, e) {
            var n = t.ef || [];
            this.effectElements = [];
            var i, r, a = n.length;
            for (i = 0; i < a; i++) r = new GroupEffect(n[i], e), this.effectElements.push(r)
        }

        function GroupEffect(t, e) {
            this.init(t, e)
        }
        TextExpressionSelectorProp = function () {
            function t(t, e) {
                return this.textIndex = t + 1, this.textTotal = e, this.v = this.getValue() * this.mult, this.v
            }
            return function (e, n) {
                this.pv = 1, this.comp = e.comp, this.elem = e, this.mult = .01, this.propType = "textSelector", this.textTotal = n.totalChars, this.selectorValue = 100, this.lastValue = [1, 1, 1], this.k = !0, this.x = !0, this.getValue = ExpressionManager.initiateExpression.bind(this)(e, n, this), this.getMult = t, this.getVelocityAtTime = expressionHelpers.getVelocityAtTime, this.kf ? this.getValueAtTime = expressionHelpers.getValueAtTime.bind(this) : this.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(this), this.setGroupProperty = expressionHelpers.setGroupProperty
            }
        }(), propertyGetTextProp = TextSelectorProp.getTextSelectorProp, TextSelectorProp.getTextSelectorProp = function (t, e, n) {
            return 1 === e.t ? new TextExpressionSelectorProp(t, e, n) : propertyGetTextProp(t, e, n)
        }, extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function (t, e) {
            this.data = t, this.effectElements = [], this.initDynamicPropertyContainer(e);
            var n, i, r = this.data.ef.length,
                a = this.data.ef;
            for (n = 0; n < r; n += 1) {
                switch (i = null, a[n].ty) {
                    case 0:
                        i = new SliderEffect(a[n], e, this);
                        break;
                    case 1:
                        i = new AngleEffect(a[n], e, this);
                        break;
                    case 2:
                        i = new ColorEffect(a[n], e, this);
                        break;
                    case 3:
                        i = new PointEffect(a[n], e, this);
                        break;
                    case 4:
                    case 7:
                        i = new CheckboxEffect(a[n], e, this);
                        break;
                    case 10:
                        i = new LayerIndexEffect(a[n], e, this);
                        break;
                    case 11:
                        i = new MaskIndexEffect(a[n], e, this);
                        break;
                    case 5:
                        i = new EffectsManager(a[n], e, this);
                        break;
                    default:
                        i = new NoValueEffect(a[n], e, this)
                }
                i && this.effectElements.push(i)
            }
        };
        var lottie = {},
            _isFrozen = !1;

        function setLocationHref(t) {
            locationHref = t
        }

        function searchAnimations() {
            !0 === standalone ? animationManager.searchAnimations(animationData, standalone, renderer) : animationManager.searchAnimations()
        }

        function setSubframeRendering(t) {
            subframeEnabled = t
        }

        function loadAnimation(t) {
            return !0 === standalone && (t.animationData = JSON.parse(animationData)), animationManager.loadAnimation(t)
        }

        function setQuality(t) {
            if ("string" == typeof t) switch (t) {
                case "high":
                    defaultCurveSegments = 200;
                    break;
                case "medium":
                    defaultCurveSegments = 50;
                    break;
                case "low":
                    defaultCurveSegments = 10
            } else !isNaN(t) && t > 1 && (defaultCurveSegments = t);
            roundValues(!(defaultCurveSegments >= 50))
        }

        function inBrowser() {
            return "undefined" != typeof navigator
        }

        function installPlugin(t, e) {
            "expressions" === t && (expressionsPlugin = e)
        }

        function getFactory(t) {
            switch (t) {
                case "propertyFactory":
                    return PropertyFactory;
                case "shapePropertyFactory":
                    return ShapePropertyFactory;
                case "matrix":
                    return Matrix
            }
        }

        function checkReady() {
            "complete" === document.readyState && (clearInterval(readyStateCheckInterval), searchAnimations())
        }

        function getQueryVariable(t) {
            for (var e = queryString.split("&"), n = 0; n < e.length; n++) {
                var i = e[n].split("=");
                if (decodeURIComponent(i[0]) == t) return decodeURIComponent(i[1])
            }
        }
        lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocationHref, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.__getFactory = getFactory, lottie.version = "5.6.8";
        var standalone = "__[STANDALONE]__",
            animationData = "__[ANIMATIONDATA]__",
            renderer = "";
        if (standalone) {
            var scripts = document.getElementsByTagName("script"),
                index = scripts.length - 1,
                myScript = scripts[index] || {
                    src: ""
                },
                queryString = myScript.src.replace(/^[^\?]+\??/, "");
            renderer = getQueryVariable("renderer")
        }
        var readyStateCheckInterval = setInterval(checkReady, 100);
        return lottie
    }))
}, function (t, e, n) {
    "use strict";
    var i = n(7);

    function r() {
        var t = navigator.userAgent.toLowerCase(),
            e = navigator.appVersion.toLowerCase(),
            n = /windows phone|iemobile|wpdesktop/.test(t),
            i = !n && /android.*mobile/.test(t),
            r = !n && !i && /android/i.test(t),
            a = i || r,
            s = !n && /ip(hone|od|ad)/i.test(t) && !window.MSStream,
            o = !n && /ipad/i.test(t) && s,
            l = r || o,
            h = i || s && !o || n,
            u = h || l,
            c = t.indexOf("firefox") > -1,
            p = !!t.match(/version\/[\d\.]+.*safari/),
            f = t.indexOf("opr") > -1,
            d = !window.ActiveXObject && "ActiveXObject" in window,
            m = e.indexOf("msie") > -1 || d || e.indexOf("edge") > -1,
            g = t.indexOf("edge") > -1,
            v = null !== window.chrome && void 0 !== window.chrome && "google inc." == navigator.vendor.toLowerCase() && !f && !g;
        this.infos = {
            isDroid: a,
            isDroidPhone: i,
            isDroidTablet: r,
            isWindowsPhone: n,
            isIos: s,
            isIpad: o,
            isDevice: u,
            isEdge: g,
            isIE: m,
            isIE11: d,
            isPhone: h,
            isTablet: l,
            isFirefox: c,
            isSafari: p,
            isOpera: f,
            isChrome: v,
            isDesktop: !h && !l
        }, Object.keys(this.infos).forEach((function (t) {
            Object.defineProperty(this, t, {
                get: function () {
                    return this.infos[t]
                }
            })
        }), this), Object.freeze(this)
    }
    t.exports = new r, r.prototype.addClasses = function (t) {
        Object.keys(this.infos).forEach((function (e) {
            this.infos[e] && function (t, e) {
                t.addClass ? t.addClass(e) : t.classList ? t.classList.add(e) : t.className += " " + e
            }(t, i(e))
        }), this)
    }, r.prototype.getInfos = function () {
        return t = this.infos, JSON.parse(JSON.stringify(t));
        var t
    }
}, function (t, e, n) {
    (function (e) {
        var n = /^\s+|\s+$/g,
            i = /^[-+]0x[0-9a-f]+$/i,
            r = /^0b[01]+$/i,
            a = /^0o[0-7]+$/i,
            s = parseInt,
            o = "object" == typeof e && e && e.Object === Object && e,
            l = "object" == typeof self && self && self.Object === Object && self,
            h = o || l || Function("return this")(),
            u = Object.prototype.toString,
            c = Math.max,
            p = Math.min,
            f = function () {
                return h.Date.now()
            };

        function d(t) {
            var e = typeof t;
            return !!t && ("object" == e || "function" == e)
        }

        function m(t) {
            if ("number" == typeof t) return t;
            if (function (t) {
                    return "symbol" == typeof t || function (t) {
                        return !!t && "object" == typeof t
                    }(t) && "[object Symbol]" == u.call(t)
                }(t)) return NaN;
            if (d(t)) {
                var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                t = d(e) ? e + "" : e
            }
            if ("string" != typeof t) return 0 === t ? t : +t;
            t = t.replace(n, "");
            var o = r.test(t);
            return o || a.test(t) ? s(t.slice(2), o ? 2 : 8) : i.test(t) ? NaN : +t
        }
        t.exports = function (t, e, n) {
            var i, r, a, s, o, l, h = 0,
                u = !1,
                g = !1,
                v = !0;
            if ("function" != typeof t) throw new TypeError("Expected a function");

            function y(e) {
                var n = i,
                    a = r;
                return i = r = void 0, h = e, s = t.apply(a, n)
            }

            function _(t) {
                return h = t, o = setTimeout(b, e), u ? y(t) : s
            }

            function x(t) {
                var n = t - l;
                return void 0 === l || n >= e || n < 0 || g && t - h >= a
            }

            function b() {
                var t = f();
                if (x(t)) return E(t);
                o = setTimeout(b, function (t) {
                    var n = e - (t - l);
                    return g ? p(n, a - (t - h)) : n
                }(t))
            }

            function E(t) {
                return o = void 0, v && i ? y(t) : (i = r = void 0, s)
            }

            function w() {
                var t = f(),
                    n = x(t);
                if (i = arguments, r = this, l = t, n) {
                    if (void 0 === o) return _(l);
                    if (g) return o = setTimeout(b, e), y(l)
                }
                return void 0 === o && (o = setTimeout(b, e)), s
            }
            return e = m(e) || 0, d(n) && (u = !!n.leading, a = (g = "maxWait" in n) ? c(m(n.maxWait) || 0, e) : a, v = "trailing" in n ? !!n.trailing : v), w.cancel = function () {
                void 0 !== o && clearTimeout(o), h = 0, i = l = r = o = void 0
            }, w.flush = function () {
                return void 0 === o ? s : E(f())
            }, w
        }
    }).call(this, n(8))
}, function (t, e, n) {
    var i, r, a, s;

    function o(t) {
        return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
            return typeof t
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }
    s = function (t) {
        "use strict";
        var e, n, i, r = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/,
            a = /(?:\r|\n|\t\t)/g,
            s = /(?:\s\s+)/g,
            l = function (t) {
                return n.getComputedStyle(t)
            },
            h = Array.isArray,
            u = [].slice,
            c = function (t, n) {
                var i;
                return h(t) ? t : "string" === (i = o(t)) && !n && t ? u.call(e.querySelectorAll(t), 0) : t && "object" === i && "length" in t ? u.call(t, 0) : t ? [t] : []
            },
            p = function (t) {
                return "absolute" === t.position || !0 === t.absolute
            },
            f = function (t, e) {
                for (var n, i = e.length; --i > -1;)
                    if (n = e[i], t.substr(0, n.length) === n) return n.length
            },
            d = function (t, e) {
                void 0 === t && (t = "");
                var n = ~t.indexOf("++"),
                    i = 1;
                return n && (t = t.split("++").join("")),
                    function () {
                        return "<" + e + " style='position:relative;display:inline-block;'" + (t ? " class='" + t + (n ? i++ : "") + "'>" : ">")
                    }
            },
            m = function t(e, n, i) {
                var r = e.nodeType;
                if (1 === r || 9 === r || 11 === r)
                    for (e = e.firstChild; e; e = e.nextSibling) t(e, n, i);
                else 3 !== r && 4 !== r || (e.nodeValue = e.nodeValue.split(n).join(i))
            },
            g = function (t, e) {
                for (var n = e.length; --n > -1;) t.push(e[n])
            },
            v = function (t, e, n) {
                for (var i; t && t !== e;) {
                    if (i = t._next || t.nextSibling) return i.textContent.charAt(0) === n;
                    t = t.parentNode || t._parent
                }
            },
            y = function t(e) {
                var n, i, r = c(e.childNodes),
                    a = r.length;
                for (n = 0; n < a; n++)(i = r[n])._isSplit ? t(i) : (n && 3 === i.previousSibling.nodeType ? i.previousSibling.nodeValue += 3 === i.nodeType ? i.nodeValue : i.firstChild.nodeValue : 3 !== i.nodeType && e.insertBefore(i.firstChild, i), e.removeChild(i))
            },
            _ = function (t, e) {
                return parseFloat(e[t]) || 0
            },
            x = function (t, n, i, r, a, s, o) {
                var h, u, c, f, d, x, b, E, w, D, M, S, T = l(t),
                    A = _("paddingLeft", T),
                    C = -999,
                    P = _("borderBottomWidth", T) + _("borderTopWidth", T),
                    F = _("borderLeftWidth", T) + _("borderRightWidth", T),
                    L = _("paddingTop", T) + _("paddingBottom", T),
                    R = _("paddingLeft", T) + _("paddingRight", T),
                    I = .2 * _("fontSize", T),
                    k = T.textAlign,
                    O = [],
                    N = [],
                    B = [],
                    z = n.wordDelimiter || " ",
                    U = n.tag ? n.tag : n.span ? "span" : "div",
                    V = n.type || n.split || "chars,words,lines",
                    G = a && ~V.indexOf("lines") ? [] : null,
                    H = ~V.indexOf("words"),
                    j = ~V.indexOf("chars"),
                    W = p(n),
                    X = n.linesClass,
                    q = ~(X || "").indexOf("++"),
                    Y = [];
                for (q && (X = X.split("++").join("")), c = (u = t.getElementsByTagName("*")).length, d = [], h = 0; h < c; h++) d[h] = u[h];
                if (G || W)
                    for (h = 0; h < c; h++)((x = (f = d[h]).parentNode === t) || W || j && !H) && (S = f.offsetTop, G && x && Math.abs(S - C) > I && ("BR" !== f.nodeName || 0 === h) && (b = [], G.push(b), C = S), W && (f._x = f.offsetLeft, f._y = S, f._w = f.offsetWidth, f._h = f.offsetHeight), G && ((f._isSplit && x || !j && x || H && x || !H && f.parentNode.parentNode === t && !f.parentNode._isSplit) && (b.push(f), f._x -= A, v(f, t, z) && (f._wordEnd = !0)), "BR" === f.nodeName && (f.nextSibling && "BR" === f.nextSibling.nodeName || 0 === h) && G.push([])));
                for (h = 0; h < c; h++) x = (f = d[h]).parentNode === t, "BR" !== f.nodeName ? (W && (w = f.style, H || x || (f._x += f.parentNode._x, f._y += f.parentNode._y), w.left = f._x + "px", w.top = f._y + "px", w.position = "absolute", w.display = "block", w.width = f._w + 1 + "px", w.height = f._h + "px"), !H && j ? f._isSplit ? (f._next = f.nextSibling, f.parentNode.appendChild(f)) : f.parentNode._isSplit ? (f._parent = f.parentNode, !f.previousSibling && f.firstChild && (f.firstChild._isFirst = !0), f.nextSibling && " " === f.nextSibling.textContent && !f.nextSibling.nextSibling && Y.push(f.nextSibling), f._next = f.nextSibling && f.nextSibling._isFirst ? null : f.nextSibling, f.parentNode.removeChild(f), d.splice(h--, 1), c--) : x || (S = !f.nextSibling && v(f.parentNode, t, z), f.parentNode._parent && f.parentNode._parent.appendChild(f), S && f.parentNode.appendChild(e.createTextNode(" ")), "span" === U && (f.style.display = "inline"), O.push(f)) : f.parentNode._isSplit && !f._isSplit && "" !== f.innerHTML ? N.push(f) : j && !f._isSplit && ("span" === U && (f.style.display = "inline"), O.push(f))) : G || W ? (f.parentNode && f.parentNode.removeChild(f), d.splice(h--, 1), c--) : H || t.appendChild(f);
                for (h = Y.length; --h > -1;) Y[h].parentNode.removeChild(Y[h]);
                if (G) {
                    for (W && (D = e.createElement(U), t.appendChild(D), M = D.offsetWidth + "px", S = D.offsetParent === t ? 0 : t.offsetLeft, t.removeChild(D)), w = t.style.cssText, t.style.cssText = "display:none;"; t.firstChild;) t.removeChild(t.firstChild);
                    for (E = " " === z && (!W || !H && !j), h = 0; h < G.length; h++) {
                        for (b = G[h], (D = e.createElement(U)).style.cssText = "display:block;text-align:" + k + ";position:" + (W ? "absolute;" : "relative;"), X && (D.className = X + (q ? h + 1 : "")), B.push(D), c = b.length, u = 0; u < c; u++) "BR" !== b[u].nodeName && (f = b[u], D.appendChild(f), E && f._wordEnd && D.appendChild(e.createTextNode(" ")), W && (0 === u && (D.style.top = f._y + "px", D.style.left = A + S + "px"), f.style.top = "0px", S && (f.style.left = f._x - S + "px")));
                        0 === c ? D.innerHTML = "&nbsp;" : H || j || (y(D), m(D, String.fromCharCode(160), " ")), W && (D.style.width = M, D.style.height = f._h + "px"), t.appendChild(D)
                    }
                    t.style.cssText = w
                }
                W && (o > t.clientHeight && (t.style.height = o - L + "px", t.clientHeight < o && (t.style.height = o + P + "px")), s > t.clientWidth && (t.style.width = s - R + "px", t.clientWidth < s && (t.style.width = s + F + "px"))), g(i, O), H && g(r, N), g(a, B)
            },
            b = function (t, n, i, o) {
                var l, h, u, c, d, g, v, y, _ = n.tag ? n.tag : n.span ? "span" : "div",
                    x = ~(n.type || n.split || "chars,words,lines").indexOf("chars"),
                    b = p(n),
                    E = n.wordDelimiter || " ",
                    w = " " !== E ? "" : b ? "&#173; " : " ",
                    D = "</" + _ + ">",
                    M = 1,
                    S = n.specialChars ? "function" == typeof n.specialChars ? n.specialChars : f : null,
                    T = e.createElement("div"),
                    A = t.parentNode;
                for (A.insertBefore(T, t), T.textContent = t.nodeValue, A.removeChild(t), v = -1 !== (l = function t(e) {
                        var n = e.nodeType,
                            i = "";
                        if (1 === n || 9 === n || 11 === n) {
                            if ("string" == typeof e.textContent) return e.textContent;
                            for (e = e.firstChild; e; e = e.nextSibling) i += t(e)
                        } else if (3 === n || 4 === n) return e.nodeValue;
                        return i
                    }(t = T)).indexOf("<"), !1 !== n.reduceWhiteSpace && (l = l.replace(s, " ").replace(a, "")), v && (l = l.split("<").join("{{LT}}")), d = l.length, h = (" " === l.charAt(0) ? w : "") + i(), u = 0; u < d; u++)
                    if (g = l.charAt(u), S && (y = S(l.substr(u), n.specialChars))) g = l.substr(u, y || 1), h += x && " " !== g ? o() + g + "</" + _ + ">" : g, u += y - 1;
                    else if (g === E && l.charAt(u - 1) !== E && u) {
                    for (h += M ? D : "", M = 0; l.charAt(u + 1) === E;) h += w, u++;
                    u === d - 1 ? h += w : ")" !== l.charAt(u + 1) && (h += w + i(), M = 1)
                } else "{" === g && "{{LT}}" === l.substr(u, 6) ? (h += x ? o() + "{{LT}}</" + _ + ">" : "{{LT}}", u += 5) : g.charCodeAt(0) >= 55296 && g.charCodeAt(0) <= 56319 || l.charCodeAt(u + 1) >= 65024 && l.charCodeAt(u + 1) <= 65039 ? (c = ((l.substr(u, 12).split(r) || [])[1] || "").length || 2, h += x && " " !== g ? o() + l.substr(u, c) + "</" + _ + ">" : l.substr(u, c), u += c - 1) : h += x && " " !== g ? o() + g + "</" + _ + ">" : g;
                t.outerHTML = h + (M ? D : ""), v && m(A, "{{LT}}", "<")
            },
            E = function t(e, n, i, r) {
                var a, s, o = c(e.childNodes),
                    h = o.length,
                    u = p(n);
                if (3 !== e.nodeType || h > 1) {
                    for (n.absolute = !1, a = 0; a < h; a++)(3 !== (s = o[a]).nodeType || /\S+/.test(s.nodeValue)) && (u && 3 !== s.nodeType && "inline" === l(s).display && (s.style.display = "inline-block", s.style.position = "relative"), s._isSplit = !0, t(s, n, i, r));
                    return n.absolute = u, void(e._isSplit = !0)
                }
                b(e, n, i, r)
            },
            w = function () {
                function t(t, r) {
                    i || (e = document, n = window, i = 1), this.elements = c(t), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = r || {}, this.split(r)
                }
                var r = t.prototype;
                return r.split = function (t) {
                    this.isSplit && this.revert(), this.vars = t = t || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                    for (var e, n, i, r = this.elements.length, a = t.tag ? t.tag : t.span ? "span" : "div", s = d(t.wordsClass, a), o = d(t.charsClass, a); --r > -1;) i = this.elements[r], this._originals[r] = i.innerHTML, e = i.clientHeight, n = i.clientWidth, E(i, t, s, o), x(i, t, this.chars, this.words, this.lines, n, e);
                    return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
                }, r.revert = function () {
                    var t = this._originals;
                    if (!t) throw "revert() call wasn't scoped properly.";
                    return this.elements.forEach((function (e, n) {
                        return e.innerHTML = t[n]
                    })), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
                }, t.create = function (e, n) {
                    return new t(e, n)
                }, t
            }();
        w.version = "3.0.0", t.SplitText = w, t.default = w, Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, "object" === o(e) && void 0 !== t ? s(e) : (r = [e], void 0 === (a = "function" == typeof (i = s) ? i.apply(e, r) : i) || (t.exports = a))
}, function (t, e, n) {
    t.exports = n(9)
}, function (t, e, n) {}, function (t, e) {
    ! function () {
        "use strict";
        if ("object" == typeof window)
            if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) "isIntersecting" in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
                get: function () {
                    return this.intersectionRatio > 0
                }
            });
            else {
                var t = window.document,
                    e = [],
                    n = null,
                    i = null;
                a.prototype.THROTTLE_TIMEOUT = 100, a.prototype.POLL_INTERVAL = null, a.prototype.USE_MUTATION_OBSERVER = !0, a._setupCrossOriginUpdater = function () {
                    return n || (n = function (t, n) {
                        i = t && n ? u(t, n) : {
                            top: 0,
                            bottom: 0,
                            left: 0,
                            right: 0,
                            width: 0,
                            height: 0
                        }, e.forEach((function (t) {
                            t._checkForIntersections()
                        }))
                    }), n
                }, a._resetCrossOriginUpdater = function () {
                    n = null, i = null
                }, a.prototype.observe = function (t) {
                    if (!this._observationTargets.some((function (e) {
                            return e.element == t
                        }))) {
                        if (!t || 1 != t.nodeType) throw new Error("target must be an Element");
                        this._registerInstance(), this._observationTargets.push({
                            element: t,
                            entry: null
                        }), this._monitorIntersections(t.ownerDocument), this._checkForIntersections()
                    }
                }, a.prototype.unobserve = function (t) {
                    this._observationTargets = this._observationTargets.filter((function (e) {
                        return e.element != t
                    })), this._unmonitorIntersections(t.ownerDocument), 0 == this._observationTargets.length && this._unregisterInstance()
                }, a.prototype.disconnect = function () {
                    this._observationTargets = [], this._unmonitorAllIntersections(), this._unregisterInstance()
                }, a.prototype.takeRecords = function () {
                    var t = this._queuedEntries.slice();
                    return this._queuedEntries = [], t
                }, a.prototype._initThresholds = function (t) {
                    var e = t || [0];
                    return Array.isArray(e) || (e = [e]), e.sort().filter((function (t, e, n) {
                        if ("number" != typeof t || isNaN(t) || t < 0 || t > 1) throw new Error("threshold must be a number between 0 and 1 inclusively");
                        return t !== n[e - 1]
                    }))
                }, a.prototype._parseRootMargin = function (t) {
                    var e = (t || "0px").split(/\s+/).map((function (t) {
                        var e = /^(-?\d*\.?\d+)(px|%)$/.exec(t);
                        if (!e) throw new Error("rootMargin must be specified in pixels or percent");
                        return {
                            value: parseFloat(e[1]),
                            unit: e[2]
                        }
                    }));
                    return e[1] = e[1] || e[0], e[2] = e[2] || e[0], e[3] = e[3] || e[1], e
                }, a.prototype._monitorIntersections = function (e) {
                    var n = e.defaultView;
                    if (n && -1 == this._monitoringDocuments.indexOf(e)) {
                        var i = this._checkForIntersections,
                            r = null,
                            a = null;
                        if (this.POLL_INTERVAL ? r = n.setInterval(i, this.POLL_INTERVAL) : (s(n, "resize", i, !0), s(e, "scroll", i, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in n && (a = new n.MutationObserver(i)).observe(e, {
                                attributes: !0,
                                childList: !0,
                                characterData: !0,
                                subtree: !0
                            })), this._monitoringDocuments.push(e), this._monitoringUnsubscribes.push((function () {
                                var t = e.defaultView;
                                t && (r && t.clearInterval(r), o(t, "resize", i, !0)), o(e, "scroll", i, !0), a && a.disconnect()
                            })), e != (this.root && this.root.ownerDocument || t)) {
                            var l = f(e);
                            l && this._monitorIntersections(l.ownerDocument)
                        }
                    }
                }, a.prototype._unmonitorIntersections = function (e) {
                    var n = this._monitoringDocuments.indexOf(e);
                    if (-1 != n) {
                        var i = this.root && this.root.ownerDocument || t;
                        if (!this._observationTargets.some((function (t) {
                                var n = t.element.ownerDocument;
                                if (n == e) return !0;
                                for (; n && n != i;) {
                                    var r = f(n);
                                    if ((n = r && r.ownerDocument) == e) return !0
                                }
                                return !1
                            }))) {
                            var r = this._monitoringUnsubscribes[n];
                            if (this._monitoringDocuments.splice(n, 1), this._monitoringUnsubscribes.splice(n, 1), r(), e != i) {
                                var a = f(e);
                                a && this._unmonitorIntersections(a.ownerDocument)
                            }
                        }
                    }
                }, a.prototype._unmonitorAllIntersections = function () {
                    var t = this._monitoringUnsubscribes.slice(0);
                    this._monitoringDocuments.length = 0, this._monitoringUnsubscribes.length = 0;
                    for (var e = 0; e < t.length; e++) t[e]()
                }, a.prototype._checkForIntersections = function () {
                    if (this.root || !n || i) {
                        var t = this._rootIsInDom(),
                            e = t ? this._getRootRect() : {
                                top: 0,
                                bottom: 0,
                                left: 0,
                                right: 0,
                                width: 0,
                                height: 0
                            };
                        this._observationTargets.forEach((function (i) {
                            var a = i.element,
                                s = l(a),
                                o = this._rootContainsTarget(a),
                                h = i.entry,
                                u = t && o && this._computeTargetAndRootIntersection(a, s, e),
                                c = i.entry = new r({
                                    time: window.performance && performance.now && performance.now(),
                                    target: a,
                                    boundingClientRect: s,
                                    rootBounds: n && !this.root ? null : e,
                                    intersectionRect: u
                                });
                            h ? t && o ? this._hasCrossedThreshold(h, c) && this._queuedEntries.push(c) : h && h.isIntersecting && this._queuedEntries.push(c) : this._queuedEntries.push(c)
                        }), this), this._queuedEntries.length && this._callback(this.takeRecords(), this)
                    }
                }, a.prototype._computeTargetAndRootIntersection = function (e, r, a) {
                    if ("none" != window.getComputedStyle(e).display) {
                        for (var s, o, h, c, f, d, m, g, v = r, y = p(e), _ = !1; !_ && y;) {
                            var x = null,
                                b = 1 == y.nodeType ? window.getComputedStyle(y) : {};
                            if ("none" == b.display) return null;
                            if (y == this.root || 9 == y.nodeType)
                                if (_ = !0, y == this.root || y == t) n && !this.root ? !i || 0 == i.width && 0 == i.height ? (y = null, x = null, v = null) : x = i : x = a;
                                else {
                                    var E = p(y),
                                        w = E && l(E),
                                        D = E && this._computeTargetAndRootIntersection(E, w, a);
                                    w && D ? (y = E, x = u(w, D)) : (y = null, v = null)
                                }
                            else {
                                var M = y.ownerDocument;
                                y != M.body && y != M.documentElement && "visible" != b.overflow && (x = l(y))
                            }
                            if (x && (s = x, o = v, h = void 0, c = void 0, f = void 0, d = void 0, m = void 0, g = void 0, h = Math.max(s.top, o.top), c = Math.min(s.bottom, o.bottom), f = Math.max(s.left, o.left), d = Math.min(s.right, o.right), g = c - h, v = (m = d - f) >= 0 && g >= 0 && {
                                    top: h,
                                    bottom: c,
                                    left: f,
                                    right: d,
                                    width: m,
                                    height: g
                                } || null), !v) break;
                            y = y && p(y)
                        }
                        return v
                    }
                }, a.prototype._getRootRect = function () {
                    var e;
                    if (this.root) e = l(this.root);
                    else {
                        var n = t.documentElement,
                            i = t.body;
                        e = {
                            top: 0,
                            left: 0,
                            right: n.clientWidth || i.clientWidth,
                            width: n.clientWidth || i.clientWidth,
                            bottom: n.clientHeight || i.clientHeight,
                            height: n.clientHeight || i.clientHeight
                        }
                    }
                    return this._expandRectByRootMargin(e)
                }, a.prototype._expandRectByRootMargin = function (t) {
                    var e = this._rootMarginValues.map((function (e, n) {
                            return "px" == e.unit ? e.value : e.value * (n % 2 ? t.width : t.height) / 100
                        })),
                        n = {
                            top: t.top - e[0],
                            right: t.right + e[1],
                            bottom: t.bottom + e[2],
                            left: t.left - e[3]
                        };
                    return n.width = n.right - n.left, n.height = n.bottom - n.top, n
                }, a.prototype._hasCrossedThreshold = function (t, e) {
                    var n = t && t.isIntersecting ? t.intersectionRatio || 0 : -1,
                        i = e.isIntersecting ? e.intersectionRatio || 0 : -1;
                    if (n !== i)
                        for (var r = 0; r < this.thresholds.length; r++) {
                            var a = this.thresholds[r];
                            if (a == n || a == i || a < n != a < i) return !0
                        }
                }, a.prototype._rootIsInDom = function () {
                    return !this.root || c(t, this.root)
                }, a.prototype._rootContainsTarget = function (e) {
                    return c(this.root || t, e) && (!this.root || this.root.ownerDocument == e.ownerDocument)
                }, a.prototype._registerInstance = function () {
                    e.indexOf(this) < 0 && e.push(this)
                }, a.prototype._unregisterInstance = function () {
                    var t = e.indexOf(this); - 1 != t && e.splice(t, 1)
                }, window.IntersectionObserver = a, window.IntersectionObserverEntry = r
            }
        function r(t) {
            this.time = t.time, this.target = t.target, this.rootBounds = h(t.rootBounds), this.boundingClientRect = h(t.boundingClientRect), this.intersectionRect = h(t.intersectionRect || {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                width: 0,
                height: 0
            }), this.isIntersecting = !!t.intersectionRect;
            var e = this.boundingClientRect,
                n = e.width * e.height,
                i = this.intersectionRect,
                r = i.width * i.height;
            this.intersectionRatio = n ? Number((r / n).toFixed(4)) : this.isIntersecting ? 1 : 0
        }

        function a(t, e) {
            var n, i, r, a = e || {};
            if ("function" != typeof t) throw new Error("callback must be a function");
            if (a.root && 1 != a.root.nodeType) throw new Error("root must be an Element");
            this._checkForIntersections = (n = this._checkForIntersections.bind(this), i = this.THROTTLE_TIMEOUT, r = null, function () {
                r || (r = setTimeout((function () {
                    n(), r = null
                }), i))
            }), this._callback = t, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(a.rootMargin), this.thresholds = this._initThresholds(a.threshold), this.root = a.root || null, this.rootMargin = this._rootMarginValues.map((function (t) {
                return t.value + t.unit
            })).join(" "), this._monitoringDocuments = [], this._monitoringUnsubscribes = []
        }

        function s(t, e, n, i) {
            "function" == typeof t.addEventListener ? t.addEventListener(e, n, i || !1) : "function" == typeof t.attachEvent && t.attachEvent("on" + e, n)
        }

        function o(t, e, n, i) {
            "function" == typeof t.removeEventListener ? t.removeEventListener(e, n, i || !1) : "function" == typeof t.detatchEvent && t.detatchEvent("on" + e, n)
        }

        function l(t) {
            var e;
            try {
                e = t.getBoundingClientRect()
            } catch (t) {}
            return e ? (e.width && e.height || (e = {
                top: e.top,
                right: e.right,
                bottom: e.bottom,
                left: e.left,
                width: e.right - e.left,
                height: e.bottom - e.top
            }), e) : {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                width: 0,
                height: 0
            }
        }

        function h(t) {
            return !t || "x" in t ? t : {
                top: t.top,
                y: t.top,
                bottom: t.bottom,
                left: t.left,
                x: t.left,
                right: t.right,
                width: t.width,
                height: t.height
            }
        }

        function u(t, e) {
            var n = e.top - t.top,
                i = e.left - t.left;
            return {
                top: n,
                left: i,
                height: e.height,
                width: e.width,
                bottom: n + e.height,
                right: i + e.width
            }
        }

        function c(t, e) {
            for (var n = e; n;) {
                if (n == t) return !0;
                n = p(n)
            }
            return !1
        }

        function p(e) {
            var n = e.parentNode;
            return 9 == e.nodeType && e != t ? f(e) : n && 11 == n.nodeType && n.host ? n.host : n && n.assignedSlot ? n.assignedSlot.parentNode : n
        }

        function f(t) {
            try {
                return t.defaultView && t.defaultView.frameElement || null
            } catch (t) {
                return null
            }
        }
    }()
}, function (t, e, n) {
    "use strict";
    t.exports = function (t) {
        if ("string" != typeof t) throw new TypeError("expected a string");
        return (t = (t = (t = t.replace(/([a-z])([A-Z])/g, "$1-$2")).replace(/[ \t\W]/g, "-")).replace(/^-+|-+$/g, "")).toLowerCase()
    }
}, function (t, e) {
    var n;
    n = function () {
        return this
    }();
    try {
        n = n || new Function("return this")()
    } catch (t) {
        "object" == typeof window && (n = window)
    }
    t.exports = n
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = {};
    n.r(i), n.d(i, "HeroSlide", (function () {
        return qh
    })), n.d(i, "PlaneVideo", (function () {
        return ru
    }));
    n(5), n(6);

    function r() {}
    r.prototype = {
        on: function (t, e, n) {
            var i = this.e || (this.e = {});
            return (i[t] || (i[t] = [])).push({
                fn: e,
                ctx: n
            }), this
        },
        once: function (t, e, n) {
            var i = this;

            function r() {
                i.off(t, r), e.apply(n, arguments)
            }
            return r._ = e, this.on(t, r, n)
        },
        emit: function (t) {
            for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++) n[i].fn.apply(n[i].ctx, e);
            return this
        },
        off: function (t, e) {
            var n = this.e || (this.e = {}),
                i = n[t],
                r = [];
            if (i && e)
                for (var a = 0, s = i.length; a < s; a++) i[a].fn !== e && i[a].fn._ !== e && r.push(i[a]);
            return r.length ? n[t] = r : delete n[t], this
        }
    };
    var a = r;
    a.TinyEmitter = r;
    var s = function (t) {
        this.wrap = document.querySelector("[data-router-wrapper]"), this.properties = t, this.Transition = t.transition ? new t.transition.class(this.wrap, t.transition.name) : null
    };
    s.prototype.setup = function () {
        this.onEnter && this.onEnter(), this.onEnterCompleted && this.onEnterCompleted()
    }, s.prototype.add = function () {
        this.wrap.insertAdjacentHTML("beforeend", this.properties.view.outerHTML)
    }, s.prototype.update = function () {
        document.title = this.properties.page.title
    }, s.prototype.show = function (t) {
        var e = this;
        return new Promise((function (n) {
            try {
                function i(t) {
                    e.onEnterCompleted && e.onEnterCompleted(), n()
                }
                return e.update(), e.onEnter && e.onEnter(), Promise.resolve(e.Transition ? Promise.resolve(e.Transition.show(t)).then(i) : i())
            } catch (t) {
                return Promise.reject(t)
            }
        }))
    }, s.prototype.hide = function (t) {
        var e = this;
        return new Promise((function (n) {
            try {
                function i(t) {
                    e.onLeaveCompleted && e.onLeaveCompleted(), n()
                }
                return e.onLeave && e.onLeave(), Promise.resolve(e.Transition ? Promise.resolve(e.Transition.hide(t)).then(i) : i())
            } catch (t) {
                return Promise.reject(t)
            }
        }))
    };
    var o = new window.DOMParser,
        l = function (t, e) {
            this.renderers = t, this.transitions = e
        };
    l.prototype.getOrigin = function (t) {
        var e = t.match(/(https?:\/\/[\w\-.]+)/);
        return e ? e[1].replace(/https?:\/\//, "") : null
    }, l.prototype.getPathname = function (t) {
        var e = t.match(/https?:\/\/.*?(\/[\w_\-./]+)/);
        return e ? e[1] : "/"
    }, l.prototype.getAnchor = function (t) {
        var e = t.match(/(#.*)$/);
        return e ? e[1] : null
    }, l.prototype.getParams = function (t) {
        var e = t.match(/\?([\w_\-.=&]+)/);
        if (!e) return null;
        for (var n = e[1].split("&"), i = {}, r = 0; r < n.length; r++) {
            var a = n[r].split("=");
            i[a[0]] = a[1]
        }
        return i
    }, l.prototype.getDOM = function (t) {
        return "string" == typeof t ? o.parseFromString(t, "text/html") : t
    }, l.prototype.getView = function (t) {
        return t.querySelector("[data-router-view]")
    }, l.prototype.getSlug = function (t) {
        return t.getAttribute("data-router-view")
    }, l.prototype.getRenderer = function (t) {
        if (!this.renderers) return Promise.resolve(s);
        if (t in this.renderers) {
            var e = this.renderers[t];
            return "function" != typeof e || s.isPrototypeOf(e) ? "function" == typeof e.then ? Promise.resolve(e).then((function (t) {
                return t.default
            })) : Promise.resolve(e) : Promise.resolve(e()).then((function (t) {
                return t.default
            }))
        }
        return Promise.resolve(s)
    }, l.prototype.getTransition = function (t) {
        return this.transitions ? t in this.transitions ? {
            class: this.transitions[t],
            name: t
        } : "default" in this.transitions ? {
            class: this.transitions.default,
            name: "default"
        } : null : null
    }, l.prototype.getProperties = function (t) {
        var e = this.getDOM(t),
            n = this.getView(e),
            i = this.getSlug(n);
        return {
            page: e,
            view: n,
            slug: i,
            renderer: this.getRenderer(i, this.renderers),
            transition: this.getTransition(i, this.transitions)
        }
    }, l.prototype.getLocation = function (t) {
        return {
            href: t,
            anchor: this.getAnchor(t),
            origin: this.getOrigin(t),
            params: this.getParams(t),
            pathname: this.getPathname(t)
        }
    };
    var h = function (t) {
            function e(e) {
                var n = this;
                void 0 === e && (e = {});
                var i = e.renderers,
                    r = e.transitions;
                t.call(this), this.Helpers = new l(i, r), this.Transitions = r, this.Contextual = !1, this.location = this.Helpers.getLocation(window.location.href), this.properties = this.Helpers.getProperties(document.cloneNode(!0)), this.popping = !1, this.running = !1, this.trigger = null, this.cache = new Map, this.cache.set(this.location.href, this.properties), this.properties.renderer.then((function (t) {
                    n.From = new t(n.properties), n.From.setup()
                })), this._navigate = this.navigate.bind(this), window.addEventListener("popstate", this.popState.bind(this)), this.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), this.attach(this.links)
            }
            return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.attach = function (t) {
                for (var e = 0, n = t; e < n.length; e += 1) n[e].addEventListener("click", this._navigate)
            }, e.prototype.detach = function (t) {
                for (var e = 0, n = t; e < n.length; e += 1) n[e].removeEventListener("click", this._navigate)
            }, e.prototype.navigate = function (t) {
                if (!t.metaKey && !t.ctrlKey) {
                    t.preventDefault();
                    var e = !!t.currentTarget.hasAttribute("data-transition") && t.currentTarget.dataset.transition;
                    this.redirect(t.currentTarget.href, e, t.currentTarget)
                }
            }, e.prototype.redirect = function (t, e, n) {
                if (void 0 === e && (e = !1), void 0 === n && (n = "script"), this.trigger = n, !this.running && t !== this.location.href) {
                    var i = this.Helpers.getLocation(t);
                    this.Contextual = !1, e && (this.Contextual = this.Transitions.contextual[e].prototype, this.Contextual.name = e), i.origin !== this.location.origin || i.anchor && i.pathname === this.location.pathname ? window.location.href = t : (this.location = i, this.beforeFetch())
                }
            }, e.prototype.popState = function () {
                this.trigger = "popstate", this.Contextual = !1;
                var t = this.Helpers.getLocation(window.location.href);
                this.location.pathname !== t.pathname || !this.location.anchor && !t.anchor ? (this.popping = !0, this.location = t, this.beforeFetch()) : this.location = t
            }, e.prototype.pushState = function () {
                this.popping || window.history.pushState(this.location, "", this.location.href)
            }, e.prototype.fetch = function () {
                try {
                    var t = this;
                    return Promise.resolve(fetch(t.location.href, {
                        mode: "same-origin",
                        method: "GET",
                        headers: {
                            "X-Requested-With": "Highway"
                        },
                        credentials: "same-origin"
                    })).then((function (e) {
                        if (e.status >= 200 && e.status < 300) return e.text();
                        window.location.href = t.location.href
                    }))
                } catch (t) {
                    return Promise.reject(t)
                }
            }, e.prototype.beforeFetch = function () {
                try {
                    var t = this;

                    function e() {
                        t.afterFetch()
                    }
                    t.pushState(), t.running = !0, t.emit("NAVIGATE_OUT", {
                        from: {
                            page: t.From.properties.page,
                            view: t.From.properties.view
                        },
                        trigger: t.trigger,
                        location: t.location
                    });
                    var n = {
                            trigger: t.trigger,
                            contextual: t.Contextual
                        },
                        i = t.cache.has(t.location.href) ? Promise.resolve(t.From.hide(n)).then((function () {
                            t.properties = t.cache.get(t.location.href)
                        })) : Promise.resolve(Promise.all([t.fetch(), t.From.hide(n)])).then((function (e) {
                            t.properties = t.Helpers.getProperties(e[0]), t.cache.set(t.location.href, t.properties)
                        }));
                    return Promise.resolve(i && i.then ? i.then(e) : e())
                } catch (t) {
                    return Promise.reject(t)
                }
            }, e.prototype.afterFetch = function () {
                try {
                    var t = this;
                    return Promise.resolve(t.properties.renderer).then((function (e) {
                        return t.To = new e(t.properties), t.To.add(), t.emit("NAVIGATE_IN", {
                            to: {
                                page: t.To.properties.page,
                                view: t.To.wrap.lastElementChild
                            },
                            trigger: t.trigger,
                            location: t.location
                        }), Promise.resolve(t.To.show({
                            trigger: t.trigger,
                            contextual: t.Contextual
                        })).then((function () {
                            t.popping = !1, t.running = !1, t.detach(t.links), t.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"), t.attach(t.links), t.emit("NAVIGATE_END", {
                                to: {
                                    page: t.To.properties.page,
                                    view: t.To.wrap.lastElementChild
                                },
                                from: {
                                    page: t.From.properties.page,
                                    view: t.From.properties.view
                                },
                                trigger: t.trigger,
                                location: t.location
                            }), t.From = t.To, t.trigger = null
                        }))
                    }))
                } catch (t) {
                    return Promise.reject(t)
                }
            }, e
        }(a),
        u = function (t, e) {
            this.wrap = t, this.name = e
        };
    u.prototype.show = function (t) {
        var e = this,
            n = t.trigger,
            i = t.contextual,
            r = this.wrap.lastElementChild,
            a = this.wrap.firstElementChild;
        return new Promise((function (t) {
            i ? (r.setAttribute("data-transition-in", i.name), r.removeAttribute("data-transition-out", i.name), i.in && i.in({
                to: r,
                from: a,
                trigger: n,
                done: t
            })) : (r.setAttribute("data-transition-in", e.name), r.removeAttribute("data-transition-out", e.name), e.in && e.in({
                to: r,
                from: a,
                trigger: n,
                done: t
            }))
        }))
    }, u.prototype.hide = function (t) {
        var e = this,
            n = t.trigger,
            i = t.contextual,
            r = this.wrap.firstElementChild;
        return new Promise((function (t) {
            i ? (r.setAttribute("data-transition-out", i.name), r.removeAttribute("data-transition-in", i.name), i.out && i.out({
                from: r,
                trigger: n,
                done: t
            })) : (r.setAttribute("data-transition-out", e.name), r.removeAttribute("data-transition-in", e.name), e.out && e.out({
                from: r,
                trigger: n,
                done: t
            }))
        }))
    };
    var c = {
            Core: h,
            Helpers: l,
            Renderer: s,
            Transition: u
        },
        p = n(1),
        f = n.n(p);

    function d(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(t);
            e && (i = i.filter((function (e) {
                return Object.getOwnPropertyDescriptor(t, e).enumerable
            }))), n.push.apply(n, i)
        }
        return n
    }

    function m(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var g = {
        dom: {
            doc: document.documentElement,
            body: document.body,
            scroll: document.querySelector("[data-router-wrapper]"),
            gl: document.querySelector(".js-gl"),
            lastClicked: null
        },
        bounds: {
            ww: window.innerWidth,
            wh: window.innerHeight,
            vh: 0,
            scroll: 0,
            hero: {
                w: 0,
                h: 0
            }
        },
        flags: function (t) {
            for (var e = 1; e < arguments.length; e++) {
                var n = null != arguments[e] ? arguments[e] : {};
                e % 2 ? d(Object(n), !0).forEach((function (e) {
                    m(t, e, n[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : d(Object(n)).forEach((function (e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                }))
            }
            return t
        }({
            locked: !0,
            resize: !1,
            dragging: !1,
            loaded: !1,
            small: window.matchMedia("(max-width: 639px)").matches,
            hover: window.matchMedia("(hover: hover)").matches,
            windows: -1 !== ["Win32", "Win64", "Windows", "WinCE"].indexOf(window.navigator.platform)
        }, f.a.getInfos()),
        addClasses: function () {
            f.a.addClasses(this.dom.body), this.flags.windows && this.dom.body.classList.add("is-windows")
        }
    };

    function v(t, e, n) {
        return t * (1 - n) + e * n
    }
    var y = function (t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document;
            return e.querySelector(t)
        },
        _ = function (t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document;
            return e.querySelectorAll(t)
        };

    function x(t) {
        return t.getBoundingClientRect()
    }

    function b() {
        if (!(this instanceof b)) return new b;
        this.size = 0, this.uid = 0, this.selectors = [], this.selectorObjects = {}, this.indexes = Object.create(this.indexes), this.activeIndexes = []
    }
    var E = window.document.documentElement,
        w = E.matches || E.webkitMatchesSelector || E.mozMatchesSelector || E.oMatchesSelector || E.msMatchesSelector;
    b.prototype.matchesSelector = function (t, e) {
        return w.call(t, e)
    }, b.prototype.querySelectorAll = function (t, e) {
        return e.querySelectorAll(t)
    }, b.prototype.indexes = [];
    var D = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
    b.prototype.indexes.push({
        name: "ID",
        selector: function (t) {
            var e;
            if (e = t.match(D)) return e[0].slice(1)
        },
        element: function (t) {
            if (t.id) return [t.id]
        }
    });
    var M = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
    b.prototype.indexes.push({
        name: "CLASS",
        selector: function (t) {
            var e;
            if (e = t.match(M)) return e[0].slice(1)
        },
        element: function (t) {
            var e = t.className;
            if (e) {
                if ("string" == typeof e) return e.split(/\s/);
                if ("object" == typeof e && "baseVal" in e) return e.baseVal.split(/\s/)
            }
        }
    });
    var S, T = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
    b.prototype.indexes.push({
        name: "TAG",
        selector: function (t) {
            var e;
            if (e = t.match(T)) return e[0].toUpperCase()
        },
        element: function (t) {
            return [t.nodeName.toUpperCase()]
        }
    }), b.prototype.indexes.default = {
        name: "UNIVERSAL",
        selector: function () {
            return !0
        },
        element: function () {
            return [!0]
        }
    }, S = "function" == typeof window.Map ? window.Map : function () {
        function t() {
            this.map = {}
        }
        return t.prototype.get = function (t) {
            return this.map[t + " "]
        }, t.prototype.set = function (t, e) {
            this.map[t + " "] = e
        }, t
    }();
    var A = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g;

    function C(t, e) {
        var n, i, r, a, s, o, l = (t = t.slice(0).concat(t.default)).length,
            h = e,
            u = [];
        do {
            if (A.exec(""), (r = A.exec(h)) && (h = r[3], r[2] || !h))
                for (n = 0; n < l; n++)
                    if (s = (o = t[n]).selector(r[1])) {
                        for (i = u.length, a = !1; i--;)
                            if (u[i].index === o && u[i].key === s) {
                                a = !0;
                                break
                            } a || u.push({
                            index: o,
                            key: s
                        });
                        break
                    }
        } while (r);
        return u
    }

    function P(t, e) {
        var n, i, r;
        for (n = 0, i = t.length; n < i; n++)
            if (r = t[n], e.isPrototypeOf(r)) return r
    }

    function F(t, e) {
        return t.id - e.id
    }
    b.prototype.logDefaultIndexUsed = function () {}, b.prototype.add = function (t, e) {
        var n, i, r, a, s, o, l, h, u = this.activeIndexes,
            c = this.selectors,
            p = this.selectorObjects;
        if ("string" == typeof t) {
            for (p[(n = {
                    id: this.uid++,
                    selector: t,
                    data: e
                }).id] = n, l = C(this.indexes, t), i = 0; i < l.length; i++) a = (h = l[i]).key, (s = P(u, r = h.index)) || ((s = Object.create(r)).map = new S, u.push(s)), r === this.indexes.default && this.logDefaultIndexUsed(n), (o = s.map.get(a)) || (o = [], s.map.set(a, o)), o.push(n);
            this.size++, c.push(t)
        }
    }, b.prototype.remove = function (t, e) {
        if ("string" == typeof t) {
            var n, i, r, a, s, o, l, h, u = this.activeIndexes,
                c = this.selectors = [],
                p = this.selectorObjects,
                f = {},
                d = 1 === arguments.length;
            for (n = C(this.indexes, t), r = 0; r < n.length; r++)
                for (i = n[r], a = u.length; a--;)
                    if (o = u[a], i.index.isPrototypeOf(o)) {
                        if (l = o.map.get(i.key))
                            for (s = l.length; s--;)(h = l[s]).selector !== t || !d && h.data !== e || (l.splice(s, 1), f[h.id] = !0);
                        break
                    } for (r in f) delete p[r], this.size--;
            for (r in p) c.push(p[r].selector)
        }
    }, b.prototype.queryAll = function (t) {
        if (!this.selectors.length) return [];
        var e, n, i, r, a, s, o, l, h = {},
            u = [],
            c = this.querySelectorAll(this.selectors.join(", "), t);
        for (e = 0, i = c.length; e < i; e++)
            for (a = c[e], n = 0, r = (s = this.matches(a)).length; n < r; n++) h[(l = s[n]).id] ? o = h[l.id] : (o = {
                id: l.id,
                selector: l.selector,
                data: l.data,
                elements: []
            }, h[l.id] = o, u.push(o)), o.elements.push(a);
        return u.sort(F)
    }, b.prototype.matches = function (t) {
        if (!t) return [];
        var e, n, i, r, a, s, o, l, h, u, c, p = this.activeIndexes,
            f = {},
            d = [];
        for (e = 0, r = p.length; e < r; e++)
            if (l = (o = p[e]).element(t))
                for (n = 0, a = l.length; n < a; n++)
                    if (h = o.map.get(l[n]))
                        for (i = 0, s = h.length; i < s; i++) !f[c = (u = h[i]).id] && this.matchesSelector(t, u.selector) && (f[c] = !0, d.push(u));
        return d.sort(F)
    };
    const L = {},
        R = {},
        I = ["mouseenter", "mouseleave"];

    function k(t) {
        void 0 === R[t] && (R[t] = [])
    }

    function O(t) {
        return "string" == typeof t ? document.querySelectorAll(t) : t
    }

    function N(t) {
        let e = function (t, e) {
            const n = [];
            let i = e;
            do {
                if (1 !== i.nodeType) break;
                const e = t.matches(i);
                e.length && n.push({
                    delegatedTarget: i,
                    stack: e
                })
            } while (i = i.parentElement);
            return n
        }(L[t.type], t.target);
        if (e.length)
            for (let n = 0; n < e.length; n++)
                for (let i = 0; i < e[n].stack.length; i++) - 1 !== I.indexOf(t.type) ? (B(t, e[n].delegatedTarget), t.target === e[n].delegatedTarget && e[n].stack[i].data(t)) : (B(t, e[n].delegatedTarget), e[n].stack[i].data(t))
    }

    function B(t, e) {
        Object.defineProperty(t, "currentTarget", {
            configurable: !0,
            enumerable: !0,
            value: e
        })
    }

    function z(t) {
        return JSON.parse(JSON.stringify(t))
    }
    var U = new class {
        bindAll(t, e) {
            void 0 === e && (e = Object.getOwnPropertyNames(Object.getPrototypeOf(t)));
            for (let n = 0; n < e.length; n++) t[e[n]] = t[e[n]].bind(t)
        }
        on(t, e, n, i) {
            if ("function" == typeof e && void 0 === n) return k(t), void R[t].push(e);
            const r = t.split(" ");
            for (let t = 0; t < r.length; t++)
                if (e.nodeType && 1 === e.nodeType || e === window || e === document) e.addEventListener(r[t], n, i);
                else {
                    e = O(e);
                    for (let a = 0; a < e.length; a++) e[a].addEventListener(r[t], n, i)
                }
        }
        delegate(t, e, n) {
            const i = t.split(" ");
            for (let t = 0; t < i.length; t++) {
                let r = L[i[t]];
                void 0 === r && (r = new b, L[i[t]] = r, -1 !== I.indexOf(i[t]) ? document.addEventListener(i[t], N, !0) : document.addEventListener(i[t], N)), r.add(e, n)
            }
        }
        off(t, e, n) {
            if (void 0 === e) return void(R[t] = []);
            if ("function" == typeof e) {
                k(t);
                for (let n = 0; n < R[t].length; n++) R[t][n] === e && R[t].splice(n, 1);
                return
            }
            const i = t.split(" ");
            for (let t = 0; t < i.length; t++) {
                const r = L[i[t]];
                if (void 0 === r || (r.remove(e, n), 0 !== r.size))
                    if (void 0 === e.removeEventListener) {
                        e = O(e);
                        for (let r = 0; r < e.length; r++) e[r].removeEventListener(i[t], n)
                    } else e.removeEventListener(i[t], n);
                else delete L[i[t]], document.removeEventListener(i[t], N)
            }
        }
        emit(t, ...e) {
            ! function (t, e) {
                if (R[t])
                    for (let n = 0; n < R[t].length; n++) R[t][n](...e)
            }(t, e)
        }
        debugDelegated() {
            return z(L)
        }
        debugBus() {
            return z(R)
        }
    };

    function V(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function G(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function H(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var j = 37,
        W = 38,
        X = 39,
        q = 40,
        Y = 32,
        Z = "ontouchstart" in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,
        J = "onkeydown" in document,
        K = g.flags,
        $ = g.bounds,
        Q = K.windows,
        tt = K.isFirefox,
        et = function () {
            function t() {
                var e = this,
                    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                V(this, t), H(this, "wheel", (function (t) {
                    var n = e.opts,
                        i = n.mm,
                        r = n.fm,
                        a = e.evt;
                    a.deltaY = t.wheelDeltaY || -1 * t.deltaY, tt && 1 == t.deltaMode && (a.deltaY *= r), a.deltaY *= i, e.notify(t)
                })), H(this, "touchStart", (function (t) {
                    var n = t.targetTouches ? t.targetTouches[0] : t;
                    e.touchStartY = n.pageY
                })), H(this, "touchMove", (function (t) {
                    var n = e.opts.tm * 0.1,
                        i = e.evt,
                        r = t.targetTouches ? t.targetTouches[0] : t;
                    i.deltaY = (r.pageY - e.touchStartY) * n, e.touchStartY = r.pageY, e.notify(t)
                })), H(this, "keyDown", (function (t) {
                    if ("INPUT" !== document.activeElement.nodeName) {
                        var n = e.evt,
                            i = e.opts.ks,
                            r = $.wh - 40;
                        switch (n.deltaY = 0, t.keyCode) {
                            case j:
                            case W:
                                n.deltaY = i;
                                break;
                            case X:
                            case q:
                                n.deltaY = -i;
                                break;
                            case Y && t.shiftKey:
                                n.deltaY = r;
                                break;
                            case Y:
                                n.deltaY = -r;
                                break;
                            default:
                                return
                        }
                        e.notify(t)
                    }
                })), this.el = window, this.opts = Object.assign({
                    mm: Q ? 1.1 : .45,
                    tm: 2.75,
                    fm: Q ? 40 : 90,
                    ks: 120
                }, n), this.evt = {
                    y: 0,
                    deltaY: 0
                }, this.touchStartY = null, this.init()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function () {
                    this.notify(), this.addEvents()
                }
            }, {
                key: "addEvents",
                value: function () {
                    U.on("wheel", this.el, this.wheel, {
                        passive: !0
                    }), Z && (U.on("touchstart", this.el, this.touchStart, {
                        passive: !0
                    }), U.on("touchmove", this.el, this.touchMove, {
                        passive: !0
                    })), J && U.on("keydown", document, this.keyDown)
                }
            }, {
                key: "notify",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                        e = this.evt;
                    e.y += e.deltaY, U.emit("vs", {
                        y: e.y,
                        deltaY: e.deltaY,
                        originalEvent: t
                    })
                }
            }]) && G(e.prototype, n), i && G(e, i), t
        }();
    var nt = g.flags;
    new function t() {
        var e, n, i;
        ! function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }(this, t), i = function (t) {
            var e = t.deltaY;
            nt.locked || (Cu.run(), U.emit("scroll", {
                y: -1 * e
            }))
        }, (n = "onVS") in (e = this) ? Object.defineProperty(e, n, {
            value: i,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[n] = i, nt.isDesktop && (new et, U.on("vs", this.onVS))
    };

    function it(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function rt(t, e) {
        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
    }
    var at, st, ot, lt, ht, ut, ct, pt, ft, dt, mt, gt, vt, yt, _t, xt, bt, Et, wt, Dt, Mt, St = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        },
        Tt = {
            duration: .5,
            overwrite: !1,
            delay: 0
        },
        At = 1e8,
        Ct = 2 * Math.PI,
        Pt = Ct / 4,
        Ft = 0,
        Lt = Math.sqrt,
        Rt = Math.cos,
        It = Math.sin,
        kt = function (t) {
            return "string" == typeof t
        },
        Ot = function (t) {
            return "function" == typeof t
        },
        Nt = function (t) {
            return "number" == typeof t
        },
        Bt = function (t) {
            return void 0 === t
        },
        zt = function (t) {
            return "object" == typeof t
        },
        Ut = function (t) {
            return !1 !== t
        },
        Vt = function () {
            return "undefined" != typeof window
        },
        Gt = function (t) {
            return Ot(t) || kt(t)
        },
        Ht = Array.isArray,
        jt = /(?:-?\.?\d|\.)+/gi,
        Wt = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g,
        Xt = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        qt = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi,
        Yt = /\(([^()]+)\)/i,
        Zt = /[+-]=-?[\.\d]+/,
        Jt = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
        Kt = {},
        $t = {},
        Qt = function (t) {
            return ($t = Me(t, Kt)) && ai
        },
        te = function (t, e) {
            return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
        },
        ee = function (t, e) {
            return !e && console.warn(t)
        },
        ne = function (t, e) {
            return t && (Kt[t] = e) && $t && ($t[t] = e) || Kt
        },
        ie = function () {
            return 0
        },
        re = {},
        ae = [],
        se = {},
        oe = {},
        le = {},
        he = 30,
        ue = [],
        ce = "",
        pe = function (t) {
            var e, n, i = t[0];
            if (zt(i) || Ot(i) || (t = [t]), !(e = (i._gsap || {}).harness)) {
                for (n = ue.length; n-- && !ue[n].targetTest(i););
                e = ue[n]
            }
            for (n = t.length; n--;) t[n] && (t[n]._gsap || (t[n]._gsap = new Pn(t[n], e))) || t.splice(n, 1);
            return t
        },
        fe = function (t) {
            return t._gsap || pe(Je(t))[0]._gsap
        },
        de = function (t, e) {
            var n = t[e];
            return Ot(n) ? t[e]() : Bt(n) && t.getAttribute(e) || n
        },
        me = function (t, e) {
            return (t = t.split(",")).forEach(e) || t
        },
        ge = function (t) {
            return Math.round(1e5 * t) / 1e5 || 0
        },
        ve = function (t, e) {
            for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;);
            return i < n
        },
        ye = function (t, e, n) {
            var i, r = Nt(t[1]),
                a = (r ? 2 : 1) + (e < 2 ? 0 : 1),
                s = t[a];
            if (r && (s.duration = t[1]), s.parent = n, e) {
                for (i = s; n && !("immediateRender" in i);) i = n.vars.defaults || {}, n = Ut(n.vars.inherit) && n.parent;
                s.immediateRender = Ut(i.immediateRender), e < 2 ? s.runBackwards = 1 : s.startAt = t[a - 1]
            }
            return s
        },
        _e = function () {
            var t, e, n = ae.length,
                i = ae.slice(0);
            for (se = {}, ae.length = 0, t = 0; t < n; t++)(e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
        },
        xe = function (t, e, n, i) {
            ae.length && _e(), t.render(e, n, i), ae.length && _e()
        },
        be = function (t) {
            var e = parseFloat(t);
            return (e || 0 === e) && (t + "").match(Jt).length < 2 ? e : t
        },
        Ee = function (t) {
            return t
        },
        we = function (t, e) {
            for (var n in e) n in t || (t[n] = e[n]);
            return t
        },
        De = function (t, e) {
            for (var n in e) n in t || "duration" === n || "ease" === n || (t[n] = e[n])
        },
        Me = function (t, e) {
            for (var n in e) t[n] = e[n];
            return t
        },
        Se = function t(e, n) {
            for (var i in n) e[i] = zt(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i];
            return e
        },
        Te = function (t, e) {
            var n, i = {};
            for (n in t) n in e || (i[n] = t[n]);
            return i
        },
        Ae = function (t) {
            var e = t.parent || at,
                n = t.keyframes ? De : we;
            if (Ut(t.inherit))
                for (; e;) n(t, e.vars.defaults), e = e.parent;
            return t
        },
        Ce = function (t, e, n, i) {
            void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
            var r = e._prev,
                a = e._next;
            r ? r._next = a : t[n] === e && (t[n] = a), a ? a._prev = r : t[i] === e && (t[i] = r), e._next = e._prev = e.parent = null
        },
        Pe = function (t, e) {
            !t.parent || e && !t.parent.autoRemoveChildren || t.parent.remove(t), t._act = 0
        },
        Fe = function (t) {
            for (var e = t; e;) e._dirty = 1, e = e.parent;
            return t
        },
        Le = function (t) {
            for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
            return t
        },
        Re = function (t) {
            return t._repeat ? Ie(t._tTime, t = t.duration() + t._rDelay) * t : 0
        },
        Ie = function (t, e) {
            return (t /= e) && ~~t === t ? ~~t - 1 : ~~t
        },
        ke = function (t, e) {
            return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
        },
        Oe = function (t) {
            return t._end = ge(t._start + (t._tDur / Math.abs(t._ts || t._rts || 1e-8) || 0))
        },
        Ne = function (t, e) {
            var n;
            if ((e._time || e._initted && !e._dur) && (n = ke(t.rawTime(), e), (!e._dur || We(0, e.totalDuration(), n) - e._tTime > 1e-8) && e.render(n, !0)), Fe(t)._dp && t._initted && t._time >= t._dur && t._ts) {
                if (t._dur < t.duration())
                    for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                t._zTime = -1e-8
            }
        },
        Be = function (t, e, n, i) {
            return e.parent && Pe(e), e._start = ge(n + e._delay), e._end = ge(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
                function (t, e, n, i, r) {
                    void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                    var a, s = t[i];
                    if (r)
                        for (a = e[r]; s && s[r] > a;) s = s._prev;
                    s ? (e._next = s._next, s._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = s, e.parent = e._dp = t
                }(t, e, "_first", "_last", t._sort ? "_start" : 0), t._recent = e, i || Ne(t, e), t
        },
        ze = function (t, e, n, i) {
            return Nn(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && ut !== yn.frame ? (ae.push(t), t._lazy = [e, i], 1) : void 0 : 1
        },
        Ue = function (t, e, n) {
            var i = t._repeat,
                r = ge(e) || 0;
            return t._dur = r, t._tDur = i ? i < 0 ? 1e12 : ge(r * (i + 1) + t._rDelay * i) : r, t._time > r && (t._time = r, t._tTime = Math.min(t._tTime, t._tDur)), !n && Fe(t.parent), t.parent && Oe(t), t
        },
        Ve = function (t) {
            return t instanceof Ln ? Fe(t) : Ue(t, t._dur)
        },
        Ge = {
            _start: 0,
            endTime: ie
        },
        He = function t(e, n) {
            var i, r, a = e.labels,
                s = e._recent || Ge,
                o = e.duration() >= At ? s.endTime(!1) : e._dur;
            return kt(n) && (isNaN(n) || n in a) ? "<" === (i = n.charAt(0)) || ">" === i ? ("<" === i ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) : (i = n.indexOf("=")) < 0 ? (n in a || (a[n] = o), a[n]) : (r = +(n.charAt(i - 1) + n.substr(i + 1)), i > 1 ? t(e, n.substr(0, i - 1)) + r : o + r) : null == n ? o : +n
        },
        je = function (t, e) {
            return t || 0 === t ? e(t) : e
        },
        We = function (t, e, n) {
            return n < t ? t : n > e ? e : n
        },
        Xe = function (t) {
            return (t + "").substr((parseFloat(t) + "").length)
        },
        qe = [].slice,
        Ye = function (t, e) {
            return t && zt(t) && "length" in t && (!e && !t.length || t.length - 1 in t && zt(t[0])) && !t.nodeType && t !== st
        },
        Ze = function (t, e, n) {
            return void 0 === n && (n = []), t.forEach((function (t) {
                var i;
                return kt(t) && !e || Ye(t, 1) ? (i = n).push.apply(i, Je(t)) : n.push(t)
            })) || n
        },
        Je = function (t, e) {
            return !kt(t) || e || !ot && _n() ? Ht(t) ? Ze(t, e) : Ye(t) ? qe.call(t, 0) : t ? [t] : [] : qe.call(lt.querySelectorAll(t), 0)
        },
        Ke = function (t) {
            return t.sort((function () {
                return .5 - Math.random()
            }))
        },
        $e = function (t) {
            if (Ot(t)) return t;
            var e = zt(t) ? t : {
                    each: t
                },
                n = Mn(e.ease),
                i = e.from || 0,
                r = parseFloat(e.base) || 0,
                a = {},
                s = i > 0 && i < 1,
                o = isNaN(i) || s,
                l = e.axis,
                h = i,
                u = i;
            return kt(i) ? h = u = {
                    center: .5,
                    edges: .5,
                    end: 1
                } [i] || 0 : !s && o && (h = i[0], u = i[1]),
                function (t, s, c) {
                    var p, f, d, m, g, v, y, _, x, b = (c || e).length,
                        E = a[b];
                    if (!E) {
                        if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, At])[1])) {
                            for (y = -At; y < (y = c[x++].getBoundingClientRect().left) && x < b;);
                            x--
                        }
                        for (E = a[b] = [], p = o ? Math.min(x, b) * h - .5 : i % x, f = o ? b * u / x - .5 : i / x | 0, y = 0, _ = At, v = 0; v < b; v++) d = v % x - p, m = f - (v / x | 0), E[v] = g = l ? Math.abs("y" === l ? m : d) : Lt(d * d + m * m), g > y && (y = g), g < _ && (_ = g);
                        "random" === i && Ke(E), E.max = y - _, E.min = _, E.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (x > b ? b - 1 : l ? "y" === l ? b / x : x : Math.max(x, b / x)) || 0) * ("edges" === i ? -1 : 1), E.b = b < 0 ? r - b : r, E.u = Xe(e.amount || e.each) || 0, n = n && b < 0 ? Dn(n) : n
                    }
                    return b = (E[t] - E.min) / E.max || 0, ge(E.b + (n ? n(b) : b) * E.v) + E.u
                }
        },
        Qe = function (t) {
            var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
            return function (n) {
                return ~~(Math.round(parseFloat(n) / t) * t * e) / e + (Nt(n) ? 0 : Xe(n))
            }
        },
        tn = function (t, e) {
            var n, i, r = Ht(t);
            return !r && zt(t) && (n = r = t.radius || At, t.values ? (t = Je(t.values), (i = !Nt(t[0])) && (n *= n)) : t = Qe(t.increment)), je(e, r ? Ot(t) ? function (e) {
                return i = t(e), Math.abs(i - e) <= n ? i : e
            } : function (e) {
                for (var r, a, s = parseFloat(i ? e.x : e), o = parseFloat(i ? e.y : 0), l = At, h = 0, u = t.length; u--;)(r = i ? (r = t[u].x - s) * r + (a = t[u].y - o) * a : Math.abs(t[u] - s)) < l && (l = r, h = u);
                return h = !n || l <= n ? t[h] : e, i || h === e || Nt(e) ? h : h + Xe(e)
            } : Qe(t))
        },
        en = function (t, e, n, i) {
            return je(Ht(t) ? !e : !0 === n ? !!(n = 0) : !i, (function () {
                return Ht(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && ~~(Math.round((t + Math.random() * (e - t)) / n) * n * i) / i
            }))
        },
        nn = function (t, e, n) {
            return je(n, (function (n) {
                return t[~~e(n)]
            }))
        },
        rn = function (t) {
            for (var e, n, i, r, a = 0, s = ""; ~(e = t.indexOf("random(", a));) i = t.indexOf(")", e), r = "[" === t.charAt(e + 7), n = t.substr(e + 7, i - e - 7).match(r ? Jt : jt), s += t.substr(a, e - a) + en(r ? n : +n[0], +n[1], +n[2] || 1e-5), a = i + 1;
            return s + t.substr(a, t.length - a)
        },
        an = function (t, e, n, i, r) {
            var a = e - t,
                s = i - n;
            return je(r, (function (e) {
                return n + (e - t) / a * s
            }))
        },
        sn = function (t, e, n) {
            var i, r, a, s = t.labels,
                o = At;
            for (i in s)(r = s[i] - e) < 0 == !!n && r && o > (r = Math.abs(r)) && (a = i, o = r);
            return a
        },
        on = function (t, e, n) {
            var i, r, a = t.vars,
                s = a[e];
            if (s) return i = a[e + "Params"], r = a.callbackScope || t, n && ae.length && _e(), i ? s.apply(r, i) : s.call(r)
        },
        ln = function (t) {
            return Pe(t), t.progress() < 1 && on(t, "onInterrupt"), t
        },
        hn = function (t) {
            var e = (t = !t.name && t.default || t).name,
                n = Ot(t),
                i = e && !n && t.init ? function () {
                    this._props = []
                } : t,
                r = {
                    init: ie,
                    render: Jn,
                    add: kn,
                    kill: $n,
                    modifier: Kn,
                    rawVars: 0
                },
                a = {
                    targetTest: 0,
                    get: 0,
                    getSetter: Xn,
                    aliases: {},
                    register: 0
                };
            if (_n(), t !== i) {
                if (oe[e]) return;
                we(i, we(Te(t, r), a)), Me(i.prototype, Me(r, Te(t, a))), oe[i.prop = e] = i, t.targetTest && (ue.push(i), re[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
            }
            ne(e, i), t.register && t.register(ai, i, ei)
        },
        un = {
            aqua: [0, 255, 255],
            lime: [0, 255, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, 255],
            navy: [0, 0, 128],
            white: [255, 255, 255],
            olive: [128, 128, 0],
            yellow: [255, 255, 0],
            orange: [255, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [255, 0, 0],
            pink: [255, 192, 203],
            cyan: [0, 255, 255],
            transparent: [255, 255, 255, 0]
        },
        cn = function (t, e, n) {
            return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) + .5 | 0
        },
        pn = function (t, e, n) {
            var i, r, a, s, o, l, h, u, c, p, f = t ? Nt(t) ? [t >> 16, t >> 8 & 255, 255 & t] : 0 : un.black;
            if (!f) {
                if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), un[t]) f = un[t];
                else if ("#" === t.charAt(0)) 4 === t.length && (i = t.charAt(1), r = t.charAt(2), a = t.charAt(3), t = "#" + i + i + r + r + a + a), f = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                else if ("hsl" === t.substr(0, 3))
                    if (f = p = t.match(jt), e) {
                        if (~t.indexOf("=")) return f = t.match(Wt), n && f.length < 4 && (f[3] = 1), f
                    } else s = +f[0] % 360 / 360, o = +f[1] / 100, i = 2 * (l = +f[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o), f.length > 3 && (f[3] *= 1), f[0] = cn(s + 1 / 3, i, r), f[1] = cn(s, i, r), f[2] = cn(s - 1 / 3, i, r);
                else f = t.match(jt) || un.transparent;
                f = f.map(Number)
            }
            return e && !p && (i = f[0] / 255, r = f[1] / 255, a = f[2] / 255, l = ((h = Math.max(i, r, a)) + (u = Math.min(i, r, a))) / 2, h === u ? s = o = 0 : (c = h - u, o = l > .5 ? c / (2 - h - u) : c / (h + u), s = h === i ? (r - a) / c + (r < a ? 6 : 0) : h === r ? (a - i) / c + 2 : (i - r) / c + 4, s *= 60), f[0] = ~~(s + .5), f[1] = ~~(100 * o + .5), f[2] = ~~(100 * l + .5)), n && f.length < 4 && (f[3] = 1), f
        },
        fn = function (t) {
            var e = [],
                n = [],
                i = -1;
            return t.split(mn).forEach((function (t) {
                var r = t.match(Xt) || [];
                e.push.apply(e, r), n.push(i += r.length + 1)
            })), e.c = n, e
        },
        dn = function (t, e, n) {
            var i, r, a, s, o = "",
                l = (t + o).match(mn),
                h = e ? "hsla(" : "rgba(",
                u = 0;
            if (!l) return t;
            if (l = l.map((function (t) {
                    return (t = pn(t, e, 1)) && h + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                })), n && (a = fn(t), (i = n.c).join(o) !== a.c.join(o)))
                for (s = (r = t.replace(mn, "1").split(Xt)).length - 1; u < s; u++) o += r[u] + (~i.indexOf(u) ? l.shift() || h + "0,0,0,0)" : (a.length ? a : l.length ? l : n).shift());
            if (!r)
                for (s = (r = t.split(mn)).length - 1; u < s; u++) o += r[u] + l[u];
            return o + r[s]
        },
        mn = function () {
            var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
            for (t in un) e += "|" + t + "\\b";
            return new RegExp(e + ")", "gi")
        }(),
        gn = /hsl[a]?\(/,
        vn = function (t) {
            var e, n = t.join(" ");
            if (mn.lastIndex = 0, mn.test(n)) return e = gn.test(n), t[1] = dn(t[1], e), t[0] = dn(t[0], e, fn(t[1])), !0
        },
        yn = (vt = Date.now, yt = 500, _t = 33, xt = vt(), bt = xt, wt = Et = 1 / 240, Mt = function t(e) {
            var n, i, r = vt() - bt,
                a = !0 === e;
            r > yt && (xt += r - _t), bt += r, gt.time = (bt - xt) / 1e3, ((n = gt.time - wt) > 0 || a) && (gt.frame++, wt += n + (n >= Et ? .004 : Et - n), i = 1), a || (ft = dt(t)), i && Dt.forEach((function (t) {
                return t(gt.time, r, gt.frame, e)
            }))
        }, gt = {
            time: 0,
            frame: 0,
            tick: function () {
                Mt(!0)
            },
            wake: function () {
                ht && (!ot && Vt() && (st = ot = window, lt = st.document || {}, Kt.gsap = ai, (st.gsapVersions || (st.gsapVersions = [])).push(ai.version), Qt($t || st.GreenSockGlobals || !st.gsap && st || {}), mt = st.requestAnimationFrame), ft && gt.sleep(), dt = mt || function (t) {
                    return setTimeout(t, 1e3 * (wt - gt.time) + 1 | 0)
                }, pt = 1, Mt(2))
            },
            sleep: function () {
                (mt ? st.cancelAnimationFrame : clearTimeout)(ft), pt = 0, dt = ie
            },
            lagSmoothing: function (t, e) {
                yt = t || 1 / 1e-8, _t = Math.min(e, yt, 0)
            },
            fps: function (t) {
                Et = 1 / (t || 240), wt = gt.time + Et
            },
            add: function (t) {
                Dt.indexOf(t) < 0 && Dt.push(t), _n()
            },
            remove: function (t) {
                var e;
                ~(e = Dt.indexOf(t)) && Dt.splice(e, 1)
            },
            _listeners: Dt = []
        }),
        _n = function () {
            return !pt && yn.wake()
        },
        xn = {},
        bn = /^[\d.\-M][\d.\-,\s]/,
        En = /["']/g,
        wn = function (t) {
            for (var e, n, i, r = {}, a = t.substr(1, t.length - 3).split(":"), s = a[0], o = 1, l = a.length; o < l; o++) n = a[o], e = o !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, e), r[s] = isNaN(i) ? i.replace(En, "").trim() : +i, s = n.substr(e + 1).trim();
            return r
        },
        Dn = function (t) {
            return function (e) {
                return 1 - t(1 - e)
            }
        },
        Mn = function (t, e) {
            return t && (Ot(t) ? t : xn[t] || function (t) {
                var e = (t + "").split("("),
                    n = xn[e[0]];
                return n && e.length > 1 && n.config ? n.config.apply(null, ~t.indexOf("{") ? [wn(e[1])] : Yt.exec(t)[1].split(",").map(be)) : xn._CE && bn.test(t) ? xn._CE("", t) : n
            }(t)) || e
        },
        Sn = function (t, e, n, i) {
            void 0 === n && (n = function (t) {
                return 1 - e(1 - t)
            }), void 0 === i && (i = function (t) {
                return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
            });
            var r, a = {
                easeIn: e,
                easeOut: n,
                easeInOut: i
            };
            return me(t, (function (t) {
                for (var e in xn[t] = Kt[t] = a, xn[r = t.toLowerCase()] = n, a) xn[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = xn[t + "." + e] = a[e]
            })), a
        },
        Tn = function (t) {
            return function (e) {
                return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
            }
        },
        An = function t(e, n, i) {
            var r = n >= 1 ? n : 1,
                a = (i || (e ? .3 : .45)) / (n < 1 ? n : 1),
                s = a / Ct * (Math.asin(1 / r) || 0),
                o = function (t) {
                    return 1 === t ? 1 : r * Math.pow(2, -10 * t) * It((t - s) * a) + 1
                },
                l = "out" === e ? o : "in" === e ? function (t) {
                    return 1 - o(1 - t)
                } : Tn(o);
            return a = Ct / a, l.config = function (n, i) {
                return t(e, n, i)
            }, l
        },
        Cn = function t(e, n) {
            void 0 === n && (n = 1.70158);
            var i = function (t) {
                    return t ? --t * t * ((n + 1) * t + n) + 1 : 0
                },
                r = "out" === e ? i : "in" === e ? function (t) {
                    return 1 - i(1 - t)
                } : Tn(i);
            return r.config = function (n) {
                return t(e, n)
            }, r
        };
    me("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) {
            var n = e < 5 ? e + 1 : e;
            Sn(t + ",Power" + (n - 1), e ? function (t) {
                return Math.pow(t, n)
            } : function (t) {
                return t
            }, (function (t) {
                return 1 - Math.pow(1 - t, n)
            }), (function (t) {
                return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
            }))
        })), xn.Linear.easeNone = xn.none = xn.Linear.easeIn, Sn("Elastic", An("in"), An("out"), An()),
        function (t, e) {
            var n = 1 / e,
                i = function (i) {
                    return i < n ? t * i * i : i < .7272727272727273 ? t * Math.pow(i - 1.5 / e, 2) + .75 : i < .9090909090909092 ? t * (i -= 2.25 / e) * i + .9375 : t * Math.pow(i - 2.625 / e, 2) + .984375
                };
            Sn("Bounce", (function (t) {
                return 1 - i(1 - t)
            }), i)
        }(7.5625, 2.75), Sn("Expo", (function (t) {
            return t ? Math.pow(2, 10 * (t - 1)) : 0
        })), Sn("Circ", (function (t) {
            return -(Lt(1 - t * t) - 1)
        })), Sn("Sine", (function (t) {
            return 1 - Rt(t * Pt)
        })), Sn("Back", Cn("in"), Cn("out"), Cn()), xn.SteppedEase = xn.steps = Kt.SteppedEase = {
            config: function (t, e) {
                void 0 === t && (t = 1);
                var n = 1 / t,
                    i = t + (e ? 0 : 1),
                    r = e ? 1 : 0;
                return function (t) {
                    return ((i * We(0, 1 - 1e-8, t) | 0) + r) * n
                }
            }
        }, Tt.ease = xn["quad.out"], me("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (t) {
            return ce += t + "," + t + "Params,"
        }));
    var Pn = function (t, e) {
            this.id = Ft++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : de, this.set = e ? e.getSetter : Xn
        },
        Fn = function () {
            function t(t, e) {
                var n = t.parent || at;
                this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Ue(this, +t.duration, 1), this.data = t.data, pt || yn.wake(), n && Be(n, this, e || 0 === e ? e : n._time, 1), t.reversed && this.reverse(), t.paused && this.paused(!0)
            }
            var e = t.prototype;
            return e.delay = function (t) {
                return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
            }, e.duration = function (t) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
            }, e.totalDuration = function (t) {
                return arguments.length ? (this._dirty = 0, Ue(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }, e.totalTime = function (t, e) {
                if (_n(), !arguments.length) return this._tTime;
                var n = this.parent || this._dp;
                if (n && n.smoothChildTiming && this._ts) {
                    for (this._start = ge(n._time - (this._ts > 0 ? t / this._ts : ((this._dirty ? this.totalDuration() : this._tDur) - t) / -this._ts)), Oe(this), n._dirty || Fe(n); n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                    !this.parent && this._dp.autoRemoveChildren && Be(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== t || !this._dur && !e || this._initted && 1e-8 === Math.abs(this._zTime)) && (this._ts || (this._pTime = t), xe(this, t, e)), this
            }, e.time = function (t, e) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Re(this)) % this._dur || (t ? this._dur : 0), e) : this._time
            }, e.totalProgress = function (t, e) {
                return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
            }, e.progress = function (t, e) {
                return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Re(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
            }, e.iteration = function (t, e) {
                var n = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Ie(this._tTime, n) + 1 : 1
            }, e.timeScale = function (t) {
                if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                if (this._rts === t) return this;
                var e = this.parent && this._ts ? ke(this.parent._time, this) : this._tTime;
                return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, Le(this.totalTime(We(0, this._tDur, e), !0))
            }, e.paused = function (t) {
                return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (_n(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= 1e-8) && 1e-8 !== Math.abs(this._zTime)))), this) : this._ps
            }, e.startTime = function (t) {
                if (arguments.length) {
                    this._start = t;
                    var e = this.parent || this._dp;
                    return e && (e._sort || !this.parent) && Be(e, this, t - this._delay), this
                }
                return this._start
            }, e.endTime = function (t) {
                return this._start + (Ut(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
            }, e.rawTime = function (t) {
                var e = this.parent || this._dp;
                return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? ke(e.rawTime(t), this) : this._tTime : this._tTime
            }, e.repeat = function (t) {
                return arguments.length ? (this._repeat = t, Ve(this)) : this._repeat
            }, e.repeatDelay = function (t) {
                return arguments.length ? (this._rDelay = t, Ve(this)) : this._rDelay
            }, e.yoyo = function (t) {
                return arguments.length ? (this._yoyo = t, this) : this._yoyo
            }, e.seek = function (t, e) {
                return this.totalTime(He(this, t), Ut(e))
            }, e.restart = function (t, e) {
                return this.play().totalTime(t ? -this._delay : 0, Ut(e))
            }, e.play = function (t, e) {
                return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
            }, e.reverse = function (t, e) {
                return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
            }, e.pause = function (t, e) {
                return null != t && this.seek(t, e), this.paused(!0)
            }, e.resume = function () {
                return this.paused(!1)
            }, e.reversed = function (t) {
                return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
            }, e.invalidate = function () {
                return this._initted = 0, this._zTime = -1e-8, this
            }, e.isActive = function (t) {
                var e, n = this.parent || this._dp,
                    i = this._start;
                return !(n && !(this._ts && (this._initted || !t) && n.isActive(t) && (e = n.rawTime(!0)) >= i && e < this.endTime(!0) - 1e-8))
            }, e.eventCallback = function (t, e, n) {
                var i = this.vars;
                return arguments.length > 1 ? (e ? (i[t] = e, n && (i[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t]
            }, e.then = function (t) {
                var e = this;
                return new Promise((function (n) {
                    var i = Ot(t) ? t : Ee,
                        r = function () {
                            var t = e.then;
                            e.then = null, Ot(i) && (i = i(e)) && (i.then || i === e) && (e.then = t), n(i), e.then = t
                        };
                    e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
                }))
            }, e.kill = function () {
                ln(this)
            }, t
        }();
    we(Fn.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var Ln = function (t) {
        function e(e, n) {
            var i;
            return void 0 === e && (e = {}), (i = t.call(this, e, n) || this).labels = {}, i.smoothChildTiming = !!e.smoothChildTiming, i.autoRemoveChildren = !!e.autoRemoveChildren, i._sort = Ut(e.sortChildren), i.parent && Ne(i.parent, it(i)), i
        }
        rt(e, t);
        var n = e.prototype;
        return n.to = function (t, e, n) {
            return new Vn(t, ye(arguments, 0, this), He(this, Nt(e) ? arguments[3] : n)), this
        }, n.from = function (t, e, n) {
            return new Vn(t, ye(arguments, 1, this), He(this, Nt(e) ? arguments[3] : n)), this
        }, n.fromTo = function (t, e, n, i) {
            return new Vn(t, ye(arguments, 2, this), He(this, Nt(e) ? arguments[4] : i)), this
        }, n.set = function (t, e, n) {
            return e.duration = 0, e.parent = this, Ae(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new Vn(t, e, He(this, n), 1), this
        }, n.call = function (t, e, n) {
            return Be(this, Vn.delayedCall(0, t, e), He(this, n))
        }, n.staggerTo = function (t, e, n, i, r, a, s) {
            return n.duration = e, n.stagger = n.stagger || i, n.onComplete = a, n.onCompleteParams = s, n.parent = this, new Vn(t, n, He(this, r)), this
        }, n.staggerFrom = function (t, e, n, i, r, a, s) {
            return n.runBackwards = 1, Ae(n).immediateRender = Ut(n.immediateRender), this.staggerTo(t, e, n, i, r, a, s)
        }, n.staggerFromTo = function (t, e, n, i, r, a, s, o) {
            return i.startAt = n, Ae(i).immediateRender = Ut(i.immediateRender), this.staggerTo(t, e, i, r, a, s, o)
        }, n.render = function (t, e, n) {
            var i, r, a, s, o, l, h, u, c, p, f, d, m = this._time,
                g = this._dirty ? this.totalDuration() : this._tDur,
                v = this._dur,
                y = this !== at && t > g - 1e-8 && t >= 0 ? g : t < 1e-8 ? 0 : t,
                _ = this._zTime < 0 != t < 0 && (this._initted || !v);
            if (y !== this._tTime || n || _) {
                if (m !== this._time && v && (y += this._time - m, t += this._time - m), i = y, c = this._start, l = !(u = this._ts), _ && (v || (m = this._zTime), !t && e || (this._zTime = t)), this._repeat && (f = this._yoyo, o = v + this._rDelay, ((i = ge(y % o)) > v || g === y) && (i = v), (s = ~~(y / o)) && s === y / o && (i = v, s--), f && 1 & s && (i = v - i, d = 1), s !== (p = Ie(this._tTime, o)) && !this._lock)) {
                    var x = f && 1 & p,
                        b = x === (f && 1 & s);
                    if (s < p && (x = !x), m = x ? 0 : v, this._lock = 1, this.render(m, e, !v)._lock = 0, !e && this.parent && on(this, "onRepeat"), this.vars.repeatRefresh && !d && (this.invalidate()._lock = 1), m !== this._time || l !== !this._ts) return this;
                    if (b && (this._lock = 2, m = x ? v + 1e-4 : -1e-4, this.render(m, !0), this.vars.repeatRefresh && !d && this.invalidate()), this._lock = 0, !this._ts && !l) return this
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (h = function (t, e, n) {
                        var i;
                        if (n > e)
                            for (i = t._first; i && i._start <= n;) {
                                if (!i._dur && "isPause" === i.data && i._start > e) return i;
                                i = i._next
                            } else
                                for (i = t._last; i && i._start >= n;) {
                                    if (!i._dur && "isPause" === i.data && i._start < e) return i;
                                    i = i._prev
                                }
                    }(this, ge(m), ge(i))) && (y -= i - (i = h._start)), this._tTime = y, this._time = i, this._act = !u, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t), m || !i || e || on(this, "onStart"), i >= m && t >= 0)
                    for (r = this._first; r;) {
                        if (a = r._next, (r._act || i >= r._start) && r._ts && h !== r) {
                            if (r.parent !== this) return this.render(t, e, n);
                            if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, e, n), i !== this._time || !this._ts && !l) {
                                h = 0, a && (y += this._zTime = -1e-8);
                                break
                            }
                        }
                        r = a
                    } else {
                        r = this._last;
                        for (var E = t < 0 ? t : i; r;) {
                            if (a = r._prev, (r._act || E <= r._end) && r._ts && h !== r) {
                                if (r.parent !== this) return this.render(t, e, n);
                                if (r.render(r._ts > 0 ? (E - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (E - r._start) * r._ts, e, n), i !== this._time || !this._ts && !l) {
                                    h = 0, a && (y += this._zTime = E ? -1e-8 : 1e-8);
                                    break
                                }
                            }
                            r = a
                        }
                    }
                if (h && !e && (this.pause(), h.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1, this._ts)) return this._start = c, Oe(this), this.render(t, e, n);
                this._onUpdate && !e && on(this, "onUpdate", !0), (y === g && g >= this.totalDuration() || !y && this._ts < 0) && (c !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((t || !v) && (t && this._ts > 0 || !y && this._ts < 0) && Pe(this, 1), e || t < 0 && !m || (on(this, y === g ? "onComplete" : "onReverseComplete", !0), this._prom && this._prom())))
            }
            return this
        }, n.add = function (t, e) {
            var n = this;
            if (Nt(e) || (e = He(this, e)), !(t instanceof Fn)) {
                if (Ht(t)) return t.forEach((function (t) {
                    return n.add(t, e)
                })), Fe(this);
                if (kt(t)) return this.addLabel(t, e);
                if (!Ot(t)) return this;
                t = Vn.delayedCall(0, t)
            }
            return this !== t ? Be(this, t, e) : this
        }, n.getChildren = function (t, e, n, i) {
            void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === i && (i = -At);
            for (var r = [], a = this._first; a;) a._start >= i && (a instanceof Vn ? e && r.push(a) : (n && r.push(a), t && r.push.apply(r, a.getChildren(!0, e, n)))), a = a._next;
            return r
        }, n.getById = function (t) {
            for (var e = this.getChildren(1, 1, 1), n = e.length; n--;)
                if (e[n].vars.id === t) return e[n]
        }, n.remove = function (t) {
            return kt(t) ? this.removeLabel(t) : Ot(t) ? this.killTweensOf(t) : (Ce(this, t), t === this._recent && (this._recent = this._last), Fe(this))
        }, n.totalTime = function (e, n) {
            return arguments.length ? (this._forcing = 1, this.parent || this._dp || !this._ts || (this._start = ge(yn.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
        }, n.addLabel = function (t, e) {
            return this.labels[t] = He(this, e), this
        }, n.removeLabel = function (t) {
            return delete this.labels[t], this
        }, n.addPause = function (t, e, n) {
            var i = Vn.delayedCall(0, e || ie, n);
            return i.data = "isPause", this._hasPause = 1, Be(this, i, He(this, t))
        }, n.removePause = function (t) {
            var e = this._first;
            for (t = He(this, t); e;) e._start === t && "isPause" === e.data && Pe(e), e = e._next
        }, n.killTweensOf = function (t, e, n) {
            for (var i = this.getTweensOf(t, n), r = i.length; r--;) Rn !== i[r] && i[r].kill(t, e);
            return this
        }, n.getTweensOf = function (t, e) {
            for (var n, i = [], r = Je(t), a = this._first; a;) a instanceof Vn ? !ve(a._targets, r) || e && !a.isActive("started" === e) || i.push(a) : (n = a.getTweensOf(r, e)).length && i.push.apply(i, n), a = a._next;
            return i
        }, n.tweenTo = function (t, e) {
            e = e || {};
            var n = this,
                i = He(n, t),
                r = e,
                a = r.startAt,
                s = r.onStart,
                o = r.onStartParams,
                l = Vn.to(n, we(e, {
                    ease: "none",
                    lazy: !1,
                    time: i,
                    duration: e.duration || Math.abs((i - (a && "time" in a ? a.time : n._time)) / n.timeScale()) || 1e-8,
                    onStart: function () {
                        n.pause();
                        var t = e.duration || Math.abs((i - n._time) / n.timeScale());
                        l._dur !== t && Ue(l, t).render(l._time, !0, !0), s && s.apply(l, o || [])
                    }
                }));
            return l
        }, n.tweenFromTo = function (t, e, n) {
            return this.tweenTo(e, we({
                startAt: {
                    time: He(this, t)
                }
            }, n))
        }, n.recent = function () {
            return this._recent
        }, n.nextLabel = function (t) {
            return void 0 === t && (t = this._time), sn(this, He(this, t))
        }, n.previousLabel = function (t) {
            return void 0 === t && (t = this._time), sn(this, He(this, t), 1)
        }, n.currentLabel = function (t) {
            return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + 1e-8)
        }, n.shiftChildren = function (t, e, n) {
            void 0 === n && (n = 0);
            for (var i, r = this._first, a = this.labels; r;) r._start >= n && (r._start += t), r = r._next;
            if (e)
                for (i in a) a[i] >= n && (a[i] += t);
            return Fe(this)
        }, n.invalidate = function () {
            var e = this._first;
            for (this._lock = 0; e;) e.invalidate(), e = e._next;
            return t.prototype.invalidate.call(this)
        }, n.clear = function (t) {
            void 0 === t && (t = !0);
            for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
            return this._time = this._tTime = 0, t && (this.labels = {}), Fe(this)
        }, n.totalDuration = function (t) {
            var e, n, i, r, a = 0,
                s = this,
                o = s._last,
                l = At;
            if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -t : t));
            if (s._dirty) {
                for (r = s.parent; o;) e = o._prev, o._dirty && o.totalDuration(), (i = o._start) > l && s._sort && o._ts && !s._lock ? (s._lock = 1, Be(s, o, i - o._delay, 1)._lock = 0) : l = i, i < 0 && o._ts && (a -= i, (!r && !s._dp || r && r.smoothChildTiming) && (s._start += i / s._ts, s._time -= i, s._tTime -= i), s.shiftChildren(-i, !1, -1e20), l = 0), (n = Oe(o)) > a && o._ts && (a = n), o = e;
                Ue(s, s === at && s._time > a ? s._time : Math.min(At, a), 1), s._dirty = 0
            }
            return s._tDur
        }, e.updateRoot = function (t) {
            if (at._ts && (xe(at, ke(t, at)), ut = yn.frame), yn.frame >= he) {
                he += St.autoSleep || 120;
                var e = at._first;
                if ((!e || !e._ts) && St.autoSleep && yn._listeners.length < 2) {
                    for (; e && !e._ts;) e = e._next;
                    e || yn.sleep()
                }
            }
        }, e
    }(Fn);
    we(Ln.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
    });
    var Rn, In = function (t, e, n, i, r, a, s) {
            var o, l, h, u, c, p, f, d, m = new ei(this._pt, t, e, 0, 1, Zn, null, r),
                g = 0,
                v = 0;
            for (m.b = n, m.e = i, n += "", (f = ~(i += "").indexOf("random(")) && (i = rn(i)), a && (a(d = [n, i], t, e), n = d[0], i = d[1]), l = n.match(qt) || []; o = qt.exec(i);) u = o[0], c = i.substring(g, o.index), h ? h = (h + 1) % 5 : "rgba(" === c.substr(-5) && (h = 1), u !== l[v++] && (p = parseFloat(l[v - 1]) || 0, m._pt = {
                _next: m._pt,
                p: c || 1 === v ? c : ",",
                s: p,
                c: "=" === u.charAt(1) ? parseFloat(u.substr(2)) * ("-" === u.charAt(0) ? -1 : 1) : parseFloat(u) - p,
                m: h && h < 4 ? Math.round : 0
            }, g = qt.lastIndex);
            return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = s, (Zt.test(i) || f) && (m.e = 0), this._pt = m, m
        },
        kn = function (t, e, n, i, r, a, s, o, l) {
            Ot(i) && (i = i(r || 0, t, a));
            var h, u = t[e],
                c = "get" !== n ? n : Ot(u) ? l ? t[e.indexOf("set") || !Ot(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : u,
                p = Ot(u) ? l ? jn : Hn : Gn;
            if (kt(i) && (~i.indexOf("random(") && (i = rn(i)), "=" === i.charAt(1) && (i = parseFloat(c) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + (Xe(c) || 0))), c !== i) return isNaN(c + i) ? (!u && !(e in t) && te(e, i), In.call(this, t, e, c, i, p, o || St.stringFilter, l)) : (h = new ei(this._pt, t, e, +c || 0, i - (c || 0), "boolean" == typeof u ? Yn : qn, 0, p), l && (h.fp = l), s && h.modifier(s, this, t), this._pt = h)
        },
        On = function (t, e, n, i, r, a) {
            var s, o, l, h;
            if (oe[t] && !1 !== (s = new oe[t]).init(r, s.rawVars ? e[t] : function (t, e, n, i, r) {
                    if (Ot(t) && (t = Bn(t, r, e, n, i)), !zt(t) || t.style && t.nodeType || Ht(t)) return kt(t) ? Bn(t, r, e, n, i) : t;
                    var a, s = {};
                    for (a in t) s[a] = Bn(t[a], r, e, n, i);
                    return s
                }(e[t], i, r, a, n), n, i, a) && (n._pt = o = new ei(n._pt, r, t, 0, 1, s.render, s, 0, s.priority), n !== ct))
                for (l = n._ptLookup[n._targets.indexOf(r)], h = s._props.length; h--;) l[s._props[h]] = o;
            return s
        },
        Nn = function t(e, n) {
            var i, r, a, s, o, l, h, u, c, p, f, d, m = e.vars,
                g = m.ease,
                v = m.startAt,
                y = m.immediateRender,
                _ = m.lazy,
                x = m.onUpdate,
                b = m.onUpdateParams,
                E = m.callbackScope,
                w = m.runBackwards,
                D = m.yoyoEase,
                M = m.keyframes,
                S = m.autoRevert,
                T = e._dur,
                A = e._startAt,
                C = e._targets,
                P = e.parent,
                F = P && "nested" === P.data ? P.parent._targets : C,
                L = "auto" === e._overwrite,
                R = e.timeline;
            if (!R || M && g || (g = "none"), e._ease = Mn(g, Tt.ease), e._yEase = D ? Dn(Mn(!0 === D ? g : D, Tt.ease)) : 0, D && e._yoyo && !e._repeat && (D = e._yEase, e._yEase = e._ease, e._ease = D), !R) {
                if (A && A.render(-1, !0).kill(), v) {
                    if (Pe(e._startAt = Vn.set(C, we({
                            data: "isStart",
                            overwrite: !1,
                            parent: P,
                            immediateRender: !0,
                            lazy: Ut(_),
                            startAt: null,
                            delay: 0,
                            onUpdate: x,
                            onUpdateParams: b,
                            callbackScope: E,
                            stagger: 0
                        }, v))), y)
                        if (n > 0) !S && (e._startAt = 0);
                        else if (T) return
                } else if (w && T)
                    if (A) !S && (e._startAt = 0);
                    else if (n && (y = !1), Pe(e._startAt = Vn.set(C, Me(Te(m, re), {
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: y && Ut(_),
                        immediateRender: y,
                        stagger: 0,
                        parent: P
                    }))), y) {
                    if (!n) return
                } else t(e._startAt, 1e-8);
                for (i = Te(m, re), e._pt = 0, d = (u = C[0] ? fe(C[0]).harness : 0) && m[u.prop], _ = T && Ut(_) || _ && !T, r = 0; r < C.length; r++) {
                    if (h = (o = C[r])._gsap || pe(C)[r]._gsap, e._ptLookup[r] = p = {}, se[h.id] && _e(), f = F === C ? r : F.indexOf(o), u && !1 !== (c = new u).init(o, d || i, e, f, F) && (e._pt = s = new ei(e._pt, o, c.name, 0, 1, c.render, c, 0, c.priority), c._props.forEach((function (t) {
                            p[t] = s
                        })), c.priority && (l = 1)), !u || d)
                        for (a in i) oe[a] && (c = On(a, i, e, f, o, F)) ? c.priority && (l = 1) : p[a] = s = kn.call(e, o, a, "get", i[a], f, F, 0, m.stringFilter);
                    e._op && e._op[r] && e.kill(o, e._op[r]), L && e._pt && (Rn = e, at.killTweensOf(o, p, "started"), Rn = 0), e._pt && _ && (se[h.id] = 1)
                }
                l && ti(e), e._onInit && e._onInit(e)
            }
            e._from = !R && !!m.runBackwards, e._onUpdate = x, e._initted = 1
        },
        Bn = function (t, e, n, i, r) {
            return Ot(t) ? t.call(e, n, i, r) : kt(t) && ~t.indexOf("random(") ? rn(t) : t
        },
        zn = ce + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
        Un = (zn + ",id,stagger,delay,duration,paused").split(","),
        Vn = function (t) {
            function e(e, n, i, r) {
                var a;
                "number" == typeof n && (i.duration = n, n = i, i = null);
                var s, o, l, h, u, c, p, f, d = (a = t.call(this, r ? n : Ae(n), i) || this).vars,
                    m = d.duration,
                    g = d.delay,
                    v = d.immediateRender,
                    y = d.stagger,
                    _ = d.overwrite,
                    x = d.keyframes,
                    b = d.defaults,
                    E = a.parent,
                    w = (Ht(e) ? Nt(e[0]) : "length" in n) ? [e] : Je(e);
                if (a._targets = w.length ? pe(w) : ee("GSAP target " + e + " not found. https://greensock.com", !St.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = _, x || y || Gt(m) || Gt(g)) {
                    if (n = a.vars, (s = a.timeline = new Ln({
                            data: "nested",
                            defaults: b || {}
                        })).kill(), s.parent = it(a), x) we(s.vars.defaults, {
                        ease: "none"
                    }), x.forEach((function (t) {
                        return s.to(w, t, ">")
                    }));
                    else {
                        if (h = w.length, p = y ? $e(y) : ie, zt(y))
                            for (u in y) ~zn.indexOf(u) && (f || (f = {}), f[u] = y[u]);
                        for (o = 0; o < h; o++) {
                            for (u in l = {}, n) Un.indexOf(u) < 0 && (l[u] = n[u]);
                            l.stagger = 0, f && Me(l, f), n.yoyoEase && !n.repeat && (l.yoyoEase = n.yoyoEase), c = w[o], l.duration = +Bn(m, it(a), o, c, w), l.delay = (+Bn(g, it(a), o, c, w) || 0) - a._delay, !y && 1 === h && l.delay && (a._delay = g = l.delay, a._start += g, l.delay = 0), s.to(c, l, p(o, c, w))
                        }
                        m = g = 0
                    }
                    m || a.duration(m = s.duration())
                } else a.timeline = 0;
                return !0 === _ && (Rn = it(a), at.killTweensOf(w), Rn = 0), E && Ne(E, it(a)), (v || !m && !x && a._start === E._time && Ut(v) && function t(e) {
                    return !e || e._ts && t(e.parent)
                }(it(a)) && "nested" !== E.data) && (a._tTime = -1e-8, a.render(Math.max(0, -g))), a
            }
            rt(e, t);
            var n = e.prototype;
            return n.render = function (t, e, n) {
                var i, r, a, s, o, l, h, u, c, p = this._time,
                    f = this._tDur,
                    d = this._dur,
                    m = t > f - 1e-8 && t >= 0 ? f : t < 1e-8 ? 0 : t;
                if (d) {
                    if (m !== this._tTime || !t || n || this._startAt && this._zTime < 0 != t < 0) {
                        if (i = m, u = this.timeline, this._repeat) {
                            if (s = d + this._rDelay, ((i = ge(m % s)) > d || f === m) && (i = d), (a = ~~(m / s)) && a === m / s && (i = d, a--), (l = this._yoyo && 1 & a) && (c = this._yEase, i = d - i), o = Ie(this._tTime, s), i === p && !n && this._initted) return this;
                            a !== o && (!this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1, this.render(s * a, !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (ze(this, i, n, e)) return this._tTime = 0, this;
                            if (d !== this._dur) return this.render(t, e, n)
                        }
                        for (this._tTime = m, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = h = (c || this._ease)(i / d), this._from && (this.ratio = h = 1 - h), p || !i || e || on(this, "onStart"), r = this._pt; r;) r.r(h, r.d), r = r._next;
                        u && u.render(t < 0 ? t : !i && l ? -1e-8 : u._dur * h, e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), on(this, "onUpdate")), this._repeat && a !== o && this.vars.onRepeat && !e && this.parent && on(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, n), (t || !d) && (t && this._ts > 0 || !m && this._ts < 0) && Pe(this, 1), e || t < 0 && !p || m < f && this.timeScale() > 0 || (on(this, m === f ? "onComplete" : "onReverseComplete", !0), this._prom && this._prom()))
                    }
                } else ! function (t, e, n, i) {
                    var r, a = t._zTime < 0 ? 0 : 1,
                        s = e < 0 ? 0 : 1,
                        o = t._rDelay,
                        l = 0;
                    if (o && t._repeat && (l = We(0, t._tDur, e), Ie(l, o) !== Ie(t._tTime, o) && (a = 1 - s, t.vars.repeatRefresh && t._initted && t.invalidate())), (t._initted || !ze(t, e, i, n)) && (s !== a || i || 1e-8 === t._zTime || !e && t._zTime)) {
                        for (t._zTime = e || (n ? 1e-8 : 0), t.ratio = s, t._from && (s = 1 - s), t._time = 0, t._tTime = l, n || on(t, "onStart"), r = t._pt; r;) r.r(s, r.d), r = r._next;
                        !s && t._startAt && !t._onUpdate && t._start && t._startAt.render(e, !0, i), t._onUpdate && (n || on(t, "onUpdate")), l && t._repeat && !n && t.parent && on(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === s && (t.ratio && Pe(t, 1), n || (on(t, t.ratio ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                    }
                }(this, t, e, n);
                return this
            }, n.targets = function () {
                return this._targets
            }, n.invalidate = function () {
                return this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this)
            }, n.kill = function (t, e) {
                if (void 0 === e && (e = "all"), !(t || e && "all" !== e) && (this._lazy = 0, this.parent)) return ln(this);
                if (this.timeline) return this.timeline.killTweensOf(t, e, Rn && !0 !== Rn.vars.overwrite), this;
                var n, i, r, a, s, o, l, h = this._targets,
                    u = t ? Je(t) : h,
                    c = this._ptLookup,
                    p = this._pt;
                if ((!e || "all" === e) && function (t, e) {
                        for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n];);
                        return n < 0
                    }(h, u)) return ln(this);
                for (n = this._op = this._op || [], "all" !== e && (kt(e) && (s = {}, me(e, (function (t) {
                        return s[t] = 1
                    })), e = s), e = function (t, e) {
                        var n, i, r, a, s = t[0] ? fe(t[0]).harness : 0,
                            o = s && s.aliases;
                        if (!o) return e;
                        for (i in n = Me({}, e), o)
                            if (i in n)
                                for (r = (a = o[i].split(",")).length; r--;) n[a[r]] = n[i];
                        return n
                    }(h, e)), l = h.length; l--;)
                    if (~u.indexOf(h[l]))
                        for (s in i = c[l], "all" === e ? (n[l] = e, a = i, r = {}) : (r = n[l] = n[l] || {}, a = e), a)(o = i && i[s]) && ("kill" in o.d && !0 !== o.d.kill(s) || Ce(this, o, "_pt"), delete i[s]), "all" !== r && (r[s] = 1);
                return this._initted && !this._pt && p && ln(this), this
            }, e.to = function (t, n) {
                return new e(t, n, arguments[2])
            }, e.from = function (t, n) {
                return new e(t, ye(arguments, 1))
            }, e.delayedCall = function (t, n, i, r) {
                return new e(n, 0, {
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: t,
                    onComplete: n,
                    onReverseComplete: n,
                    onCompleteParams: i,
                    onReverseCompleteParams: i,
                    callbackScope: r
                })
            }, e.fromTo = function (t, n, i) {
                return new e(t, ye(arguments, 2))
            }, e.set = function (t, n) {
                return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
            }, e.killTweensOf = function (t, e, n) {
                return at.killTweensOf(t, e, n)
            }, e
        }(Fn);
    we(Vn.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }), me("staggerTo,staggerFrom,staggerFromTo", (function (t) {
        Vn[t] = function () {
            var e = new Ln,
                n = qe.call(arguments, 0);
            return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
        }
    }));
    var Gn = function (t, e, n) {
            return t[e] = n
        },
        Hn = function (t, e, n) {
            return t[e](n)
        },
        jn = function (t, e, n, i) {
            return t[e](i.fp, n)
        },
        Wn = function (t, e, n) {
            return t.setAttribute(e, n)
        },
        Xn = function (t, e) {
            return Ot(t[e]) ? Hn : Bt(t[e]) && t.setAttribute ? Wn : Gn
        },
        qn = function (t, e) {
            return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e)
        },
        Yn = function (t, e) {
            return e.set(e.t, e.p, !!(e.s + e.c * t), e)
        },
        Zn = function (t, e) {
            var n = e._pt,
                i = "";
            if (!t && e.b) i = e.b;
            else if (1 === t && e.e) i = e.e;
            else {
                for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i, n = n._next;
                i += e.c
            }
            e.set(e.t, e.p, i, e)
        },
        Jn = function (t, e) {
            for (var n = e._pt; n;) n.r(t, n.d), n = n._next
        },
        Kn = function (t, e, n, i) {
            for (var r, a = this._pt; a;) r = a._next, a.p === i && a.modifier(t, e, n), a = r
        },
        $n = function (t) {
            for (var e, n, i = this._pt; i;) n = i._next, i.p === t && !i.op || i.op === t ? Ce(this, i, "_pt") : i.dep || (e = 1), i = n;
            return !e
        },
        Qn = function (t, e, n, i) {
            i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
        },
        ti = function (t) {
            for (var e, n, i, r, a = t._pt; a;) {
                for (e = a._next, n = i; n && n.pr > a.pr;) n = n._next;
                (a._prev = n ? n._prev : r) ? a._prev._next = a: i = a, (a._next = n) ? n._prev = a : r = a, a = e
            }
            t._pt = i
        },
        ei = function () {
            function t(t, e, n, i, r, a, s, o, l) {
                this.t = e, this.s = i, this.c = r, this.p = n, this.r = a || qn, this.d = s || this, this.set = o || Gn, this.pr = l || 0, this._next = t, t && (t._prev = this)
            }
            return t.prototype.modifier = function (t, e, n) {
                this.mSet = this.mSet || this.set, this.set = Qn, this.m = t, this.mt = n, this.tween = e
            }, t
        }();
    me(ce + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert", (function (t) {
        return re[t] = 1
    })), Kt.TweenMax = Kt.TweenLite = Vn, Kt.TimelineLite = Kt.TimelineMax = Ln, at = new Ln({
        sortChildren: !1,
        defaults: Tt,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }), St.stringFilter = vn;
    var ni = {
        registerPlugin: function () {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
            e.forEach((function (t) {
                return hn(t)
            }))
        },
        timeline: function (t) {
            return new Ln(t)
        },
        getTweensOf: function (t, e) {
            return at.getTweensOf(t, e)
        },
        getProperty: function (t, e, n, i) {
            kt(t) && (t = Je(t)[0]);
            var r = fe(t || {}).get,
                a = n ? Ee : be;
            return "native" === n && (n = ""), t ? e ? a((oe[e] && oe[e].get || r)(t, e, n, i)) : function (e, n, i) {
                return a((oe[e] && oe[e].get || r)(t, e, n, i))
            } : t
        },
        quickSetter: function (t, e, n) {
            if ((t = Je(t)).length > 1) {
                var i = t.map((function (t) {
                        return ai.quickSetter(t, e, n)
                    })),
                    r = i.length;
                return function (t) {
                    for (var e = r; e--;) i[e](t)
                }
            }
            t = t[0] || {};
            var a = oe[e],
                s = fe(t),
                o = a ? function (e) {
                    var i = new a;
                    ct._pt = 0, i.init(t, n ? e + n : e, ct, 0, [t]), i.render(1, i), ct._pt && Jn(1, ct)
                } : s.set(t, e);
            return a ? o : function (i) {
                return o(t, e, n ? i + n : i, s, 1)
            }
        },
        isTweening: function (t) {
            return at.getTweensOf(t, !0).length > 0
        },
        defaults: function (t) {
            return t && t.ease && (t.ease = Mn(t.ease, Tt.ease)), Se(Tt, t || {})
        },
        config: function (t) {
            return Se(St, t || {})
        },
        registerEffect: function (t) {
            var e = t.name,
                n = t.effect,
                i = t.plugins,
                r = t.defaults,
                a = t.extendTimeline;
            (i || "").split(",").forEach((function (t) {
                return t && !oe[t] && !Kt[t] && ee(e + " effect requires " + t + " plugin.")
            })), le[e] = function (t, e, i) {
                return n(Je(t), we(e || {}, r), i)
            }, a && (Ln.prototype[e] = function (t, n, i) {
                return this.add(le[e](t, zt(n) ? n : (i = n) && {}, this), i)
            })
        },
        registerEase: function (t, e) {
            xn[t] = Mn(e)
        },
        parseEase: function (t, e) {
            return arguments.length ? Mn(t, e) : xn
        },
        getById: function (t) {
            return at.getById(t)
        },
        exportRoot: function (t, e) {
            void 0 === t && (t = {});
            var n, i, r = new Ln(t);
            for (r.smoothChildTiming = Ut(t.smoothChildTiming), at.remove(r), r._dp = 0, r._time = r._tTime = at._time, n = at._first; n;) i = n._next, !e && !n._dur && n instanceof Vn && n.vars.onComplete === n._targets[0] || Be(r, n, n._start - n._delay), n = i;
            return Be(at, r, 0), r
        },
        utils: {
            wrap: function t(e, n, i) {
                var r = n - e;
                return Ht(e) ? nn(e, t(0, e.length), n) : je(i, (function (t) {
                    return (r + (t - e) % r) % r + e
                }))
            },
            wrapYoyo: function t(e, n, i) {
                var r = n - e,
                    a = 2 * r;
                return Ht(e) ? nn(e, t(0, e.length - 1), n) : je(i, (function (t) {
                    return e + ((t = (a + (t - e) % a) % a) > r ? a - t : t)
                }))
            },
            distribute: $e,
            random: en,
            snap: tn,
            normalize: function (t, e, n) {
                return an(t, e, 0, 1, n)
            },
            getUnit: Xe,
            clamp: function (t, e, n) {
                return je(n, (function (n) {
                    return We(t, e, n)
                }))
            },
            splitColor: pn,
            toArray: Je,
            mapRange: an,
            pipe: function () {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                return function (t) {
                    return e.reduce((function (t, e) {
                        return e(t)
                    }), t)
                }
            },
            unitize: function (t, e) {
                return function (n) {
                    return t(parseFloat(n)) + (e || Xe(n))
                }
            },
            interpolate: function t(e, n, i, r) {
                var a = isNaN(e + n) ? 0 : function (t) {
                    return (1 - t) * e + t * n
                };
                if (!a) {
                    var s, o, l, h, u, c = kt(e),
                        p = {};
                    if (!0 === i && (r = 1) && (i = null), c) e = {
                        p: e
                    }, n = {
                        p: n
                    };
                    else if (Ht(e) && !Ht(n)) {
                        for (l = [], h = e.length, u = h - 2, o = 1; o < h; o++) l.push(t(e[o - 1], e[o]));
                        h--, a = function (t) {
                            t *= h;
                            var e = Math.min(u, ~~t);
                            return l[e](t - e)
                        }, i = n
                    } else r || (e = Me(Ht(e) ? [] : {}, e));
                    if (!l) {
                        for (s in n) kn.call(p, e, s, "get", n[s]);
                        a = function (t) {
                            return Jn(t, p) || (c ? e.p : e)
                        }
                    }
                }
                return je(i, a)
            },
            shuffle: Ke
        },
        install: Qt,
        effects: le,
        ticker: yn,
        updateRoot: Ln.updateRoot,
        plugins: oe,
        globalTimeline: at,
        core: {
            PropTween: ei,
            globals: ne,
            Tween: Vn,
            Timeline: Ln,
            Animation: Fn,
            getCache: fe,
            _removeLinkedListItem: Ce
        }
    };
    me("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) {
        return ni[t] = Vn[t]
    })), yn.add(Ln.updateRoot), ct = ni.to({}, {
        duration: 0
    });
    var ii = function (t, e) {
            for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
            return n
        },
        ri = function (t, e) {
            return {
                name: t,
                rawVars: 1,
                init: function (t, n, i) {
                    i._onInit = function (t) {
                        var i, r;
                        if (kt(n) && (i = {}, me(n, (function (t) {
                                return i[t] = 1
                            })), n = i), e) {
                            for (r in i = {}, n) i[r] = e(n[r]);
                            n = i
                        }! function (t, e) {
                            var n, i, r, a = t._targets;
                            for (n in e)
                                for (i = a.length; i--;)(r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = ii(r, n)), r && r.modifier && r.modifier(e[n], t, a[i], n))
                        }(t, n)
                    }
                }
            }
        },
        ai = ni.registerPlugin({
            name: "attr",
            init: function (t, e, n, i, r) {
                for (var a in e) this.add(t, "setAttribute", (t.getAttribute(a) || 0) + "", e[a], i, r, 0, 0, a), this._props.push(a)
            }
        }, {
            name: "endArray",
            init: function (t, e) {
                for (var n = e.length; n--;) this.add(t, n, t[n] || 0, e[n])
            }
        }, ri("roundProps", Qe), ri("modifiers"), ri("snap", tn)) || ni;
    Vn.version = Ln.version = ai.version = "3.2.6", ht = 1, Vt() && _n();
    xn.Power0, xn.Power1, xn.Power2, xn.Power3, xn.Power4, xn.Linear, xn.Quad, xn.Cubic, xn.Quart, xn.Quint, xn.Strong, xn.Elastic, xn.Back, xn.SteppedEase, xn.Bounce, xn.Sine, xn.Expo, xn.Circ;
    var si, oi, li, hi, ui, ci, pi, fi, di = {},
        mi = 180 / Math.PI,
        gi = Math.PI / 180,
        vi = Math.atan2,
        yi = /([A-Z])/g,
        _i = /(?:left|right|width|margin|padding|x)/i,
        xi = /[\s,\(]\S/,
        bi = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        },
        Ei = function (t, e) {
            return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        },
        wi = function (t, e) {
            return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        },
        Di = function (t, e) {
            return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
        },
        Mi = function (t, e) {
            var n = e.s + e.c * t;
            e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
        },
        Si = function (t, e) {
            return e.set(e.t, e.p, t ? e.e : e.b, e)
        },
        Ti = function (t, e) {
            return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
        },
        Ai = function (t, e, n) {
            return t.style[e] = n
        },
        Ci = function (t, e, n) {
            return t.style.setProperty(e, n)
        },
        Pi = function (t, e, n) {
            return t._gsap[e] = n
        },
        Fi = function (t, e, n) {
            return t._gsap.scaleX = t._gsap.scaleY = n
        },
        Li = function (t, e, n, i, r) {
            var a = t._gsap;
            a.scaleX = a.scaleY = n, a.renderTransform(r, a)
        },
        Ri = function (t, e, n, i, r) {
            var a = t._gsap;
            a[e] = n, a.renderTransform(r, a)
        },
        Ii = "transform",
        ki = Ii + "Origin",
        Oi = function (t, e) {
            var n = oi.createElementNS ? oi.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : oi.createElement(t);
            return n.style ? n : oi.createElement(t)
        },
        Ni = function t(e, n, i) {
            var r = getComputedStyle(e);
            return r[n] || r.getPropertyValue(n.replace(yi, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && t(e, zi(n) || n, 1) || ""
        },
        Bi = "O,Moz,ms,Ms,Webkit".split(","),
        zi = function (t, e, n) {
            var i = (e || ui).style,
                r = 5;
            if (t in i && !n) return t;
            for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(Bi[r] + t in i););
            return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? Bi[r] : "") + t
        },
        Ui = function () {
            "undefined" != typeof window && (si = window, oi = si.document, li = oi.documentElement, ui = Oi("div") || {
                style: {}
            }, ci = Oi("div"), Ii = zi(Ii), ki = zi(ki), ui.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", fi = !!zi("perspective"), hi = 1)
        },
        Vi = function t(e) {
            var n, i = Oi("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                r = this.parentNode,
                a = this.nextSibling,
                s = this.style.cssText;
            if (li.appendChild(i), i.appendChild(this), this.style.display = "block", e) try {
                n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
            } catch (t) {} else this._gsapBBox && (n = this._gsapBBox());
            return r && (a ? r.insertBefore(this, a) : r.appendChild(this)), li.removeChild(i), this.style.cssText = s, n
        },
        Gi = function (t, e) {
            for (var n = e.length; n--;)
                if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
        },
        Hi = function (t) {
            var e;
            try {
                e = t.getBBox()
            } catch (n) {
                e = Vi.call(t, !0)
            }
            return e && (e.width || e.height) || t.getBBox === Vi || (e = Vi.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                x: +Gi(t, ["x", "cx", "x1"]) || 0,
                y: +Gi(t, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
            }
        },
        ji = function (t) {
            return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Hi(t))
        },
        Wi = function (t, e) {
            if (e) {
                var n = t.style;
                e in di && (e = Ii), n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), n.removeProperty(e.replace(yi, "-$1").toLowerCase())) : n.removeAttribute(e)
            }
        },
        Xi = function (t, e, n, i, r, a) {
            var s = new ei(t._pt, e, n, 0, 1, a ? Ti : Si);
            return t._pt = s, s.b = i, s.e = r, t._props.push(n), s
        },
        qi = {
            deg: 1,
            rad: 1,
            turn: 1
        },
        Yi = function t(e, n, i, r) {
            var a, s, o, l, h = parseFloat(i) || 0,
                u = (i + "").trim().substr((h + "").length) || "px",
                c = ui.style,
                p = _i.test(n),
                f = "svg" === e.tagName.toLowerCase(),
                d = (f ? "client" : "offset") + (p ? "Width" : "Height"),
                m = "px" === r,
                g = "%" === r;
            return r === u || !h || qi[r] || qi[u] ? h : ("px" !== u && !m && (h = t(e, n, i, "px")), l = e.getCTM && ji(e), g && (di[n] || ~n.indexOf("adius")) ? ge(h / (l ? e.getBBox()[p ? "width" : "height"] : e[d]) * 100) : (c[p ? "width" : "height"] = 100 + (m ? u : r), s = ~n.indexOf("adius") || "em" === r && e.appendChild && !f ? e : e.parentNode, l && (s = (e.ownerSVGElement || {}).parentNode), s && s !== oi && s.appendChild || (s = oi.body), (o = s._gsap) && g && o.width && p && o.time === yn.time ? ge(h / o.width * 100) : ((g || "%" === u) && (c.position = Ni(e, "position")), s === e && (c.position = "static"), s.appendChild(ui), a = ui[d], s.removeChild(ui), c.position = "absolute", p && g && ((o = fe(s)).time = yn.time, o.width = s[d]), ge(m ? a * h / 100 : a && h ? 100 / a * h : 0))))
        },
        Zi = function (t, e, n, i) {
            var r;
            return hi || Ui(), e in bi && "transform" !== e && ~(e = bi[e]).indexOf(",") && (e = e.split(",")[0]), di[e] && "transform" !== e ? (r = sr(t, i), r = "transformOrigin" !== e ? r[e] : or(Ni(t, ki)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Qi[e] && Qi[e](t, e, n) || Ni(t, e) || de(t, e) || ("opacity" === e ? 1 : 0)), n && !~(r + "").indexOf(" ") ? Yi(t, e, r, n) + n : r
        },
        Ji = function (t, e, n, i) {
            if (!n || "none" === n) {
                var r = zi(e, t, 1),
                    a = r && Ni(t, r, 1);
                a && a !== n && (e = r, n = a)
            }
            var s, o, l, h, u, c, p, f, d, m, g, v, y = new ei(this._pt, t.style, e, 0, 1, Zn),
                _ = 0,
                x = 0;
            if (y.b = n, y.e = i, n += "", "auto" === (i += "") && (t.style[e] = i, i = Ni(t, e) || i, t.style[e] = n), vn(s = [n, i]), i = s[1], l = (n = s[0]).match(Xt) || [], (i.match(Xt) || []).length) {
                for (; o = Xt.exec(i);) p = o[0], d = i.substring(_, o.index), u ? u = (u + 1) % 5 : "rgba(" !== d.substr(-5) && "hsla(" !== d.substr(-5) || (u = 1), p !== (c = l[x++] || "") && (h = parseFloat(c) || 0, g = c.substr((h + "").length), (v = "=" === p.charAt(1) ? +(p.charAt(0) + "1") : 0) && (p = p.substr(2)), f = parseFloat(p), m = p.substr((f + "").length), _ = Xt.lastIndex - m.length, m || (m = m || St.units[e] || g, _ === i.length && (i += m, y.e += m)), g !== m && (h = Yi(t, e, c, m) || 0), y._pt = {
                    _next: y._pt,
                    p: d || 1 === x ? d : ",",
                    s: h,
                    c: v ? v * f : f - h,
                    m: u && u < 4 ? Math.round : 0
                });
                y.c = _ < i.length ? i.substring(_, i.length) : ""
            } else y.r = "display" === e && "none" === i ? Ti : Si;
            return Zt.test(i) && (y.e = 0), this._pt = y, y
        },
        Ki = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        },
        $i = function (t, e) {
            if (e.tween && e.tween._time === e.tween._dur) {
                var n, i, r, a = e.t,
                    s = a.style,
                    o = e.u,
                    l = a._gsap;
                if ("all" === o || !0 === o) s.cssText = "", i = 1;
                else
                    for (r = (o = o.split(",")).length; --r > -1;) n = o[r], di[n] && (i = 1, n = "transformOrigin" === n ? ki : Ii), Wi(a, n);
                i && (Wi(a, Ii), l && (l.svg && a.removeAttribute("transform"), sr(a, 1), l.uncache = 1))
            }
        },
        Qi = {
            clearProps: function (t, e, n, i, r) {
                if ("isFromStart" !== r.data) {
                    var a = t._pt = new ei(t._pt, e, n, 0, 0, $i);
                    return a.u = i, a.pr = -10, a.tween = r, t._props.push(n), 1
                }
            }
        },
        tr = [1, 0, 0, 1, 0, 0],
        er = {},
        nr = function (t) {
            return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
        },
        ir = function (t) {
            var e = Ni(t, Ii);
            return nr(e) ? tr : e.substr(7).match(Wt).map(ge)
        },
        rr = function (t, e) {
            var n, i, r, a, s = t._gsap || fe(t),
                o = t.style,
                l = ir(t);
            return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? tr : l : (l !== tr || t.offsetParent || t === li || s.svg || (r = o.display, o.display = "block", (n = t.parentNode) && t.offsetParent || (a = 1, i = t.nextSibling, li.appendChild(t)), l = ir(t), r ? o.display = r : Wi(t, "display"), a && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : li.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
        },
        ar = function (t, e, n, i, r, a) {
            var s, o, l, h = t._gsap,
                u = r || rr(t, !0),
                c = h.xOrigin || 0,
                p = h.yOrigin || 0,
                f = h.xOffset || 0,
                d = h.yOffset || 0,
                m = u[0],
                g = u[1],
                v = u[2],
                y = u[3],
                _ = u[4],
                x = u[5],
                b = e.split(" "),
                E = parseFloat(b[0]) || 0,
                w = parseFloat(b[1]) || 0;
            n ? u !== tr && (o = m * y - g * v) && (l = E * (-g / o) + w * (m / o) - (m * x - g * _) / o, E = E * (y / o) + w * (-v / o) + (v * x - y * _) / o, w = l) : (E = (s = Hi(t)).x + (~b[0].indexOf("%") ? E / 100 * s.width : E), w = s.y + (~(b[1] || b[0]).indexOf("%") ? w / 100 * s.height : w)), i || !1 !== i && h.smooth ? (_ = E - c, x = w - p, h.xOffset = f + (_ * m + x * v) - _, h.yOffset = d + (_ * g + x * y) - x) : h.xOffset = h.yOffset = 0, h.xOrigin = E, h.yOrigin = w, h.smooth = !!i, h.origin = e, h.originIsAbsolute = !!n, t.style[ki] = "0px 0px", a && (Xi(a, h, "xOrigin", c, E), Xi(a, h, "yOrigin", p, w), Xi(a, h, "xOffset", f, h.xOffset), Xi(a, h, "yOffset", d, h.yOffset)), t.setAttribute("data-svg-origin", E + " " + w)
        },
        sr = function (t, e) {
            var n = t._gsap || new Pn(t);
            if ("x" in n && !e && !n.uncache) return n;
            var i, r, a, s, o, l, h, u, c, p, f, d, m, g, v, y, _, x, b, E, w, D, M, S, T, A, C, P, F, L, R, I, k = t.style,
                O = n.scaleX < 0,
                N = Ni(t, ki) || "0";
            return i = r = a = l = h = u = c = p = f = 0, s = o = 1, n.svg = !(!t.getCTM || !ji(t)), g = rr(t, n.svg), n.svg && (S = !n.uncache && t.getAttribute("data-svg-origin"), ar(t, S || N, !!S || n.originIsAbsolute, !1 !== n.smooth, g)), d = n.xOrigin || 0, m = n.yOrigin || 0, g !== tr && (x = g[0], b = g[1], E = g[2], w = g[3], i = D = g[4], r = M = g[5], 6 === g.length ? (s = Math.sqrt(x * x + b * b), o = Math.sqrt(w * w + E * E), l = x || b ? vi(b, x) * mi : 0, (c = E || w ? vi(E, w) * mi + l : 0) && (o *= Math.cos(c * gi)), n.svg && (i -= d - (d * x + m * E), r -= m - (d * b + m * w))) : (I = g[6], L = g[7], C = g[8], P = g[9], F = g[10], R = g[11], i = g[12], r = g[13], a = g[14], h = (v = vi(I, F)) * mi, v && (S = D * (y = Math.cos(-v)) + C * (_ = Math.sin(-v)), T = M * y + P * _, A = I * y + F * _, C = D * -_ + C * y, P = M * -_ + P * y, F = I * -_ + F * y, R = L * -_ + R * y, D = S, M = T, I = A), u = (v = vi(-E, F)) * mi, v && (y = Math.cos(-v), R = w * (_ = Math.sin(-v)) + R * y, x = S = x * y - C * _, b = T = b * y - P * _, E = A = E * y - F * _), l = (v = vi(b, x)) * mi, v && (S = x * (y = Math.cos(v)) + b * (_ = Math.sin(v)), T = D * y + M * _, b = b * y - x * _, M = M * y - D * _, x = S, D = T), h && Math.abs(h) + Math.abs(l) > 359.9 && (h = l = 0, u = 180 - u), s = ge(Math.sqrt(x * x + b * b + E * E)), o = ge(Math.sqrt(M * M + I * I)), v = vi(D, M), c = Math.abs(v) > 2e-4 ? v * mi : 0, f = R ? 1 / (R < 0 ? -R : R) : 0), n.svg && (g = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !nr(Ni(t, Ii)), g && t.setAttribute("transform", g))), Math.abs(c) > 90 && Math.abs(c) < 270 && (O ? (s *= -1, c += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (o *= -1, c += c <= 0 ? 180 : -180)), n.x = ((n.xPercent = i && Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0) ? 0 : i) + "px", n.y = ((n.yPercent = r && Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0) ? 0 : r) + "px", n.z = a + "px", n.scaleX = ge(s), n.scaleY = ge(o), n.rotation = ge(l) + "deg", n.rotationX = ge(h) + "deg", n.rotationY = ge(u) + "deg", n.skewX = c + "deg", n.skewY = p + "deg", n.transformPerspective = f + "px", (n.zOrigin = parseFloat(N.split(" ")[2]) || 0) && (k[ki] = or(N)), n.xOffset = n.yOffset = 0, n.force3D = St.force3D, n.renderTransform = n.svg ? cr : fi ? ur : hr, n.uncache = 0, n
        },
        or = function (t) {
            return (t = t.split(" "))[0] + " " + t[1]
        },
        lr = function (t, e, n) {
            var i = Xe(e);
            return ge(parseFloat(e) + parseFloat(Yi(t, "x", n + "px", i))) + i
        },
        hr = function (t, e) {
            e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, ur(t, e)
        },
        ur = function (t, e) {
            var n = e || this,
                i = n.xPercent,
                r = n.yPercent,
                a = n.x,
                s = n.y,
                o = n.z,
                l = n.rotation,
                h = n.rotationY,
                u = n.rotationX,
                c = n.skewX,
                p = n.skewY,
                f = n.scaleX,
                d = n.scaleY,
                m = n.transformPerspective,
                g = n.force3D,
                v = n.target,
                y = n.zOrigin,
                _ = "",
                x = "auto" === g && t && 1 !== t || !0 === g;
            if (y && ("0deg" !== u || "0deg" !== h)) {
                var b, E = parseFloat(h) * gi,
                    w = Math.sin(E),
                    D = Math.cos(E);
                E = parseFloat(u) * gi, b = Math.cos(E), a = lr(v, a, w * b * -y), s = lr(v, s, -Math.sin(E) * -y), o = lr(v, o, D * b * -y + y)
            }
            "0px" !== m && (_ += "perspective(" + m + ") "), (i || r) && (_ += "translate(" + i + "%, " + r + "%) "), (x || "0px" !== a || "0px" !== s || "0px" !== o) && (_ += "0px" !== o || x ? "translate3d(" + a + ", " + s + ", " + o + ") " : "translate(" + a + ", " + s + ") "), "0deg" !== l && (_ += "rotate(" + l + ") "), "0deg" !== h && (_ += "rotateY(" + h + ") "), "0deg" !== u && (_ += "rotateX(" + u + ") "), "0deg" === c && "0deg" === p || (_ += "skew(" + c + ", " + p + ") "), 1 === f && 1 === d || (_ += "scale(" + f + ", " + d + ") "), v.style[Ii] = _ || "translate(0, 0)"
        },
        cr = function (t, e) {
            var n, i, r, a, s, o = e || this,
                l = o.xPercent,
                h = o.yPercent,
                u = o.x,
                c = o.y,
                p = o.rotation,
                f = o.skewX,
                d = o.skewY,
                m = o.scaleX,
                g = o.scaleY,
                v = o.target,
                y = o.xOrigin,
                _ = o.yOrigin,
                x = o.xOffset,
                b = o.yOffset,
                E = o.forceCSS,
                w = parseFloat(u),
                D = parseFloat(c);
            p = parseFloat(p), f = parseFloat(f), (d = parseFloat(d)) && (f += d = parseFloat(d), p += d), p || f ? (p *= gi, f *= gi, n = Math.cos(p) * m, i = Math.sin(p) * m, r = Math.sin(p - f) * -g, a = Math.cos(p - f) * g, f && (d *= gi, s = Math.tan(f - d), r *= s = Math.sqrt(1 + s * s), a *= s, d && (s = Math.tan(d), n *= s = Math.sqrt(1 + s * s), i *= s)), n = ge(n), i = ge(i), r = ge(r), a = ge(a)) : (n = m, a = g, i = r = 0), (w && !~(u + "").indexOf("px") || D && !~(c + "").indexOf("px")) && (w = Yi(v, "x", u, "px"), D = Yi(v, "y", c, "px")), (y || _ || x || b) && (w = ge(w + y - (y * n + _ * r) + x), D = ge(D + _ - (y * i + _ * a) + b)), (l || h) && (s = v.getBBox(), w = ge(w + l / 100 * s.width), D = ge(D + h / 100 * s.height)), s = "matrix(" + n + "," + i + "," + r + "," + a + "," + w + "," + D + ")", v.setAttribute("transform", s), E && (v.style[Ii] = s)
        },
        pr = function (t, e, n, i, r, a) {
            var s, o, l = kt(r),
                h = parseFloat(r) * (l && ~r.indexOf("rad") ? mi : 1),
                u = a ? h * a : h - i,
                c = i + u + "deg";
            return l && ("short" === (s = r.split("_")[1]) && (u %= 360) !== u % 180 && (u += u < 0 ? 360 : -360), "cw" === s && u < 0 ? u = (u + 36e9) % 360 - 360 * ~~(u / 360) : "ccw" === s && u > 0 && (u = (u - 36e9) % 360 - 360 * ~~(u / 360))), t._pt = o = new ei(t._pt, e, n, i, u, wi), o.e = c, o.u = "deg", t._props.push(n), o
        },
        fr = function (t, e, n) {
            var i, r, a, s, o, l, h, u = ci.style,
                c = n._gsap;
            for (r in u.cssText = getComputedStyle(n).cssText + ";position:absolute;display:block;", u[Ii] = e, oi.body.appendChild(ci), i = sr(ci, 1), di)(a = c[r]) !== (s = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = Xe(a) !== (h = Xe(s)) ? Yi(n, r, a, h) : parseFloat(a), l = parseFloat(s), t._pt = new ei(t._pt, c, r, o, l - o, Ei), t._pt.u = h || 0, t._props.push(r));
            oi.body.removeChild(ci)
        };
    me("padding,margin,Width,Radius", (function (t, e) {
        var n = "Top",
            i = "Right",
            r = "Bottom",
            a = "Left",
            s = (e < 3 ? [n, i, r, a] : [n + a, n + i, r + i, r + a]).map((function (n) {
                return e < 2 ? t + n : "border" + n + t
            }));
        Qi[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
            var a, o;
            if (arguments.length < 4) return a = s.map((function (e) {
                return Zi(t, e, n)
            })), 5 === (o = a.join(" ")).split(a[0]).length ? a[0] : o;
            a = (i + "").split(" "), o = {}, s.forEach((function (t, e) {
                return o[t] = a[e] = a[e] || a[(e - 1) / 2 | 0]
            })), t.init(e, o, r)
        }
    }));
    var dr, mr, gr = {
        name: "css",
        register: Ui,
        targetTest: function (t) {
            return t.style && t.nodeType
        },
        init: function (t, e, n, i, r) {
            var a, s, o, l, h, u, c, p, f, d, m, g, v, y, _, x, b, E, w, D = this._props,
                M = t.style;
            for (c in hi || Ui(), e)
                if ("autoRound" !== c && (s = e[c], !oe[c] || !On(c, e, n, i, t, r)))
                    if (h = typeof s, u = Qi[c], "function" === h && (h = typeof (s = s.call(n, i, t, r))), "string" === h && ~s.indexOf("random(") && (s = rn(s)), u) u(this, t, c, s, n) && (_ = 1);
                    else if ("--" === c.substr(0, 2)) this.add(M, "setProperty", getComputedStyle(t).getPropertyValue(c) + "", s + "", i, r, 0, 0, c);
            else {
                if (a = Zi(t, c), l = parseFloat(a), (d = "string" === h && "=" === s.charAt(1) ? +(s.charAt(0) + "1") : 0) && (s = s.substr(2)), o = parseFloat(s), c in bi && ("autoAlpha" === c && (1 === l && "hidden" === Zi(t, "visibility") && o && (l = 0), Xi(this, M, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== c && "transform" !== c && ~(c = bi[c]).indexOf(",") && (c = c.split(",")[0])), m = c in di)
                    if (g || ((v = t._gsap).renderTransform || sr(t), y = !1 !== e.smoothOrigin && v.smooth, (g = this._pt = new ei(this._pt, M, Ii, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === c) this._pt = new ei(this._pt, v, "scaleY", v.scaleY, d ? d * o : o - v.scaleY), D.push("scaleY", c), c += "X";
                    else {
                        if ("transformOrigin" === c) {
                            b = void 0, E = void 0, w = void 0, b = (x = s).split(" "), E = b[0], w = b[1] || "50%", "top" !== E && "bottom" !== E && "left" !== w && "right" !== w || (x = E, E = w, w = x), b[0] = Ki[E] || E, b[1] = Ki[w] || w, s = b.join(" "), v.svg ? ar(t, s, 0, y, 0, this) : ((f = parseFloat(s.split(" ")[2]) || 0) !== v.zOrigin && Xi(this, v, "zOrigin", v.zOrigin, f), Xi(this, M, c, or(a), or(s)));
                            continue
                        }
                        if ("svgOrigin" === c) {
                            ar(t, s, 1, y, 0, this);
                            continue
                        }
                        if (c in er) {
                            pr(this, v, c, l, s, d);
                            continue
                        }
                        if ("smoothOrigin" === c) {
                            Xi(this, v, "smooth", v.smooth, s);
                            continue
                        }
                        if ("force3D" === c) {
                            v[c] = s;
                            continue
                        }
                        if ("transform" === c) {
                            fr(this, s, t);
                            continue
                        }
                    }
                else c in M || (c = zi(c) || c);
                if (m || (o || 0 === o) && (l || 0 === l) && !xi.test(s) && c in M) o || (o = 0), (p = (a + "").substr((l + "").length)) !== (f = (s + "").substr((o + "").length) || (c in St.units ? St.units[c] : p)) && (l = Yi(t, c, a, f)), this._pt = new ei(this._pt, m ? v : M, c, l, d ? d * o : o - l, "px" !== f || !1 === e.autoRound || m ? Ei : Mi), this._pt.u = f || 0, p !== f && (this._pt.b = a, this._pt.r = Di);
                else if (c in M) Ji.call(this, t, c, a, s);
                else {
                    if (!(c in t)) {
                        te(c, s);
                        continue
                    }
                    this.add(t, c, t[c], s, i, r)
                }
                D.push(c)
            }
            _ && ti(this)
        },
        get: Zi,
        aliases: bi,
        getSetter: function (t, e, n) {
            var i = bi[e];
            return i && i.indexOf(",") < 0 && (e = i), e in di && e !== ki && (t._gsap.x || Zi(t, "x")) ? n && pi === n ? "scale" === e ? Fi : Pi : (pi = n || {}) && ("scale" === e ? Li : Ri) : t.style && !Bt(t.style[e]) ? Ai : ~e.indexOf("-") ? Ci : Xn(t, e)
        },
        core: {
            _removeProperty: Wi,
            _getMatrix: rr
        }
    };
    ai.utils.checkPrefix = zi, mr = me("x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + (dr = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) {
        di[t] = 1
    })), me(dr, (function (t) {
        St.units[t] = "deg", er[t] = 1
    })), bi[mr[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + dr, me("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) {
        var e = t.split(":");
        bi[e[1]] = mr[e[0]]
    })), me("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) {
        St.units[t] = "px"
    })), ai.registerPlugin(gr);
    for (var vr = ai.registerPlugin(gr) || ai, yr = (vr.core.Tween, []), _r = 0; _r < 256; _r++) yr[_r] = (_r < 16 ? "0" : "") + _r.toString(16);
    var xr, br = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function () {
            var t = 4294967295 * Math.random() | 0,
                e = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                i = 4294967295 * Math.random() | 0;
            return (yr[255 & t] + yr[t >> 8 & 255] + yr[t >> 16 & 255] + yr[t >> 24 & 255] + "-" + yr[255 & e] + yr[e >> 8 & 255] + "-" + yr[e >> 16 & 15 | 64] + yr[e >> 24 & 255] + "-" + yr[63 & n | 128] + yr[n >> 8 & 255] + "-" + yr[n >> 16 & 255] + yr[n >> 24 & 255] + yr[255 & i] + yr[i >> 8 & 255] + yr[i >> 16 & 255] + yr[i >> 24 & 255]).toUpperCase()
        },
        clamp: function (t, e, n) {
            return Math.max(e, Math.min(n, t))
        },
        euclideanModulo: function (t, e) {
            return (t % e + e) % e
        },
        mapLinear: function (t, e, n, i, r) {
            return i + (t - e) * (r - i) / (n - e)
        },
        lerp: function (t, e, n) {
            return (1 - n) * t + n * e
        },
        smoothstep: function (t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
        },
        smootherstep: function (t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
        },
        randInt: function (t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function (t, e) {
            return t + Math.random() * (e - t)
        },
        randFloatSpread: function (t) {
            return t * (.5 - Math.random())
        },
        degToRad: function (t) {
            return t * br.DEG2RAD
        },
        radToDeg: function (t) {
            return t * br.RAD2DEG
        },
        isPowerOfTwo: function (t) {
            return 0 == (t & t - 1) && 0 !== t
        },
        ceilPowerOfTwo: function (t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        },
        floorPowerOfTwo: function (t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        },
        setQuaternionFromProperEuler: function (t, e, n, i, r) {
            var a = Math.cos,
                s = Math.sin,
                o = a(n / 2),
                l = s(n / 2),
                h = a((e + i) / 2),
                u = s((e + i) / 2),
                c = a((e - i) / 2),
                p = s((e - i) / 2),
                f = a((i - e) / 2),
                d = s((i - e) / 2);
            switch (r) {
                case "XYX":
                    t.set(o * u, l * c, l * p, o * h);
                    break;
                case "YZY":
                    t.set(l * p, o * u, l * c, o * h);
                    break;
                case "ZXZ":
                    t.set(l * c, l * p, o * u, o * h);
                    break;
                case "XZX":
                    t.set(o * u, l * d, l * f, o * h);
                    break;
                case "YXY":
                    t.set(l * f, o * u, l * d, o * h);
                    break;
                case "ZYZ":
                    t.set(l * d, l * f, o * u, o * h);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
            }
        }
    };

    function Er() {}

    function wr(t, e) {
        this.x = t || 0, this.y = e || 0
    }

    function Dr() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.assign(Er.prototype, {
        addEventListener: function (t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
        },
        hasEventListener: function (t, e) {
            if (void 0 === this._listeners) return !1;
            var n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e)
        },
        removeEventListener: function (t, e) {
            if (void 0 !== this._listeners) {
                var n = this._listeners[t];
                if (void 0 !== n) {
                    var i = n.indexOf(e); - 1 !== i && n.splice(i, 1)
                }
            }
        },
        dispatchEvent: function (t) {
            if (void 0 !== this._listeners) {
                var e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    for (var n = e.slice(0), i = 0, r = n.length; i < r; i++) n[i].call(this, t)
                }
            }
        }
    }), Object.defineProperties(wr.prototype, {
        width: {
            get: function () {
                return this.x
            },
            set: function (t) {
                this.x = t
            }
        },
        height: {
            get: function () {
                return this.y
            },
            set: function (t) {
                this.y = t
            }
        }
    }), Object.assign(wr.prototype, {
        isVector2: !0,
        set: function (t, e) {
            return this.x = t, this.y = e, this
        },
        setScalar: function (t) {
            return this.x = t, this.y = t, this
        },
        setX: function (t) {
            return this.x = t, this
        },
        setY: function (t) {
            return this.y = t, this
        },
        setComponent: function (t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function (t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y)
        },
        copy: function (t) {
            return this.x = t.x, this.y = t.y, this
        },
        add: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
        },
        addScalar: function (t) {
            return this.x += t, this.y += t, this
        },
        addVectors: function (t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this
        },
        addScaledVector: function (t, e) {
            return this.x += t.x * e, this.y += t.y * e, this
        },
        sub: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
        },
        subScalar: function (t) {
            return this.x -= t, this.y -= t, this
        },
        subVectors: function (t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this
        },
        multiply: function (t) {
            return this.x *= t.x, this.y *= t.y, this
        },
        multiplyScalar: function (t) {
            return this.x *= t, this.y *= t, this
        },
        divide: function (t) {
            return this.x /= t.x, this.y /= t.y, this
        },
        divideScalar: function (t) {
            return this.multiplyScalar(1 / t)
        },
        applyMatrix3: function (t) {
            var e = this.x,
                n = this.y,
                i = t.elements;
            return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
        },
        min: function (t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
        },
        max: function (t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
        },
        clamp: function (t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
        },
        clampScalar: function (t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
        },
        clampLength: function (t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function (t) {
            return this.x * t.x + this.y * t.y
        },
        cross: function (t) {
            return this.x * t.y - this.y * t.x
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        angle: function () {
            return Math.atan2(-this.y, -this.x) + Math.PI
        },
        distanceTo: function (t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function (t) {
            var e = this.x - t.x,
                n = this.y - t.y;
            return e * e + n * n
        },
        manhattanDistanceTo: function (t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        },
        setLength: function (t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function (t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
        },
        lerpVectors: function (t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function (t) {
            return t.x === this.x && t.y === this.y
        },
        fromArray: function (t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
        },
        toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
        },
        fromBufferAttribute: function (t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
        },
        rotateAround: function (t, e) {
            var n = Math.cos(e),
                i = Math.sin(e),
                r = this.x - t.x,
                a = this.y - t.y;
            return this.x = r * n - a * i + t.x, this.y = r * i + a * n + t.y, this
        },
        random: function () {
            return this.x = Math.random(), this.y = Math.random(), this
        }
    }), Object.assign(Dr.prototype, {
        isMatrix3: !0,
        set: function (t, e, n, i, r, a, s, o, l) {
            var h = this.elements;
            return h[0] = t, h[1] = i, h[2] = s, h[3] = e, h[4] = r, h[5] = o, h[6] = n, h[7] = a, h[8] = l, this
        },
        identity: function () {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function () {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function (t) {
            var e = this.elements,
                n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
        },
        extractBasis: function (t, e, n) {
            return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
        },
        setFromMatrix4: function (t) {
            var e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        },
        multiply: function (t) {
            return this.multiplyMatrices(this, t)
        },
        premultiply: function (t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function (t, e) {
            var n = t.elements,
                i = e.elements,
                r = this.elements,
                a = n[0],
                s = n[3],
                o = n[6],
                l = n[1],
                h = n[4],
                u = n[7],
                c = n[2],
                p = n[5],
                f = n[8],
                d = i[0],
                m = i[3],
                g = i[6],
                v = i[1],
                y = i[4],
                _ = i[7],
                x = i[2],
                b = i[5],
                E = i[8];
            return r[0] = a * d + s * v + o * x, r[3] = a * m + s * y + o * b, r[6] = a * g + s * _ + o * E, r[1] = l * d + h * v + u * x, r[4] = l * m + h * y + u * b, r[7] = l * g + h * _ + u * E, r[2] = c * d + p * v + f * x, r[5] = c * m + p * y + f * b, r[8] = c * g + p * _ + f * E, this
        },
        multiplyScalar: function (t) {
            var e = this.elements;
            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
        },
        determinant: function () {
            var t = this.elements,
                e = t[0],
                n = t[1],
                i = t[2],
                r = t[3],
                a = t[4],
                s = t[5],
                o = t[6],
                l = t[7],
                h = t[8];
            return e * a * h - e * s * l - n * r * h + n * s * o + i * r * l - i * a * o
        },
        getInverse: function (t, e) {
            void 0 !== e && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
            var n = t.elements,
                i = this.elements,
                r = n[0],
                a = n[1],
                s = n[2],
                o = n[3],
                l = n[4],
                h = n[5],
                u = n[6],
                c = n[7],
                p = n[8],
                f = p * l - h * c,
                d = h * u - p * o,
                m = c * o - l * u,
                g = r * f + a * d + s * m;
            if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            var v = 1 / g;
            return i[0] = f * v, i[1] = (s * c - p * a) * v, i[2] = (h * a - s * l) * v, i[3] = d * v, i[4] = (p * r - s * u) * v, i[5] = (s * o - h * r) * v, i[6] = m * v, i[7] = (a * u - c * r) * v, i[8] = (l * r - a * o) * v, this
        },
        transpose: function () {
            var t, e = this.elements;
            return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
        },
        getNormalMatrix: function (t) {
            return this.setFromMatrix4(t).getInverse(this).transpose()
        },
        transposeIntoArray: function (t) {
            var e = this.elements;
            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
        },
        setUvTransform: function (t, e, n, i, r, a, s) {
            var o = Math.cos(r),
                l = Math.sin(r);
            this.set(n * o, n * l, -n * (o * a + l * s) + a + t, -i * l, i * o, -i * (-l * a + o * s) + s + e, 0, 0, 1)
        },
        scale: function (t, e) {
            var n = this.elements;
            return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
        },
        rotate: function (t) {
            var e = Math.cos(t),
                n = Math.sin(t),
                i = this.elements,
                r = i[0],
                a = i[3],
                s = i[6],
                o = i[1],
                l = i[4],
                h = i[7];
            return i[0] = e * r + n * o, i[3] = e * a + n * l, i[6] = e * s + n * h, i[1] = -n * r + e * o, i[4] = -n * a + e * l, i[7] = -n * s + e * h, this
        },
        translate: function (t, e) {
            var n = this.elements;
            return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
        },
        equals: function (t) {
            for (var e = this.elements, n = t.elements, i = 0; i < 9; i++)
                if (e[i] !== n[i]) return !1;
            return !0
        },
        fromArray: function (t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this
        },
        toArray: function (t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
        }
    });
    var Mr = function (t) {
            var e;
            if ("undefined" == typeof HTMLCanvasElement) return t.src;
            if (t instanceof HTMLCanvasElement) e = t;
            else {
                void 0 === xr && (xr = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), xr.width = t.width, xr.height = t.height;
                var n = xr.getContext("2d");
                t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = xr
            }
            return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
        },
        Sr = 0;

    function Tr(t, e, n, i, r, a, s, o, l, h) {
        Object.defineProperty(this, "id", {
            value: Sr++
        }), this.uuid = br.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Tr.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Tr.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : 1001, this.wrapT = void 0 !== i ? i : 1001, this.magFilter = void 0 !== r ? r : 1006, this.minFilter = void 0 !== a ? a : 1008, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== s ? s : 1023, this.internalFormat = null, this.type = void 0 !== o ? o : 1009, this.offset = new wr(0, 0), this.repeat = new wr(1, 1), this.center = new wr(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Dr, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== h ? h : 3e3, this.version = 0, this.onUpdate = null
    }

    function Ar(t, e, n, i, r, a, s, o, l, h, u, c) {
        Tr.call(this, null, a, s, o, l, h, i, r, u, c), this.image = {
            data: t || null,
            width: e || 1,
            height: n || 1
        }, this.magFilter = void 0 !== l ? l : 1003, this.minFilter = void 0 !== h ? h : 1003, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
    }

    function Cr(t, e, n, i) {
        this._x = t || 0, this._y = e || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1
    }
    Tr.DEFAULT_IMAGE = void 0, Tr.DEFAULT_MAPPING = 300, Tr.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: Tr,
        isTexture: !0,
        updateMatrix: function () {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
        },
        toJSON: function (t) {
            var e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var i = this.image;
                if (void 0 === i.uuid && (i.uuid = br.generateUUID()), !e && void 0 === t.images[i.uuid]) {
                    var r;
                    if (Array.isArray(i)) {
                        r = [];
                        for (var a = 0, s = i.length; a < s; a++) r.push(Mr(i[a]))
                    } else r = Mr(i);
                    t.images[i.uuid] = {
                        uuid: i.uuid,
                        url: r
                    }
                }
                n.image = i.uuid
            }
            return e || (t.textures[this.uuid] = n), n
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function (t) {
            if (300 !== this.mapping) return t;
            if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                case 1e3:
                    t.x = t.x - Math.floor(t.x);
                    break;
                case 1001:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                case 1002:
                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
            }
            if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                case 1e3:
                    t.y = t.y - Math.floor(t.y);
                    break;
                case 1001:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                case 1002:
                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
            }
            return this.flipY && (t.y = 1 - t.y), t
        }
    }), Object.defineProperty(Tr.prototype, "needsUpdate", {
        set: function (t) {
            !0 === t && this.version++
        }
    }), Ar.prototype = Object.create(Tr.prototype), Ar.prototype.constructor = Ar, Ar.prototype.isDataTexture = !0, Object.assign(Cr, {
        slerp: function (t, e, n, i) {
            return n.copy(t).slerp(e, i)
        },
        slerpFlat: function (t, e, n, i, r, a, s) {
            var o = n[i + 0],
                l = n[i + 1],
                h = n[i + 2],
                u = n[i + 3],
                c = r[a + 0],
                p = r[a + 1],
                f = r[a + 2],
                d = r[a + 3];
            if (u !== d || o !== c || l !== p || h !== f) {
                var m = 1 - s,
                    g = o * c + l * p + h * f + u * d,
                    v = g >= 0 ? 1 : -1,
                    y = 1 - g * g;
                if (y > Number.EPSILON) {
                    var _ = Math.sqrt(y),
                        x = Math.atan2(_, g * v);
                    m = Math.sin(m * x) / _, s = Math.sin(s * x) / _
                }
                var b = s * v;
                if (o = o * m + c * b, l = l * m + p * b, h = h * m + f * b, u = u * m + d * b, m === 1 - s) {
                    var E = 1 / Math.sqrt(o * o + l * l + h * h + u * u);
                    o *= E, l *= E, h *= E, u *= E
                }
            }
            t[e] = o, t[e + 1] = l, t[e + 2] = h, t[e + 3] = u
        },
        multiplyQuaternionsFlat: function (t, e, n, i, r, a) {
            var s = n[i],
                o = n[i + 1],
                l = n[i + 2],
                h = n[i + 3],
                u = r[a],
                c = r[a + 1],
                p = r[a + 2],
                f = r[a + 3];
            return t[e] = s * f + h * u + o * p - l * c, t[e + 1] = o * f + h * c + l * u - s * p, t[e + 2] = l * f + h * p + s * c - o * u, t[e + 3] = h * f - s * u - o * c - l * p, t
        }
    }), Object.defineProperties(Cr.prototype, {
        x: {
            get: function () {
                return this._x
            },
            set: function (t) {
                this._x = t, this._onChangeCallback()
            }
        },
        y: {
            get: function () {
                return this._y
            },
            set: function (t) {
                this._y = t, this._onChangeCallback()
            }
        },
        z: {
            get: function () {
                return this._z
            },
            set: function (t) {
                this._z = t, this._onChangeCallback()
            }
        },
        w: {
            get: function () {
                return this._w
            },
            set: function (t) {
                this._w = t, this._onChangeCallback()
            }
        }
    }), Object.assign(Cr.prototype, {
        isQuaternion: !0,
        set: function (t, e, n, i) {
            return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
        },
        clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function (t) {
            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
        },
        setFromEuler: function (t, e) {
            if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var n = t._x,
                i = t._y,
                r = t._z,
                a = t.order,
                s = Math.cos,
                o = Math.sin,
                l = s(n / 2),
                h = s(i / 2),
                u = s(r / 2),
                c = o(n / 2),
                p = o(i / 2),
                f = o(r / 2);
            switch (a) {
                case "XYZ":
                    this._x = c * h * u + l * p * f, this._y = l * p * u - c * h * f, this._z = l * h * f + c * p * u, this._w = l * h * u - c * p * f;
                    break;
                case "YXZ":
                    this._x = c * h * u + l * p * f, this._y = l * p * u - c * h * f, this._z = l * h * f - c * p * u, this._w = l * h * u + c * p * f;
                    break;
                case "ZXY":
                    this._x = c * h * u - l * p * f, this._y = l * p * u + c * h * f, this._z = l * h * f + c * p * u, this._w = l * h * u - c * p * f;
                    break;
                case "ZYX":
                    this._x = c * h * u - l * p * f, this._y = l * p * u + c * h * f, this._z = l * h * f - c * p * u, this._w = l * h * u + c * p * f;
                    break;
                case "YZX":
                    this._x = c * h * u + l * p * f, this._y = l * p * u + c * h * f, this._z = l * h * f - c * p * u, this._w = l * h * u - c * p * f;
                    break;
                case "XZY":
                    this._x = c * h * u - l * p * f, this._y = l * p * u - c * h * f, this._z = l * h * f + c * p * u, this._w = l * h * u + c * p * f;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
            }
            return !1 !== e && this._onChangeCallback(), this
        },
        setFromAxisAngle: function (t, e) {
            var n = e / 2,
                i = Math.sin(n);
            return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
        },
        setFromRotationMatrix: function (t) {
            var e, n = t.elements,
                i = n[0],
                r = n[4],
                a = n[8],
                s = n[1],
                o = n[5],
                l = n[9],
                h = n[2],
                u = n[6],
                c = n[10],
                p = i + o + c;
            return p > 0 ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this._x = (u - l) * e, this._y = (a - h) * e, this._z = (s - r) * e) : i > o && i > c ? (e = 2 * Math.sqrt(1 + i - o - c), this._w = (u - l) / e, this._x = .25 * e, this._y = (r + s) / e, this._z = (a + h) / e) : o > c ? (e = 2 * Math.sqrt(1 + o - i - c), this._w = (a - h) / e, this._x = (r + s) / e, this._y = .25 * e, this._z = (l + u) / e) : (e = 2 * Math.sqrt(1 + c - i - o), this._w = (s - r) / e, this._x = (a + h) / e, this._y = (l + u) / e, this._z = .25 * e), this._onChangeCallback(), this
        },
        setFromUnitVectors: function (t, e) {
            var n = t.dot(e) + 1;
            return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
        },
        angleTo: function (t) {
            return 2 * Math.acos(Math.abs(br.clamp(this.dot(t), -1, 1)))
        },
        rotateTowards: function (t, e) {
            var n = this.angleTo(t);
            if (0 === n) return this;
            var i = Math.min(1, e / n);
            return this.slerp(t, i), this
        },
        inverse: function () {
            return this.conjugate()
        },
        conjugate: function () {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        },
        dot: function (t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        },
        lengthSq: function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function () {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function () {
            var t = this.length();
            return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
        },
        multiply: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        },
        premultiply: function (t) {
            return this.multiplyQuaternions(t, this)
        },
        multiplyQuaternions: function (t, e) {
            var n = t._x,
                i = t._y,
                r = t._z,
                a = t._w,
                s = e._x,
                o = e._y,
                l = e._z,
                h = e._w;
            return this._x = n * h + a * s + i * l - r * o, this._y = i * h + a * o + r * s - n * l, this._z = r * h + a * l + n * o - i * s, this._w = a * h - n * s - i * o - r * l, this._onChangeCallback(), this
        },
        slerp: function (t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            var n = this._x,
                i = this._y,
                r = this._z,
                a = this._w,
                s = a * t._w + n * t._x + i * t._y + r * t._z;
            if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = a, this._x = n, this._y = i, this._z = r, this;
            var o = 1 - s * s;
            if (o <= Number.EPSILON) {
                var l = 1 - e;
                return this._w = l * a + e * this._w, this._x = l * n + e * this._x, this._y = l * i + e * this._y, this._z = l * r + e * this._z, this.normalize(), this._onChangeCallback(), this
            }
            var h = Math.sqrt(o),
                u = Math.atan2(h, s),
                c = Math.sin((1 - e) * u) / h,
                p = Math.sin(e * u) / h;
            return this._w = a * c + this._w * p, this._x = n * c + this._x * p, this._y = i * c + this._y * p, this._z = r * c + this._z * p, this._onChangeCallback(), this
        },
        equals: function (t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        },
        fromArray: function (t, e) {
            return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
        },
        toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
        },
        fromBufferAttribute: function (t, e) {
            return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
        },
        _onChange: function (t) {
            return this._onChangeCallback = t, this
        },
        _onChangeCallback: function () {}
    });
    var Pr = new Lr,
        Fr = new Cr;

    function Lr(t, e, n) {
        this.x = t || 0, this.y = e || 0, this.z = n || 0
    }
    Object.assign(Lr.prototype, {
        isVector3: !0,
        set: function (t, e, n) {
            return this.x = t, this.y = e, this.z = n, this
        },
        setScalar: function (t) {
            return this.x = t, this.y = t, this.z = t, this
        },
        setX: function (t) {
            return this.x = t, this
        },
        setY: function (t) {
            return this.y = t, this
        },
        setZ: function (t) {
            return this.z = t, this
        },
        setComponent: function (t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function (t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function (t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this
        },
        add: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
        },
        addScalar: function (t) {
            return this.x += t, this.y += t, this.z += t, this
        },
        addVectors: function (t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
        },
        addScaledVector: function (t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
        },
        sub: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
        },
        subScalar: function (t) {
            return this.x -= t, this.y -= t, this.z -= t, this
        },
        subVectors: function (t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
        },
        multiply: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
        },
        multiplyScalar: function (t) {
            return this.x *= t, this.y *= t, this.z *= t, this
        },
        multiplyVectors: function (t, e) {
            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
        },
        applyEuler: function (t) {
            return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Fr.setFromEuler(t))
        },
        applyAxisAngle: function (t, e) {
            return this.applyQuaternion(Fr.setFromAxisAngle(t, e))
        },
        applyMatrix3: function (t) {
            var e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
        },
        applyNormalMatrix: function (t) {
            return this.applyMatrix3(t).normalize()
        },
        applyMatrix4: function (t) {
            var e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements,
                a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * a, this
        },
        applyQuaternion: function (t) {
            var e = this.x,
                n = this.y,
                i = this.z,
                r = t.x,
                a = t.y,
                s = t.z,
                o = t.w,
                l = o * e + a * i - s * n,
                h = o * n + s * e - r * i,
                u = o * i + r * n - a * e,
                c = -r * e - a * n - s * i;
            return this.x = l * o + c * -r + h * -s - u * -a, this.y = h * o + c * -a + u * -r - l * -s, this.z = u * o + c * -s + l * -a - h * -r, this
        },
        project: function (t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        },
        unproject: function (t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
        },
        transformDirection: function (t) {
            var e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
        },
        divide: function (t) {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
        },
        divideScalar: function (t) {
            return this.multiplyScalar(1 / t)
        },
        min: function (t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
        },
        max: function (t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
        },
        clamp: function (t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
        },
        clampScalar: function (t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
        },
        clampLength: function (t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function (t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function (t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function (t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
        },
        lerpVectors: function (t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        cross: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
        },
        crossVectors: function (t, e) {
            var n = t.x,
                i = t.y,
                r = t.z,
                a = e.x,
                s = e.y,
                o = e.z;
            return this.x = i * o - r * s, this.y = r * a - n * o, this.z = n * s - i * a, this
        },
        projectOnVector: function (t) {
            var e = t.lengthSq();
            if (0 === e) return this.set(0, 0, 0);
            var n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n)
        },
        projectOnPlane: function (t) {
            return Pr.copy(this).projectOnVector(t), this.sub(Pr)
        },
        reflect: function (t) {
            return this.sub(Pr.copy(t).multiplyScalar(2 * this.dot(t)))
        },
        angleTo: function (t) {
            var e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            var n = this.dot(t) / e;
            return Math.acos(br.clamp(n, -1, 1))
        },
        distanceTo: function (t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function (t) {
            var e = this.x - t.x,
                n = this.y - t.y,
                i = this.z - t.z;
            return e * e + n * n + i * i
        },
        manhattanDistanceTo: function (t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        },
        setFromSpherical: function (t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        },
        setFromSphericalCoords: function (t, e, n) {
            var i = Math.sin(e) * t;
            return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
        },
        setFromCylindrical: function (t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        },
        setFromCylindricalCoords: function (t, e, n) {
            return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
        },
        setFromMatrixPosition: function (t) {
            var e = t.elements;
            return this.x = e[12], this.y = e[13], this.z = e[14], this
        },
        setFromMatrixScale: function (t) {
            var e = this.setFromMatrixColumn(t, 0).length(),
                n = this.setFromMatrixColumn(t, 1).length(),
                i = this.setFromMatrixColumn(t, 2).length();
            return this.x = e, this.y = n, this.z = i, this
        },
        setFromMatrixColumn: function (t, e) {
            return this.fromArray(t.elements, 4 * e)
        },
        setFromMatrix3Column: function (t, e) {
            return this.fromArray(t.elements, 3 * e)
        },
        equals: function (t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        },
        fromArray: function (t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
        },
        toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
        },
        fromBufferAttribute: function (t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
        },
        random: function () {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
        }
    });
    var Rr = [new Lr, new Lr, new Lr, new Lr, new Lr, new Lr, new Lr, new Lr],
        Ir = new Lr,
        kr = new Xr,
        Or = new Lr,
        Nr = new Lr,
        Br = new Lr,
        zr = new Lr,
        Ur = new Lr,
        Vr = new Lr,
        Gr = new Lr,
        Hr = new Lr,
        jr = new Lr,
        Wr = new Lr;

    function Xr(t, e) {
        this.min = void 0 !== t ? t : new Lr(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Lr(-1 / 0, -1 / 0, -1 / 0)
    }

    function qr(t, e, n, i, r) {
        var a, s;
        for (a = 0, s = t.length - 3; a <= s; a += 3) {
            Wr.fromArray(t, a);
            var o = r.x * Math.abs(Wr.x) + r.y * Math.abs(Wr.y) + r.z * Math.abs(Wr.z),
                l = e.dot(Wr),
                h = n.dot(Wr),
                u = i.dot(Wr);
            if (Math.max(-Math.max(l, h, u), Math.min(l, h, u)) > o) return !1
        }
        return !0
    }
    Object.assign(Xr.prototype, {
        isBox3: !0,
        set: function (t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromArray: function (t) {
            for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, l = t.length; o < l; o += 3) {
                var h = t[o],
                    u = t[o + 1],
                    c = t[o + 2];
                h < e && (e = h), u < n && (n = u), c < i && (i = c), h > r && (r = h), u > a && (a = u), c > s && (s = c)
            }
            return this.min.set(e, n, i), this.max.set(r, a, s), this
        },
        setFromBufferAttribute: function (t) {
            for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, l = t.count; o < l; o++) {
                var h = t.getX(o),
                    u = t.getY(o),
                    c = t.getZ(o);
                h < e && (e = h), u < n && (n = u), c < i && (i = c), h > r && (r = h), u > a && (a = u), c > s && (s = c)
            }
            return this.min.set(e, n, i), this.max.set(r, a, s), this
        },
        setFromPoints: function (t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function (t, e) {
            var n = Ir.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
        },
        setFromObject: function (t) {
            return this.makeEmpty(), this.expandByObject(t)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function () {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function (t) {
            return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new Lr), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function (t) {
            return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new Lr), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function (t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function (t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function (t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        expandByObject: function (t) {
            t.updateWorldMatrix(!1, !1);
            var e = t.geometry;
            void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), kr.copy(e.boundingBox), kr.applyMatrix4(t.matrixWorld), this.union(kr));
            for (var n = t.children, i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
            return this
        },
        containsPoint: function (t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        },
        containsBox: function (t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        },
        getParameter: function (t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new Lr), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function (t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        },
        intersectsSphere: function (t) {
            return this.clampPoint(t.center, Ir), Ir.distanceToSquared(t.center) <= t.radius * t.radius
        },
        intersectsPlane: function (t) {
            var e, n;
            return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
        },
        intersectsTriangle: function (t) {
            if (this.isEmpty()) return !1;
            this.getCenter(Gr), Hr.subVectors(this.max, Gr), Or.subVectors(t.a, Gr), Nr.subVectors(t.b, Gr), Br.subVectors(t.c, Gr), zr.subVectors(Nr, Or), Ur.subVectors(Br, Nr), Vr.subVectors(Or, Br);
            var e = [0, -zr.z, zr.y, 0, -Ur.z, Ur.y, 0, -Vr.z, Vr.y, zr.z, 0, -zr.x, Ur.z, 0, -Ur.x, Vr.z, 0, -Vr.x, -zr.y, zr.x, 0, -Ur.y, Ur.x, 0, -Vr.y, Vr.x, 0];
            return !!qr(e, Or, Nr, Br, Hr) && (!!qr(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], Or, Nr, Br, Hr) && (jr.crossVectors(zr, Ur), qr(e = [jr.x, jr.y, jr.z], Or, Nr, Br, Hr)))
        },
        clampPoint: function (t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new Lr), e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function (t) {
            return Ir.copy(t).clamp(this.min, this.max).sub(t).length()
        },
        getBoundingSphere: function (t) {
            return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(Ir).length(), t
        },
        intersect: function (t) {
            return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
        },
        union: function (t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        applyMatrix4: function (t) {
            return this.isEmpty() || (Rr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Rr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Rr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Rr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Rr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Rr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Rr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Rr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Rr)), this
        },
        translate: function (t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function (t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    });
    var Yr = new Xr;

    function Zr(t, e) {
        this.center = void 0 !== t ? t : new Lr, this.radius = void 0 !== e ? e : -1
    }
    Object.assign(Zr.prototype, {
        set: function (t, e) {
            return this.center.copy(t), this.radius = e, this
        },
        setFromPoints: function (t, e) {
            var n = this.center;
            void 0 !== e ? n.copy(e) : Yr.setFromPoints(t).getCenter(n);
            for (var i = 0, r = 0, a = t.length; r < a; r++) i = Math.max(i, n.distanceToSquared(t[r]));
            return this.radius = Math.sqrt(i), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.center.copy(t.center), this.radius = t.radius, this
        },
        isEmpty: function () {
            return this.radius < 0
        },
        makeEmpty: function () {
            return this.center.set(0, 0, 0), this.radius = -1, this
        },
        containsPoint: function (t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function (t) {
            return t.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function (t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        },
        intersectsBox: function (t) {
            return t.intersectsSphere(this)
        },
        intersectsPlane: function (t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function (t, e) {
            var n = this.center.distanceToSquared(t);
            return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new Lr), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
        },
        getBoundingBox: function (t) {
            return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new Xr), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
        },
        applyMatrix4: function (t) {
            return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
        },
        translate: function (t) {
            return this.center.add(t), this
        },
        equals: function (t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    });
    var Jr = new Lr,
        Kr = new Lr,
        $r = new Dr;

    function Qr(t, e) {
        this.normal = void 0 !== t ? t : new Lr(1, 0, 0), this.constant = void 0 !== e ? e : 0
    }
    Object.assign(Qr.prototype, {
        isPlane: !0,
        set: function (t, e) {
            return this.normal.copy(t), this.constant = e, this
        },
        setComponents: function (t, e, n, i) {
            return this.normal.set(t, e, n), this.constant = i, this
        },
        setFromNormalAndCoplanarPoint: function (t, e) {
            return this.normal.copy(t), this.constant = -e.dot(this.normal), this
        },
        setFromCoplanarPoints: function (t, e, n) {
            var i = Jr.subVectors(n, e).cross(Kr.subVectors(t, e)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, t), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.normal.copy(t.normal), this.constant = t.constant, this
        },
        normalize: function () {
            var t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), this.constant *= t, this
        },
        negate: function () {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function (t) {
            return this.normal.dot(t) + this.constant
        },
        distanceToSphere: function (t) {
            return this.distanceToPoint(t.center) - t.radius
        },
        projectPoint: function (t, e) {
            return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new Lr), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        },
        intersectLine: function (t, e) {
            void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new Lr);
            var n = t.delta(Jr),
                i = this.normal.dot(n);
            if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
            var r = -(t.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start)
        },
        intersectsLine: function (t) {
            var e = this.distanceToPoint(t.start),
                n = this.distanceToPoint(t.end);
            return e < 0 && n > 0 || n < 0 && e > 0
        },
        intersectsBox: function (t) {
            return t.intersectsPlane(this)
        },
        intersectsSphere: function (t) {
            return t.intersectsPlane(this)
        },
        coplanarPoint: function (t) {
            return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new Lr), t.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function (t, e) {
            var n = e || $r.getNormalMatrix(t),
                i = this.coplanarPoint(Jr).applyMatrix4(t),
                r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(r), this
        },
        translate: function (t) {
            return this.constant -= t.dot(this.normal), this
        },
        equals: function (t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
    });
    var ta = new Zr,
        ea = new Lr;

    function na(t, e, n, i, r, a) {
        this.planes = [void 0 !== t ? t : new Qr, void 0 !== e ? e : new Qr, void 0 !== n ? n : new Qr, void 0 !== i ? i : new Qr, void 0 !== r ? r : new Qr, void 0 !== a ? a : new Qr]
    }
    Object.assign(na.prototype, {
        set: function (t, e, n, i, r, a) {
            var s = this.planes;
            return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(a), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this
        },
        setFromProjectionMatrix: function (t) {
            var e = this.planes,
                n = t.elements,
                i = n[0],
                r = n[1],
                a = n[2],
                s = n[3],
                o = n[4],
                l = n[5],
                h = n[6],
                u = n[7],
                c = n[8],
                p = n[9],
                f = n[10],
                d = n[11],
                m = n[12],
                g = n[13],
                v = n[14],
                y = n[15];
            return e[0].setComponents(s - i, u - o, d - c, y - m).normalize(), e[1].setComponents(s + i, u + o, d + c, y + m).normalize(), e[2].setComponents(s + r, u + l, d + p, y + g).normalize(), e[3].setComponents(s - r, u - l, d - p, y - g).normalize(), e[4].setComponents(s - a, u - h, d - f, y - v).normalize(), e[5].setComponents(s + a, u + h, d + f, y + v).normalize(), this
        },
        intersectsObject: function (t) {
            var e = t.geometry;
            return null === e.boundingSphere && e.computeBoundingSphere(), ta.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(ta)
        },
        intersectsSprite: function (t) {
            return ta.center.set(0, 0, 0), ta.radius = .7071067811865476, ta.applyMatrix4(t.matrixWorld), this.intersectsSphere(ta)
        },
        intersectsSphere: function (t) {
            for (var e = this.planes, n = t.center, i = -t.radius, r = 0; r < 6; r++) {
                if (e[r].distanceToPoint(n) < i) return !1
            }
            return !0
        },
        intersectsBox: function (t) {
            for (var e = this.planes, n = 0; n < 6; n++) {
                var i = e[n];
                if (ea.x = i.normal.x > 0 ? t.max.x : t.min.x, ea.y = i.normal.y > 0 ? t.max.y : t.min.y, ea.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(ea) < 0) return !1
            }
            return !0
        },
        containsPoint: function (t) {
            for (var e = this.planes, n = 0; n < 6; n++)
                if (e[n].distanceToPoint(t) < 0) return !1;
            return !0
        }
    });
    var ia = new Lr,
        ra = new ua,
        aa = new Lr(0, 0, 0),
        sa = new Lr(1, 1, 1),
        oa = new Lr,
        la = new Lr,
        ha = new Lr;

    function ua() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.assign(ua.prototype, {
        isMatrix4: !0,
        set: function (t, e, n, i, r, a, s, o, l, h, u, c, p, f, d, m) {
            var g = this.elements;
            return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = a, g[9] = s, g[13] = o, g[2] = l, g[6] = h, g[10] = u, g[14] = c, g[3] = p, g[7] = f, g[11] = d, g[15] = m, this
        },
        identity: function () {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function () {
            return (new ua).fromArray(this.elements)
        },
        copy: function (t) {
            var e = this.elements,
                n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
        },
        copyPosition: function (t) {
            var e = this.elements,
                n = t.elements;
            return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
        },
        extractBasis: function (t, e, n) {
            return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        },
        makeBasis: function (t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: function (t) {
            var e = this.elements,
                n = t.elements,
                i = 1 / ia.setFromMatrixColumn(t, 0).length(),
                r = 1 / ia.setFromMatrixColumn(t, 1).length(),
                a = 1 / ia.setFromMatrixColumn(t, 2).length();
            return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * a, e[9] = n[9] * a, e[10] = n[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        makeRotationFromEuler: function (t) {
            t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var e = this.elements,
                n = t.x,
                i = t.y,
                r = t.z,
                a = Math.cos(n),
                s = Math.sin(n),
                o = Math.cos(i),
                l = Math.sin(i),
                h = Math.cos(r),
                u = Math.sin(r);
            if ("XYZ" === t.order) {
                var c = a * h,
                    p = a * u,
                    f = s * h,
                    d = s * u;
                e[0] = o * h, e[4] = -o * u, e[8] = l, e[1] = p + f * l, e[5] = c - d * l, e[9] = -s * o, e[2] = d - c * l, e[6] = f + p * l, e[10] = a * o
            } else if ("YXZ" === t.order) {
                var m = o * h,
                    g = o * u,
                    v = l * h,
                    y = l * u;
                e[0] = m + y * s, e[4] = v * s - g, e[8] = a * l, e[1] = a * u, e[5] = a * h, e[9] = -s, e[2] = g * s - v, e[6] = y + m * s, e[10] = a * o
            } else if ("ZXY" === t.order) {
                m = o * h, g = o * u, v = l * h, y = l * u;
                e[0] = m - y * s, e[4] = -a * u, e[8] = v + g * s, e[1] = g + v * s, e[5] = a * h, e[9] = y - m * s, e[2] = -a * l, e[6] = s, e[10] = a * o
            } else if ("ZYX" === t.order) {
                c = a * h, p = a * u, f = s * h, d = s * u;
                e[0] = o * h, e[4] = f * l - p, e[8] = c * l + d, e[1] = o * u, e[5] = d * l + c, e[9] = p * l - f, e[2] = -l, e[6] = s * o, e[10] = a * o
            } else if ("YZX" === t.order) {
                var _ = a * o,
                    x = a * l,
                    b = s * o,
                    E = s * l;
                e[0] = o * h, e[4] = E - _ * u, e[8] = b * u + x, e[1] = u, e[5] = a * h, e[9] = -s * h, e[2] = -l * h, e[6] = x * u + b, e[10] = _ - E * u
            } else if ("XZY" === t.order) {
                _ = a * o, x = a * l, b = s * o, E = s * l;
                e[0] = o * h, e[4] = -u, e[8] = l * h, e[1] = _ * u + E, e[5] = a * h, e[9] = x * u - b, e[2] = b * u - x, e[6] = s * h, e[10] = E * u + _
            }
            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        makeRotationFromQuaternion: function (t) {
            return this.compose(aa, t, sa)
        },
        lookAt: function (t, e, n) {
            var i = this.elements;
            return ha.subVectors(t, e), 0 === ha.lengthSq() && (ha.z = 1), ha.normalize(), oa.crossVectors(n, ha), 0 === oa.lengthSq() && (1 === Math.abs(n.z) ? ha.x += 1e-4 : ha.z += 1e-4, ha.normalize(), oa.crossVectors(n, ha)), oa.normalize(), la.crossVectors(ha, oa), i[0] = oa.x, i[4] = la.x, i[8] = ha.x, i[1] = oa.y, i[5] = la.y, i[9] = ha.y, i[2] = oa.z, i[6] = la.z, i[10] = ha.z, this
        },
        multiply: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        },
        premultiply: function (t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function (t, e) {
            var n = t.elements,
                i = e.elements,
                r = this.elements,
                a = n[0],
                s = n[4],
                o = n[8],
                l = n[12],
                h = n[1],
                u = n[5],
                c = n[9],
                p = n[13],
                f = n[2],
                d = n[6],
                m = n[10],
                g = n[14],
                v = n[3],
                y = n[7],
                _ = n[11],
                x = n[15],
                b = i[0],
                E = i[4],
                w = i[8],
                D = i[12],
                M = i[1],
                S = i[5],
                T = i[9],
                A = i[13],
                C = i[2],
                P = i[6],
                F = i[10],
                L = i[14],
                R = i[3],
                I = i[7],
                k = i[11],
                O = i[15];
            return r[0] = a * b + s * M + o * C + l * R, r[4] = a * E + s * S + o * P + l * I, r[8] = a * w + s * T + o * F + l * k, r[12] = a * D + s * A + o * L + l * O, r[1] = h * b + u * M + c * C + p * R, r[5] = h * E + u * S + c * P + p * I, r[9] = h * w + u * T + c * F + p * k, r[13] = h * D + u * A + c * L + p * O, r[2] = f * b + d * M + m * C + g * R, r[6] = f * E + d * S + m * P + g * I, r[10] = f * w + d * T + m * F + g * k, r[14] = f * D + d * A + m * L + g * O, r[3] = v * b + y * M + _ * C + x * R, r[7] = v * E + y * S + _ * P + x * I, r[11] = v * w + y * T + _ * F + x * k, r[15] = v * D + y * A + _ * L + x * O, this
        },
        multiplyScalar: function (t) {
            var e = this.elements;
            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
        },
        determinant: function () {
            var t = this.elements,
                e = t[0],
                n = t[4],
                i = t[8],
                r = t[12],
                a = t[1],
                s = t[5],
                o = t[9],
                l = t[13],
                h = t[2],
                u = t[6],
                c = t[10],
                p = t[14];
            return t[3] * (+r * o * u - i * l * u - r * s * c + n * l * c + i * s * p - n * o * p) + t[7] * (+e * o * p - e * l * c + r * a * c - i * a * p + i * l * h - r * o * h) + t[11] * (+e * l * u - e * s * p - r * a * u + n * a * p + r * s * h - n * l * h) + t[15] * (-i * s * h - e * o * u + e * s * c + i * a * u - n * a * c + n * o * h)
        },
        transpose: function () {
            var t, e = this.elements;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        },
        setPosition: function (t, e, n) {
            var i = this.elements;
            return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
        },
        getInverse: function (t, e) {
            void 0 !== e && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
            var n = this.elements,
                i = t.elements,
                r = i[0],
                a = i[1],
                s = i[2],
                o = i[3],
                l = i[4],
                h = i[5],
                u = i[6],
                c = i[7],
                p = i[8],
                f = i[9],
                d = i[10],
                m = i[11],
                g = i[12],
                v = i[13],
                y = i[14],
                _ = i[15],
                x = f * y * c - v * d * c + v * u * m - h * y * m - f * u * _ + h * d * _,
                b = g * d * c - p * y * c - g * u * m + l * y * m + p * u * _ - l * d * _,
                E = p * v * c - g * f * c + g * h * m - l * v * m - p * h * _ + l * f * _,
                w = g * f * u - p * v * u - g * h * d + l * v * d + p * h * y - l * f * y,
                D = r * x + a * b + s * E + o * w;
            if (0 === D) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            var M = 1 / D;
            return n[0] = x * M, n[1] = (v * d * o - f * y * o - v * s * m + a * y * m + f * s * _ - a * d * _) * M, n[2] = (h * y * o - v * u * o + v * s * c - a * y * c - h * s * _ + a * u * _) * M, n[3] = (f * u * o - h * d * o - f * s * c + a * d * c + h * s * m - a * u * m) * M, n[4] = b * M, n[5] = (p * y * o - g * d * o + g * s * m - r * y * m - p * s * _ + r * d * _) * M, n[6] = (g * u * o - l * y * o - g * s * c + r * y * c + l * s * _ - r * u * _) * M, n[7] = (l * d * o - p * u * o + p * s * c - r * d * c - l * s * m + r * u * m) * M, n[8] = E * M, n[9] = (g * f * o - p * v * o - g * a * m + r * v * m + p * a * _ - r * f * _) * M, n[10] = (l * v * o - g * h * o + g * a * c - r * v * c - l * a * _ + r * h * _) * M, n[11] = (p * h * o - l * f * o - p * a * c + r * f * c + l * a * m - r * h * m) * M, n[12] = w * M, n[13] = (p * v * s - g * f * s + g * a * d - r * v * d - p * a * y + r * f * y) * M, n[14] = (g * h * s - l * v * s - g * a * u + r * v * u + l * a * y - r * h * y) * M, n[15] = (l * f * s - p * h * s + p * a * u - r * f * u - l * a * d + r * h * d) * M, this
        },
        scale: function (t) {
            var e = this.elements,
                n = t.x,
                i = t.y,
                r = t.z;
            return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
        },
        getMaxScaleOnAxis: function () {
            var t = this.elements,
                e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i))
        },
        makeTranslation: function (t, e, n) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
        },
        makeRotationX: function (t) {
            var e = Math.cos(t),
                n = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function (t) {
            var e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function (t) {
            var e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function (t, e) {
            var n = Math.cos(e),
                i = Math.sin(e),
                r = 1 - n,
                a = t.x,
                s = t.y,
                o = t.z,
                l = r * a,
                h = r * s;
            return this.set(l * a + n, l * s - i * o, l * o + i * s, 0, l * s + i * o, h * s + n, h * o - i * a, 0, l * o - i * s, h * o + i * a, r * o * o + n, 0, 0, 0, 0, 1), this
        },
        makeScale: function (t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        },
        makeShear: function (t, e, n) {
            return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
        },
        compose: function (t, e, n) {
            var i = this.elements,
                r = e._x,
                a = e._y,
                s = e._z,
                o = e._w,
                l = r + r,
                h = a + a,
                u = s + s,
                c = r * l,
                p = r * h,
                f = r * u,
                d = a * h,
                m = a * u,
                g = s * u,
                v = o * l,
                y = o * h,
                _ = o * u,
                x = n.x,
                b = n.y,
                E = n.z;
            return i[0] = (1 - (d + g)) * x, i[1] = (p + _) * x, i[2] = (f - y) * x, i[3] = 0, i[4] = (p - _) * b, i[5] = (1 - (c + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (f + y) * E, i[9] = (m - v) * E, i[10] = (1 - (c + d)) * E, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
        },
        decompose: function (t, e, n) {
            var i = this.elements,
                r = ia.set(i[0], i[1], i[2]).length(),
                a = ia.set(i[4], i[5], i[6]).length(),
                s = ia.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], ra.copy(this);
            var o = 1 / r,
                l = 1 / a,
                h = 1 / s;
            return ra.elements[0] *= o, ra.elements[1] *= o, ra.elements[2] *= o, ra.elements[4] *= l, ra.elements[5] *= l, ra.elements[6] *= l, ra.elements[8] *= h, ra.elements[9] *= h, ra.elements[10] *= h, e.setFromRotationMatrix(ra), n.x = r, n.y = a, n.z = s, this
        },
        makePerspective: function (t, e, n, i, r, a) {
            void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var s = this.elements,
                o = 2 * r / (e - t),
                l = 2 * r / (n - i),
                h = (e + t) / (e - t),
                u = (n + i) / (n - i),
                c = -(a + r) / (a - r),
                p = -2 * a * r / (a - r);
            return s[0] = o, s[4] = 0, s[8] = h, s[12] = 0, s[1] = 0, s[5] = l, s[9] = u, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = c, s[14] = p, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
        },
        makeOrthographic: function (t, e, n, i, r, a) {
            var s = this.elements,
                o = 1 / (e - t),
                l = 1 / (n - i),
                h = 1 / (a - r),
                u = (e + t) * o,
                c = (n + i) * l,
                p = (a + r) * h;
            return s[0] = 2 * o, s[4] = 0, s[8] = 0, s[12] = -u, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -c, s[2] = 0, s[6] = 0, s[10] = -2 * h, s[14] = -p, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
        },
        equals: function (t) {
            for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)
                if (e[i] !== n[i]) return !1;
            return !0
        },
        fromArray: function (t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this
        },
        toArray: function (t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
        }
    });
    var ca = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        },
        pa = {
            h: 0,
            s: 0,
            l: 0
        },
        fa = {
            h: 0,
            s: 0,
            l: 0
        };

    function da(t, e, n) {
        return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
    }

    function ma(t, e, n) {
        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
    }

    function ga(t) {
        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
    }

    function va(t) {
        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
    }
    Object.assign(da.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function (t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
        },
        setScalar: function (t) {
            return this.r = t, this.g = t, this.b = t, this
        },
        setHex: function (t) {
            return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
        },
        setRGB: function (t, e, n) {
            return this.r = t, this.g = e, this.b = n, this
        },
        setHSL: function (t, e, n) {
            if (t = br.euclideanModulo(t, 1), e = br.clamp(e, 0, 1), n = br.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
            else {
                var i = n <= .5 ? n * (1 + e) : n + e - n * e,
                    r = 2 * n - i;
                this.r = ma(r, i, t + 1 / 3), this.g = ma(r, i, t), this.b = ma(r, i, t - 1 / 3)
            }
            return this
        },
        setStyle: function (t) {
            function e(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            var n;
            if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                var i, r = n[1],
                    a = n[2];
                switch (r) {
                    case "rgb":
                    case "rgba":
                        if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
                        if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                            var s = parseFloat(i[1]) / 360,
                                o = parseInt(i[2], 10) / 100,
                                l = parseInt(i[3], 10) / 100;
                            return e(i[5]), this.setHSL(s, o, l)
                        }
                }
            } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                var h = n[1],
                    u = h.length;
                if (3 === u) return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255, this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255, this.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255, this;
                if (6 === u) return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255, this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255, this.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255, this
            }
            return t && t.length > 0 ? this.setColorName(t) : this
        },
        setColorName: function (t) {
            var e = ca[t];
            return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
        },
        clone: function () {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function (t) {
            return this.r = t.r, this.g = t.g, this.b = t.b, this
        },
        copyGammaToLinear: function (t, e) {
            return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
        },
        copyLinearToGamma: function (t, e) {
            void 0 === e && (e = 2);
            var n = e > 0 ? 1 / e : 1;
            return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
        },
        convertGammaToLinear: function (t) {
            return this.copyGammaToLinear(this, t), this
        },
        convertLinearToGamma: function (t) {
            return this.copyLinearToGamma(this, t), this
        },
        copySRGBToLinear: function (t) {
            return this.r = ga(t.r), this.g = ga(t.g), this.b = ga(t.b), this
        },
        copyLinearToSRGB: function (t) {
            return this.r = va(t.r), this.g = va(t.g), this.b = va(t.b), this
        },
        convertSRGBToLinear: function () {
            return this.copySRGBToLinear(this), this
        },
        convertLinearToSRGB: function () {
            return this.copyLinearToSRGB(this), this
        },
        getHex: function () {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function () {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function (t) {
            void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                h: 0,
                s: 0,
                l: 0
            });
            var e, n, i = this.r,
                r = this.g,
                a = this.b,
                s = Math.max(i, r, a),
                o = Math.min(i, r, a),
                l = (o + s) / 2;
            if (o === s) e = 0, n = 0;
            else {
                var h = s - o;
                switch (n = l <= .5 ? h / (s + o) : h / (2 - s - o), s) {
                    case i:
                        e = (r - a) / h + (r < a ? 6 : 0);
                        break;
                    case r:
                        e = (a - i) / h + 2;
                        break;
                    case a:
                        e = (i - r) / h + 4
                }
                e /= 6
            }
            return t.h = e, t.s = n, t.l = l, t
        },
        getStyle: function () {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function (t, e, n) {
            return this.getHSL(pa), pa.h += t, pa.s += e, pa.l += n, this.setHSL(pa.h, pa.s, pa.l), this
        },
        add: function (t) {
            return this.r += t.r, this.g += t.g, this.b += t.b, this
        },
        addColors: function (t, e) {
            return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
        },
        addScalar: function (t) {
            return this.r += t, this.g += t, this.b += t, this
        },
        sub: function (t) {
            return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
        },
        multiply: function (t) {
            return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
        },
        multiplyScalar: function (t) {
            return this.r *= t, this.g *= t, this.b *= t, this
        },
        lerp: function (t, e) {
            return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
        },
        lerpHSL: function (t, e) {
            this.getHSL(pa), t.getHSL(fa);
            var n = br.lerp(pa.h, fa.h, e),
                i = br.lerp(pa.s, fa.s, e),
                r = br.lerp(pa.l, fa.l, e);
            return this.setHSL(n, i, r), this
        },
        equals: function (t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        },
        fromArray: function (t, e) {
            return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
        },
        toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
        },
        toJSON: function () {
            return this.getHex()
        }
    }), da.NAMES = ca;
    var ya = {
        common: {
            diffuse: {
                value: new da(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Dr
            },
            uv2Transform: {
                value: new Dr
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new wr(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new da(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new da(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new Dr
            }
        },
        sprite: {
            diffuse: {
                value: new da(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new wr(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new Dr
            }
        }
    };

    function _a(t, e, n, i) {
        this.x = t || 0, this.y = e || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1
    }
    Object.defineProperties(_a.prototype, {
        width: {
            get: function () {
                return this.z
            },
            set: function (t) {
                this.z = t
            }
        },
        height: {
            get: function () {
                return this.w
            },
            set: function (t) {
                this.w = t
            }
        }
    }), Object.assign(_a.prototype, {
        isVector4: !0,
        set: function (t, e, n, i) {
            return this.x = t, this.y = e, this.z = n, this.w = i, this
        },
        setScalar: function (t) {
            return this.x = t, this.y = t, this.z = t, this.w = t, this
        },
        setX: function (t) {
            return this.x = t, this
        },
        setY: function (t) {
            return this.y = t, this
        },
        setZ: function (t) {
            return this.z = t, this
        },
        setW: function (t) {
            return this.w = t, this
        },
        setComponent: function (t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function (t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function (t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
        },
        add: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
        },
        addScalar: function (t) {
            return this.x += t, this.y += t, this.z += t, this.w += t, this
        },
        addVectors: function (t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
        },
        addScaledVector: function (t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
        },
        sub: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
        },
        subScalar: function (t) {
            return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
        },
        subVectors: function (t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
        },
        multiplyScalar: function (t) {
            return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
        },
        applyMatrix4: function (t) {
            var e = this.x,
                n = this.y,
                i = this.z,
                r = this.w,
                a = t.elements;
            return this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * r, this
        },
        divideScalar: function (t) {
            return this.multiplyScalar(1 / t)
        },
        setAxisAngleFromQuaternion: function (t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
        },
        setAxisAngleFromRotationMatrix: function (t) {
            var e, n, i, r, a = t.elements,
                s = a[0],
                o = a[4],
                l = a[8],
                h = a[1],
                u = a[5],
                c = a[9],
                p = a[2],
                f = a[6],
                d = a[10];
            if (Math.abs(o - h) < .01 && Math.abs(l - p) < .01 && Math.abs(c - f) < .01) {
                if (Math.abs(o + h) < .1 && Math.abs(l + p) < .1 && Math.abs(c + f) < .1 && Math.abs(s + u + d - 3) < .1) return this.set(1, 0, 0, 0), this;
                e = Math.PI;
                var m = (s + 1) / 2,
                    g = (u + 1) / 2,
                    v = (d + 1) / 2,
                    y = (o + h) / 4,
                    _ = (l + p) / 4,
                    x = (c + f) / 4;
                return m > g && m > v ? m < .01 ? (n = 0, i = .707106781, r = .707106781) : (i = y / (n = Math.sqrt(m)), r = _ / n) : g > v ? g < .01 ? (n = .707106781, i = 0, r = .707106781) : (n = y / (i = Math.sqrt(g)), r = x / i) : v < .01 ? (n = .707106781, i = .707106781, r = 0) : (n = _ / (r = Math.sqrt(v)), i = x / r), this.set(n, i, r, e), this
            }
            var b = Math.sqrt((f - c) * (f - c) + (l - p) * (l - p) + (h - o) * (h - o));
            return Math.abs(b) < .001 && (b = 1), this.x = (f - c) / b, this.y = (l - p) / b, this.z = (h - o) / b, this.w = Math.acos((s + u + d - 1) / 2), this
        },
        min: function (t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
        },
        max: function (t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
        },
        clamp: function (t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
        },
        clampScalar: function (t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
        },
        clampLength: function (t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function (t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function (t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function (t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
        },
        lerpVectors: function (t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function (t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        },
        fromArray: function (t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
        },
        toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
        },
        fromBufferAttribute: function (t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
        },
        random: function () {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
        }
    });
    var xa = new ua,
        ba = new Cr;

    function Ea(t, e, n, i) {
        this._x = t || 0, this._y = e || 0, this._z = n || 0, this._order = i || Ea.DefaultOrder
    }

    function wa() {
        this.mask = 1
    }
    Ea.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], Ea.DefaultOrder = "XYZ", Object.defineProperties(Ea.prototype, {
        x: {
            get: function () {
                return this._x
            },
            set: function (t) {
                this._x = t, this._onChangeCallback()
            }
        },
        y: {
            get: function () {
                return this._y
            },
            set: function (t) {
                this._y = t, this._onChangeCallback()
            }
        },
        z: {
            get: function () {
                return this._z
            },
            set: function (t) {
                this._z = t, this._onChangeCallback()
            }
        },
        order: {
            get: function () {
                return this._order
            },
            set: function (t) {
                this._order = t, this._onChangeCallback()
            }
        }
    }), Object.assign(Ea.prototype, {
        isEuler: !0,
        set: function (t, e, n, i) {
            return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this
        },
        clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function (t) {
            return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
        },
        setFromRotationMatrix: function (t, e, n) {
            var i = br.clamp,
                r = t.elements,
                a = r[0],
                s = r[4],
                o = r[8],
                l = r[1],
                h = r[5],
                u = r[9],
                c = r[2],
                p = r[6],
                f = r[10];
            switch (e = e || this._order) {
                case "XYZ":
                    this._y = Math.asin(i(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-s, a)) : (this._x = Math.atan2(p, h), this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-i(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(o, f), this._z = Math.atan2(l, h)) : (this._y = Math.atan2(-c, a), this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(i(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-c, f), this._z = Math.atan2(-s, h)) : (this._y = 0, this._z = Math.atan2(l, a));
                    break;
                case "ZYX":
                    this._y = Math.asin(-i(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-s, h));
                    break;
                case "YZX":
                    this._z = Math.asin(i(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, h), this._y = Math.atan2(-c, a)) : (this._x = 0, this._y = Math.atan2(o, f));
                    break;
                case "XZY":
                    this._z = Math.asin(-i(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(p, h), this._y = Math.atan2(o, a)) : (this._x = Math.atan2(-u, f), this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
            }
            return this._order = e, !1 !== n && this._onChangeCallback(), this
        },
        setFromQuaternion: function (t, e, n) {
            return xa.makeRotationFromQuaternion(t), this.setFromRotationMatrix(xa, e, n)
        },
        setFromVector3: function (t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        },
        reorder: function (t) {
            return ba.setFromEuler(this), this.setFromQuaternion(ba, t)
        },
        equals: function (t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        },
        fromArray: function (t) {
            return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
        },
        toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
        },
        toVector3: function (t) {
            return t ? t.set(this._x, this._y, this._z) : new Lr(this._x, this._y, this._z)
        },
        _onChange: function (t) {
            return this._onChangeCallback = t, this
        },
        _onChangeCallback: function () {}
    }), Object.assign(wa.prototype, {
        set: function (t) {
            this.mask = 1 << t | 0
        },
        enable: function (t) {
            this.mask |= 1 << t | 0
        },
        enableAll: function () {
            this.mask = -1
        },
        toggle: function (t) {
            this.mask ^= 1 << t | 0
        },
        disable: function (t) {
            this.mask &= ~(1 << t | 0)
        },
        disableAll: function () {
            this.mask = 0
        },
        test: function (t) {
            return 0 != (this.mask & t.mask)
        }
    });
    var Da = 0,
        Ma = new Lr,
        Sa = new Cr,
        Ta = new ua,
        Aa = new Lr,
        Ca = new Lr,
        Pa = new Lr,
        Fa = new Cr,
        La = new Lr(1, 0, 0),
        Ra = new Lr(0, 1, 0),
        Ia = new Lr(0, 0, 1),
        ka = {
            type: "added"
        },
        Oa = {
            type: "removed"
        };

    function Na() {
        Object.defineProperty(this, "id", {
            value: Da++
        }), this.uuid = br.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Na.DefaultUp.clone();
        var t = new Lr,
            e = new Ea,
            n = new Cr,
            i = new Lr(1, 1, 1);
        e._onChange((function () {
            n.setFromEuler(e, !1)
        })), n._onChange((function () {
            e.setFromQuaternion(n, void 0, !1)
        })), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new ua
            },
            normalMatrix: {
                value: new Dr
            }
        }), this.matrix = new ua, this.matrixWorld = new ua, this.matrixAutoUpdate = Na.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new wa, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }

    function Ba() {
        Na.call(this), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }

    function za() {
        var t = null,
            e = !1,
            n = null;

        function i(r, a) {
            !1 !== e && (n(r, a), t.requestAnimationFrame(i))
        }
        return {
            start: function () {
                !0 !== e && null !== n && (t.requestAnimationFrame(i), e = !0)
            },
            stop: function () {
                e = !1
            },
            setAnimationLoop: function (t) {
                n = t
            },
            setContext: function (e) {
                t = e
            }
        }
    }

    function Ua(t, e) {
        var n = e.isWebGL2,
            i = new WeakMap;
        return {
            get: function (t) {
                return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
            },
            remove: function (e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var n = i.get(e);
                n && (t.deleteBuffer(n.buffer), i.delete(e))
            },
            update: function (e, r) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var a = i.get(e);
                void 0 === a ? i.set(e, function (e, n) {
                    var i = e.array,
                        r = e.usage,
                        a = t.createBuffer();
                    t.bindBuffer(n, a), t.bufferData(n, i, r), e.onUploadCallback();
                    var s = t.FLOAT;
                    return i instanceof Float32Array ? s = t.FLOAT : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? s = t.UNSIGNED_SHORT : i instanceof Int16Array ? s = t.SHORT : i instanceof Uint32Array ? s = t.UNSIGNED_INT : i instanceof Int32Array ? s = t.INT : i instanceof Int8Array ? s = t.BYTE : i instanceof Uint8Array && (s = t.UNSIGNED_BYTE), {
                        buffer: a,
                        type: s,
                        bytesPerElement: i.BYTES_PER_ELEMENT,
                        version: e.version
                    }
                }(e, r)) : a.version < e.version && (! function (e, i, r) {
                    var a = i.array,
                        s = i.updateRange;
                    t.bindBuffer(r, e), -1 === s.count ? t.bufferSubData(r, 0, a) : (n ? t.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a, s.offset, s.count) : t.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)), s.count = -1)
                }(a.buffer, e, r), a.version = e.version)
            }
        }
    }

    function Va(t, e, n, i, r, a) {
        this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new Lr, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new da, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
    }
    Na.DefaultUp = new Lr(0, 1, 0), Na.DefaultMatrixAutoUpdate = !0, Na.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: Na,
        isObject3D: !0,
        onBeforeRender: function () {},
        onAfterRender: function () {},
        applyMatrix4: function (t) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function (t) {
            return this.quaternion.premultiply(t), this
        },
        setRotationFromAxisAngle: function (t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        },
        setRotationFromEuler: function (t) {
            this.quaternion.setFromEuler(t, !0)
        },
        setRotationFromMatrix: function (t) {
            this.quaternion.setFromRotationMatrix(t)
        },
        setRotationFromQuaternion: function (t) {
            this.quaternion.copy(t)
        },
        rotateOnAxis: function (t, e) {
            return Sa.setFromAxisAngle(t, e), this.quaternion.multiply(Sa), this
        },
        rotateOnWorldAxis: function (t, e) {
            return Sa.setFromAxisAngle(t, e), this.quaternion.premultiply(Sa), this
        },
        rotateX: function (t) {
            return this.rotateOnAxis(La, t)
        },
        rotateY: function (t) {
            return this.rotateOnAxis(Ra, t)
        },
        rotateZ: function (t) {
            return this.rotateOnAxis(Ia, t)
        },
        translateOnAxis: function (t, e) {
            return Ma.copy(t).applyQuaternion(this.quaternion), this.position.add(Ma.multiplyScalar(e)), this
        },
        translateX: function (t) {
            return this.translateOnAxis(La, t)
        },
        translateY: function (t) {
            return this.translateOnAxis(Ra, t)
        },
        translateZ: function (t) {
            return this.translateOnAxis(Ia, t)
        },
        localToWorld: function (t) {
            return t.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function (t) {
            return t.applyMatrix4(Ta.getInverse(this.matrixWorld))
        },
        lookAt: function (t, e, n) {
            t.isVector3 ? Aa.copy(t) : Aa.set(t, e, n);
            var i = this.parent;
            this.updateWorldMatrix(!0, !1), Ca.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ta.lookAt(Ca, Aa, this.up) : Ta.lookAt(Aa, Ca, this.up), this.quaternion.setFromRotationMatrix(Ta), i && (Ta.extractRotation(i.matrixWorld), Sa.setFromRotationMatrix(Ta), this.quaternion.premultiply(Sa.inverse()))
        },
        add: function (t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                return this
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(ka)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
        },
        remove: function (t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                return this
            }
            var n = this.children.indexOf(t);
            return -1 !== n && (t.parent = null, this.children.splice(n, 1), t.dispatchEvent(Oa)), this
        },
        attach: function (t) {
            return this.updateWorldMatrix(!0, !1), Ta.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Ta.multiply(t.parent.matrixWorld)), t.applyMatrix4(Ta), t.updateWorldMatrix(!1, !1), this.add(t), this
        },
        getObjectById: function (t) {
            return this.getObjectByProperty("id", t)
        },
        getObjectByName: function (t) {
            return this.getObjectByProperty("name", t)
        },
        getObjectByProperty: function (t, e) {
            if (this[t] === e) return this;
            for (var n = 0, i = this.children.length; n < i; n++) {
                var r = this.children[n].getObjectByProperty(t, e);
                if (void 0 !== r) return r
            }
        },
        getWorldPosition: function (t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new Lr), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function (t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new Cr), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Ca, t, Pa), t
        },
        getWorldScale: function (t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new Lr), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Ca, Fa, t), t
        },
        getWorldDirection: function (t) {
            void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new Lr), this.updateMatrixWorld(!0);
            var e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize()
        },
        raycast: function () {},
        traverse: function (t) {
            t(this);
            for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverse(t)
        },
        traverseVisible: function (t) {
            if (!1 !== this.visible) {
                t(this);
                for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
            }
        },
        traverseAncestors: function (t) {
            var e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t))
        },
        updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function (t) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
            for (var e = this.children, n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
        },
        updateWorldMatrix: function (t, e) {
            var n = this.parent;
            if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                for (var i = this.children, r = 0, a = i.length; r < a; r++) i[r].updateWorldMatrix(!1, !0)
        },
        toJSON: function (t) {
            var e = void 0 === t || "string" == typeof t,
                n = {};
            e && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            }, n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var i = {};

            function r(e, n) {
                return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
            }
            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                i.geometry = r(t.geometries, this.geometry);
                var a = this.geometry.parameters;
                if (void 0 !== a && void 0 !== a.shapes) {
                    var s = a.shapes;
                    if (Array.isArray(s))
                        for (var o = 0, l = s.length; o < l; o++) {
                            var h = s[o];
                            r(t.shapes, h)
                        } else r(t.shapes, s)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    var u = [];
                    for (o = 0, l = this.material.length; o < l; o++) u.push(r(t.materials, this.material[o]));
                    i.material = u
                } else i.material = r(t.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (o = 0; o < this.children.length; o++) i.children.push(this.children[o].toJSON(t).object)
            }
            if (e) {
                var c = m(t.geometries),
                    p = m(t.materials),
                    f = m(t.textures),
                    d = m(t.images);
                s = m(t.shapes);
                c.length > 0 && (n.geometries = c), p.length > 0 && (n.materials = p), f.length > 0 && (n.textures = f), d.length > 0 && (n.images = d), s.length > 0 && (n.shapes = s)
            }
            return n.object = i, n;

            function m(t) {
                var e = [];
                for (var n in t) {
                    var i = t[n];
                    delete i.metadata, e.push(i)
                }
                return e
            }
        },
        clone: function (t) {
            return (new this.constructor).copy(this, t)
        },
        copy: function (t, e) {
            if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                for (var n = 0; n < t.children.length; n++) {
                    var i = t.children[n];
                    this.add(i.clone())
                }
            return this
        }
    }), Ba.prototype = Object.assign(Object.create(Na.prototype), {
        constructor: Ba,
        isScene: !0,
        copy: function (t, e) {
            return Na.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
        },
        toJSON: function (t) {
            var e = Na.prototype.toJSON.call(this, t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.assign(Va.prototype, {
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
            for (var e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
            return this
        }
    });
    var Ga = 0,
        Ha = new ua,
        ja = new Na,
        Wa = new Lr;

    function Xa() {
        Object.defineProperty(this, "id", {
            value: Ga += 2
        }), this.uuid = br.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
    }
    Xa.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: Xa,
        isGeometry: !0,
        applyMatrix4: function (t) {
            for (var e = (new Dr).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++) {
                this.vertices[n].applyMatrix4(t)
            }
            for (n = 0, i = this.faces.length; n < i; n++) {
                var r = this.faces[n];
                r.normal.applyMatrix3(e).normalize();
                for (var a = 0, s = r.vertexNormals.length; a < s; a++) r.vertexNormals[a].applyMatrix3(e).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
        },
        rotateX: function (t) {
            return Ha.makeRotationX(t), this.applyMatrix4(Ha), this
        },
        rotateY: function (t) {
            return Ha.makeRotationY(t), this.applyMatrix4(Ha), this
        },
        rotateZ: function (t) {
            return Ha.makeRotationZ(t), this.applyMatrix4(Ha), this
        },
        translate: function (t, e, n) {
            return Ha.makeTranslation(t, e, n), this.applyMatrix4(Ha), this
        },
        scale: function (t, e, n) {
            return Ha.makeScale(t, e, n), this.applyMatrix4(Ha), this
        },
        lookAt: function (t) {
            return ja.lookAt(t), ja.updateMatrix(), this.applyMatrix4(ja.matrix), this
        },
        fromBufferGeometry: function (t) {
            var e = this,
                n = null !== t.index ? t.index.array : void 0,
                i = t.attributes;
            if (void 0 === i.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
            var r = i.position.array,
                a = void 0 !== i.normal ? i.normal.array : void 0,
                s = void 0 !== i.color ? i.color.array : void 0,
                o = void 0 !== i.uv ? i.uv.array : void 0,
                l = void 0 !== i.uv2 ? i.uv2.array : void 0;
            void 0 !== l && (this.faceVertexUvs[1] = []);
            for (var h = 0; h < r.length; h += 3) e.vertices.push((new Lr).fromArray(r, h)), void 0 !== s && e.colors.push((new da).fromArray(s, h));

            function u(t, n, i, r) {
                var h = void 0 === s ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()],
                    u = new Va(t, n, i, void 0 === a ? [] : [(new Lr).fromArray(a, 3 * t), (new Lr).fromArray(a, 3 * n), (new Lr).fromArray(a, 3 * i)], h, r);
                e.faces.push(u), void 0 !== o && e.faceVertexUvs[0].push([(new wr).fromArray(o, 2 * t), (new wr).fromArray(o, 2 * n), (new wr).fromArray(o, 2 * i)]), void 0 !== l && e.faceVertexUvs[1].push([(new wr).fromArray(l, 2 * t), (new wr).fromArray(l, 2 * n), (new wr).fromArray(l, 2 * i)])
            }
            var c = t.groups;
            if (c.length > 0)
                for (h = 0; h < c.length; h++)
                    for (var p = c[h], f = p.start, d = f, m = f + p.count; d < m; d += 3) void 0 !== n ? u(n[d], n[d + 1], n[d + 2], p.materialIndex) : u(d, d + 1, d + 2, p.materialIndex);
            else if (void 0 !== n)
                for (h = 0; h < n.length; h += 3) u(n[h], n[h + 1], n[h + 2]);
            else
                for (h = 0; h < r.length / 3; h += 3) u(h, h + 1, h + 2);
            return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
        },
        center: function () {
            return this.computeBoundingBox(), this.boundingBox.getCenter(Wa).negate(), this.translate(Wa.x, Wa.y, Wa.z), this
        },
        normalize: function () {
            this.computeBoundingSphere();
            var t = this.boundingSphere.center,
                e = this.boundingSphere.radius,
                n = 0 === e ? 1 : 1 / e,
                i = new ua;
            return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(i), this
        },
        computeFaceNormals: function () {
            for (var t = new Lr, e = new Lr, n = 0, i = this.faces.length; n < i; n++) {
                var r = this.faces[n],
                    a = this.vertices[r.a],
                    s = this.vertices[r.b],
                    o = this.vertices[r.c];
                t.subVectors(o, s), e.subVectors(a, s), t.cross(e), t.normalize(), r.normal.copy(t)
            }
        },
        computeVertexNormals: function (t) {
            var e, n, i, r, a, s;
            for (void 0 === t && (t = !0), s = new Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++) s[e] = new Lr;
            if (t) {
                var o, l, h, u = new Lr,
                    c = new Lr;
                for (i = 0, r = this.faces.length; i < r; i++) a = this.faces[i], o = this.vertices[a.a], l = this.vertices[a.b], h = this.vertices[a.c], u.subVectors(h, l), c.subVectors(o, l), u.cross(c), s[a.a].add(u), s[a.b].add(u), s[a.c].add(u)
            } else
                for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++) s[(a = this.faces[i]).a].add(a.normal), s[a.b].add(a.normal), s[a.c].add(a.normal);
            for (e = 0, n = this.vertices.length; e < n; e++) s[e].normalize();
            for (i = 0, r = this.faces.length; i < r; i++) {
                var p = (a = this.faces[i]).vertexNormals;
                3 === p.length ? (p[0].copy(s[a.a]), p[1].copy(s[a.b]), p[2].copy(s[a.c])) : (p[0] = s[a.a].clone(), p[1] = s[a.b].clone(), p[2] = s[a.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function () {
            var t, e, n;
            for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                var i = (n = this.faces[t]).vertexNormals;
                3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function () {
            var t, e, n, i, r;
            for (n = 0, i = this.faces.length; n < i; n++)
                for ((r = this.faces[n]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
            var a = new Xa;
            for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                if (!this.morphNormals[t]) {
                    this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                    var s = this.morphNormals[t].faceNormals,
                        o = this.morphNormals[t].vertexNormals;
                    for (n = 0, i = this.faces.length; n < i; n++) l = new Lr, h = {
                        a: new Lr,
                        b: new Lr,
                        c: new Lr
                    }, s.push(l), o.push(h)
                }
                var l, h, u = this.morphNormals[t];
                for (a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a.computeVertexNormals(), n = 0, i = this.faces.length; n < i; n++) r = this.faces[n], l = u.faceNormals[n], h = u.vertexNormals[n], l.copy(r.normal), h.a.copy(r.vertexNormals[0]), h.b.copy(r.vertexNormals[1]), h.c.copy(r.vertexNormals[2])
            }
            for (n = 0, i = this.faces.length; n < i; n++)(r = this.faces[n]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
        },
        computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new Xr), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new Zr), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function (t, e, n) {
            if (t && t.isGeometry) {
                var i, r = this.vertices.length,
                    a = this.vertices,
                    s = t.vertices,
                    o = this.faces,
                    l = t.faces,
                    h = this.colors,
                    u = t.colors;
                void 0 === n && (n = 0), void 0 !== e && (i = (new Dr).getNormalMatrix(e));
                for (var c = 0, p = s.length; c < p; c++) {
                    var f = s[c].clone();
                    void 0 !== e && f.applyMatrix4(e), a.push(f)
                }
                for (c = 0, p = u.length; c < p; c++) h.push(u[c].clone());
                for (c = 0, p = l.length; c < p; c++) {
                    var d, m, g, v = l[c],
                        y = v.vertexNormals,
                        _ = v.vertexColors;
                    (d = new Va(v.a + r, v.b + r, v.c + r)).normal.copy(v.normal), void 0 !== i && d.normal.applyMatrix3(i).normalize();
                    for (var x = 0, b = y.length; x < b; x++) m = y[x].clone(), void 0 !== i && m.applyMatrix3(i).normalize(), d.vertexNormals.push(m);
                    d.color.copy(v.color);
                    for (x = 0, b = _.length; x < b; x++) g = _[x], d.vertexColors.push(g.clone());
                    d.materialIndex = v.materialIndex + n, o.push(d)
                }
                for (c = 0, p = t.faceVertexUvs.length; c < p; c++) {
                    var E = t.faceVertexUvs[c];
                    void 0 === this.faceVertexUvs[c] && (this.faceVertexUvs[c] = []);
                    for (x = 0, b = E.length; x < b; x++) {
                        for (var w = E[x], D = [], M = 0, S = w.length; M < S; M++) D.push(w[M].clone());
                        this.faceVertexUvs[c].push(D)
                    }
                }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
        },
        mergeMesh: function (t) {
            t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
        },
        mergeVertices: function () {
            var t, e, n, i, r, a, s, o, l = {},
                h = [],
                u = [],
                c = Math.pow(10, 4);
            for (n = 0, i = this.vertices.length; n < i; n++) t = this.vertices[n], void 0 === l[e = Math.round(t.x * c) + "_" + Math.round(t.y * c) + "_" + Math.round(t.z * c)] ? (l[e] = n, h.push(this.vertices[n]), u[n] = h.length - 1) : u[n] = u[l[e]];
            var p = [];
            for (n = 0, i = this.faces.length; n < i; n++) {
                (r = this.faces[n]).a = u[r.a], r.b = u[r.b], r.c = u[r.c], a = [r.a, r.b, r.c];
                for (var f = 0; f < 3; f++)
                    if (a[f] === a[(f + 1) % 3]) {
                        p.push(n);
                        break
                    }
            }
            for (n = p.length - 1; n >= 0; n--) {
                var d = p[n];
                for (this.faces.splice(d, 1), s = 0, o = this.faceVertexUvs.length; s < o; s++) this.faceVertexUvs[s].splice(d, 1)
            }
            var m = this.vertices.length - h.length;
            return this.vertices = h, m
        },
        setFromPoints: function (t) {
            this.vertices = [];
            for (var e = 0, n = t.length; e < n; e++) {
                var i = t[e];
                this.vertices.push(new Lr(i.x, i.y, i.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function () {
            for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
            t.sort((function (t, e) {
                return t.materialIndex - e.materialIndex
            }));
            var i, r, a = this.faceVertexUvs[0],
                s = this.faceVertexUvs[1];
            a && a.length === e && (i = []), s && s.length === e && (r = []);
            for (n = 0; n < e; n++) {
                var o = t[n]._id;
                i && i.push(a[o]), r && r.push(s[o])
            }
            i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r)
        },
        toJSON: function () {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                var e = this.parameters;
                for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            for (var i = [], r = 0; r < this.vertices.length; r++) {
                var a = this.vertices[r];
                i.push(a.x, a.y, a.z)
            }
            var s = [],
                o = [],
                l = {},
                h = [],
                u = {},
                c = [],
                p = {};
            for (r = 0; r < this.faces.length; r++) {
                var f = this.faces[r],
                    d = void 0 !== this.faceVertexUvs[0][r],
                    m = f.normal.length() > 0,
                    g = f.vertexNormals.length > 0,
                    v = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                    y = f.vertexColors.length > 0,
                    _ = 0;
                if (_ = w(_, 0, 0), _ = w(_, 1, !0), _ = w(_, 2, !1), _ = w(_, 3, d), _ = w(_, 4, m), _ = w(_, 5, g), _ = w(_, 6, v), _ = w(_, 7, y), s.push(_), s.push(f.a, f.b, f.c), s.push(f.materialIndex), d) {
                    var x = this.faceVertexUvs[0][r];
                    s.push(S(x[0]), S(x[1]), S(x[2]))
                }
                if (m && s.push(D(f.normal)), g) {
                    var b = f.vertexNormals;
                    s.push(D(b[0]), D(b[1]), D(b[2]))
                }
                if (v && s.push(M(f.color)), y) {
                    var E = f.vertexColors;
                    s.push(M(E[0]), M(E[1]), M(E[2]))
                }
            }

            function w(t, e, n) {
                return n ? t | 1 << e : t & ~(1 << e)
            }

            function D(t) {
                var e = t.x.toString() + t.y.toString() + t.z.toString();
                return void 0 !== l[e] || (l[e] = o.length / 3, o.push(t.x, t.y, t.z)), l[e]
            }

            function M(t) {
                var e = t.r.toString() + t.g.toString() + t.b.toString();
                return void 0 !== u[e] || (u[e] = h.length, h.push(t.getHex())), u[e]
            }

            function S(t) {
                var e = t.x.toString() + t.y.toString();
                return void 0 !== p[e] || (p[e] = c.length / 2, c.push(t.x, t.y)), p[e]
            }
            return t.data = {}, t.data.vertices = i, t.data.normals = o, h.length > 0 && (t.data.colors = h), c.length > 0 && (t.data.uvs = [c]), t.data.faces = s, t
        },
        clone: function () {
            return (new Xa).copy(this)
        },
        copy: function (t) {
            var e, n, i, r, a, s;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
            var o = t.vertices;
            for (e = 0, n = o.length; e < n; e++) this.vertices.push(o[e].clone());
            var l = t.colors;
            for (e = 0, n = l.length; e < n; e++) this.colors.push(l[e].clone());
            var h = t.faces;
            for (e = 0, n = h.length; e < n; e++) this.faces.push(h[e].clone());
            for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                var u = t.faceVertexUvs[e];
                for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), i = 0, r = u.length; i < r; i++) {
                    var c = u[i],
                        p = [];
                    for (a = 0, s = c.length; a < s; a++) {
                        var f = c[a];
                        p.push(f.clone())
                    }
                    this.faceVertexUvs[e].push(p)
                }
            }
            var d = t.morphTargets;
            for (e = 0, n = d.length; e < n; e++) {
                var m = {};
                if (m.name = d[e].name, void 0 !== d[e].vertices)
                    for (m.vertices = [], i = 0, r = d[e].vertices.length; i < r; i++) m.vertices.push(d[e].vertices[i].clone());
                if (void 0 !== d[e].normals)
                    for (m.normals = [], i = 0, r = d[e].normals.length; i < r; i++) m.normals.push(d[e].normals[i].clone());
                this.morphTargets.push(m)
            }
            var g = t.morphNormals;
            for (e = 0, n = g.length; e < n; e++) {
                var v = {};
                if (void 0 !== g[e].vertexNormals)
                    for (v.vertexNormals = [], i = 0, r = g[e].vertexNormals.length; i < r; i++) {
                        var y = g[e].vertexNormals[i],
                            _ = {};
                        _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), v.vertexNormals.push(_)
                    }
                if (void 0 !== g[e].faceNormals)
                    for (v.faceNormals = [], i = 0, r = g[e].faceNormals.length; i < r; i++) v.faceNormals.push(g[e].faceNormals[i].clone());
                this.morphNormals.push(v)
            }
            var x = t.skinWeights;
            for (e = 0, n = x.length; e < n; e++) this.skinWeights.push(x[e].clone());
            var b = t.skinIndices;
            for (e = 0, n = b.length; e < n; e++) this.skinIndices.push(b[e].clone());
            var E = t.lineDistances;
            for (e = 0, n = E.length; e < n; e++) this.lineDistances.push(E[e]);
            var w = t.boundingBox;
            null !== w && (this.boundingBox = w.clone());
            var D = t.boundingSphere;
            return null !== D && (this.boundingSphere = D.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var qa = new Lr;

    function Ya(t, e, n) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = 35044, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function Za(t, e, n) {
        Ya.call(this, new Int8Array(t), e, n)
    }

    function Ja(t, e, n) {
        Ya.call(this, new Uint8Array(t), e, n)
    }

    function Ka(t, e, n) {
        Ya.call(this, new Uint8ClampedArray(t), e, n)
    }

    function $a(t, e, n) {
        Ya.call(this, new Int16Array(t), e, n)
    }

    function Qa(t, e, n) {
        Ya.call(this, new Uint16Array(t), e, n)
    }

    function ts(t, e, n) {
        Ya.call(this, new Int32Array(t), e, n)
    }

    function es(t, e, n) {
        Ya.call(this, new Uint32Array(t), e, n)
    }

    function ns(t, e, n) {
        Ya.call(this, new Float32Array(t), e, n)
    }

    function is(t, e, n) {
        Ya.call(this, new Float64Array(t), e, n)
    }

    function rs() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function as(t) {
        if (0 === t.length) return -1 / 0;
        for (var e = t[0], n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
        return e
    }
    Object.defineProperty(Ya.prototype, "needsUpdate", {
        set: function (t) {
            !0 === t && this.version++
        }
    }), Object.assign(Ya.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function () {},
        setUsage: function (t) {
            return this.usage = t, this
        },
        copy: function (t) {
            return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
        },
        copyAt: function (t, e, n) {
            t *= this.itemSize, n *= e.itemSize;
            for (var i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
            return this
        },
        copyArray: function (t) {
            return this.array.set(t), this
        },
        copyColorsArray: function (t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var a = t[i];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), a = new da), e[n++] = a.r, e[n++] = a.g, e[n++] = a.b
            }
            return this
        },
        copyVector2sArray: function (t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var a = t[i];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), a = new wr), e[n++] = a.x, e[n++] = a.y
            }
            return this
        },
        copyVector3sArray: function (t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var a = t[i];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), a = new Lr), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z
            }
            return this
        },
        copyVector4sArray: function (t) {
            for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                var a = t[i];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), a = new _a), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z, e[n++] = a.w
            }
            return this
        },
        applyMatrix3: function (t) {
            for (var e = 0, n = this.count; e < n; e++) qa.x = this.getX(e), qa.y = this.getY(e), qa.z = this.getZ(e), qa.applyMatrix3(t), this.setXYZ(e, qa.x, qa.y, qa.z);
            return this
        },
        applyMatrix4: function (t) {
            for (var e = 0, n = this.count; e < n; e++) qa.x = this.getX(e), qa.y = this.getY(e), qa.z = this.getZ(e), qa.applyMatrix4(t), this.setXYZ(e, qa.x, qa.y, qa.z);
            return this
        },
        applyNormalMatrix: function (t) {
            for (var e = 0, n = this.count; e < n; e++) qa.x = this.getX(e), qa.y = this.getY(e), qa.z = this.getZ(e), qa.applyNormalMatrix(t), this.setXYZ(e, qa.x, qa.y, qa.z);
            return this
        },
        transformDirection: function (t) {
            for (var e = 0, n = this.count; e < n; e++) qa.x = this.getX(e), qa.y = this.getY(e), qa.z = this.getZ(e), qa.transformDirection(t), this.setXYZ(e, qa.x, qa.y, qa.z);
            return this
        },
        set: function (t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        },
        getX: function (t) {
            return this.array[t * this.itemSize]
        },
        setX: function (t, e) {
            return this.array[t * this.itemSize] = e, this
        },
        getY: function (t) {
            return this.array[t * this.itemSize + 1]
        },
        setY: function (t, e) {
            return this.array[t * this.itemSize + 1] = e, this
        },
        getZ: function (t) {
            return this.array[t * this.itemSize + 2]
        },
        setZ: function (t, e) {
            return this.array[t * this.itemSize + 2] = e, this
        },
        getW: function (t) {
            return this.array[t * this.itemSize + 3]
        },
        setW: function (t, e) {
            return this.array[t * this.itemSize + 3] = e, this
        },
        setXY: function (t, e, n) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
        },
        setXYZ: function (t, e, n, i) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
        },
        setXYZW: function (t, e, n, i, r) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
        },
        onUpload: function (t) {
            return this.onUploadCallback = t, this
        },
        clone: function () {
            return new this.constructor(this.array, this.itemSize).copy(this)
        },
        toJSON: function () {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }), Za.prototype = Object.create(Ya.prototype), Za.prototype.constructor = Za, Ja.prototype = Object.create(Ya.prototype), Ja.prototype.constructor = Ja, Ka.prototype = Object.create(Ya.prototype), Ka.prototype.constructor = Ka, $a.prototype = Object.create(Ya.prototype), $a.prototype.constructor = $a, Qa.prototype = Object.create(Ya.prototype), Qa.prototype.constructor = Qa, ts.prototype = Object.create(Ya.prototype), ts.prototype.constructor = ts, es.prototype = Object.create(Ya.prototype), es.prototype.constructor = es, ns.prototype = Object.create(Ya.prototype), ns.prototype.constructor = ns, is.prototype = Object.create(Ya.prototype), is.prototype.constructor = is, Object.assign(rs.prototype, {
        computeGroups: function (t) {
            for (var e, n = [], i = void 0, r = t.faces, a = 0; a < r.length; a++) {
                var s = r[a];
                s.materialIndex !== i && (i = s.materialIndex, void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), e = {
                    start: 3 * a,
                    materialIndex: i
                })
            }
            void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), this.groups = n
        },
        fromGeometry: function (t) {
            var e, n = t.faces,
                i = t.vertices,
                r = t.faceVertexUvs,
                a = r[0] && r[0].length > 0,
                s = r[1] && r[1].length > 0,
                o = t.morphTargets,
                l = o.length;
            if (l > 0) {
                e = [];
                for (var h = 0; h < l; h++) e[h] = {
                    name: o[h].name,
                    data: []
                };
                this.morphTargets.position = e
            }
            var u, c = t.morphNormals,
                p = c.length;
            if (p > 0) {
                u = [];
                for (h = 0; h < p; h++) u[h] = {
                    name: c[h].name,
                    data: []
                };
                this.morphTargets.normal = u
            }
            var f = t.skinIndices,
                d = t.skinWeights,
                m = f.length === i.length,
                g = d.length === i.length;
            i.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
            for (h = 0; h < n.length; h++) {
                var v = n[h];
                this.vertices.push(i[v.a], i[v.b], i[v.c]);
                var y = v.vertexNormals;
                if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                else {
                    var _ = v.normal;
                    this.normals.push(_, _, _)
                }
                var x, b = v.vertexColors;
                if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                else {
                    var E = v.color;
                    this.colors.push(E, E, E)
                }
                if (!0 === a) void 0 !== (x = r[0][h]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new wr, new wr, new wr));
                if (!0 === s) void 0 !== (x = r[1][h]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new wr, new wr, new wr));
                for (var w = 0; w < l; w++) {
                    var D = o[w].vertices;
                    e[w].data.push(D[v.a], D[v.b], D[v.c])
                }
                for (w = 0; w < p; w++) {
                    var M = c[w].vertexNormals[h];
                    u[w].data.push(M.a, M.b, M.c)
                }
                m && this.skinIndices.push(f[v.a], f[v.b], f[v.c]), g && this.skinWeights.push(d[v.a], d[v.b], d[v.c])
            }
            return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
        }
    });
    var ss = 1,
        os = new ua,
        ls = new Na,
        hs = new Lr,
        us = new Xr,
        cs = new Xr,
        ps = new Lr;

    function fs() {
        Object.defineProperty(this, "id", {
            value: ss += 2
        }), this.uuid = br.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    fs.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: fs,
        isBufferGeometry: !0,
        getIndex: function () {
            return this.index
        },
        setIndex: function (t) {
            Array.isArray(t) ? this.index = new(as(t) > 65535 ? es : Qa)(t, 1) : this.index = t
        },
        getAttribute: function (t) {
            return this.attributes[t]
        },
        setAttribute: function (t, e) {
            return this.attributes[t] = e, this
        },
        deleteAttribute: function (t) {
            return delete this.attributes[t], this
        },
        addGroup: function (t, e, n) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: void 0 !== n ? n : 0
            })
        },
        clearGroups: function () {
            this.groups = []
        },
        setDrawRange: function (t, e) {
            this.drawRange.start = t, this.drawRange.count = e
        },
        applyMatrix4: function (t) {
            var e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
            var n = this.attributes.normal;
            if (void 0 !== n) {
                var i = (new Dr).getNormalMatrix(t);
                n.applyNormalMatrix(i), n.needsUpdate = !0
            }
            var r = this.attributes.tangent;
            return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function (t) {
            return os.makeRotationX(t), this.applyMatrix4(os), this
        },
        rotateY: function (t) {
            return os.makeRotationY(t), this.applyMatrix4(os), this
        },
        rotateZ: function (t) {
            return os.makeRotationZ(t), this.applyMatrix4(os), this
        },
        translate: function (t, e, n) {
            return os.makeTranslation(t, e, n), this.applyMatrix4(os), this
        },
        scale: function (t, e, n) {
            return os.makeScale(t, e, n), this.applyMatrix4(os), this
        },
        lookAt: function (t) {
            return ls.lookAt(t), ls.updateMatrix(), this.applyMatrix4(ls.matrix), this
        },
        center: function () {
            return this.computeBoundingBox(), this.boundingBox.getCenter(hs).negate(), this.translate(hs.x, hs.y, hs.z), this
        },
        setFromObject: function (t) {
            var e = t.geometry;
            if (t.isPoints || t.isLine) {
                var n = new ns(3 * e.vertices.length, 3),
                    i = new ns(3 * e.colors.length, 3);
                if (this.setAttribute("position", n.copyVector3sArray(e.vertices)), this.setAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                    var r = new ns(e.lineDistances.length, 1);
                    this.setAttribute("lineDistance", r.copyArray(e.lineDistances))
                }
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
            } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
            return this
        },
        setFromPoints: function (t) {
            for (var e = [], n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                e.push(r.x, r.y, r.z || 0)
            }
            return this.setAttribute("position", new ns(e, 3)), this
        },
        updateFromObject: function (t) {
            var e, n = t.geometry;
            if (t.isMesh) {
                var i = n.__directGeometry;
                if (!0 === n.elementsNeedUpdate && (i = void 0, n.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(n);
                i.verticesNeedUpdate = n.verticesNeedUpdate, i.normalsNeedUpdate = n.normalsNeedUpdate, i.colorsNeedUpdate = n.colorsNeedUpdate, i.uvsNeedUpdate = n.uvsNeedUpdate, i.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = i
            }
            return !0 === n.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(n.vertices), e.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(n.normals), e.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(n.colors), e.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(n.uvs), e.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(n.lineDistances), e.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(t.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
        },
        fromGeometry: function (t) {
            return t.__directGeometry = (new rs).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
        },
        fromDirectGeometry: function (t) {
            var e = new Float32Array(3 * t.vertices.length);
            if (this.setAttribute("position", new Ya(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                var n = new Float32Array(3 * t.normals.length);
                this.setAttribute("normal", new Ya(n, 3).copyVector3sArray(t.normals))
            }
            if (t.colors.length > 0) {
                var i = new Float32Array(3 * t.colors.length);
                this.setAttribute("color", new Ya(i, 3).copyColorsArray(t.colors))
            }
            if (t.uvs.length > 0) {
                var r = new Float32Array(2 * t.uvs.length);
                this.setAttribute("uv", new Ya(r, 2).copyVector2sArray(t.uvs))
            }
            if (t.uvs2.length > 0) {
                var a = new Float32Array(2 * t.uvs2.length);
                this.setAttribute("uv2", new Ya(a, 2).copyVector2sArray(t.uvs2))
            }
            for (var s in this.groups = t.groups, t.morphTargets) {
                for (var o = [], l = t.morphTargets[s], h = 0, u = l.length; h < u; h++) {
                    var c = l[h],
                        p = new ns(3 * c.data.length, 3);
                    p.name = c.name, o.push(p.copyVector3sArray(c.data))
                }
                this.morphAttributes[s] = o
            }
            if (t.skinIndices.length > 0) {
                var f = new ns(4 * t.skinIndices.length, 4);
                this.setAttribute("skinIndex", f.copyVector4sArray(t.skinIndices))
            }
            if (t.skinWeights.length > 0) {
                var d = new ns(4 * t.skinWeights.length, 4);
                this.setAttribute("skinWeight", d.copyVector4sArray(t.skinWeights))
            }
            return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
        },
        computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new Xr);
            var t = this.attributes.position,
                e = this.morphAttributes.position;
            if (void 0 !== t) {
                if (this.boundingBox.setFromBufferAttribute(t), e)
                    for (var n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        us.setFromBufferAttribute(r), this.morphTargetsRelative ? (ps.addVectors(this.boundingBox.min, us.min), this.boundingBox.expandByPoint(ps), ps.addVectors(this.boundingBox.max, us.max), this.boundingBox.expandByPoint(ps)) : (this.boundingBox.expandByPoint(us.min), this.boundingBox.expandByPoint(us.max))
                    }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new Zr);
            var t = this.attributes.position,
                e = this.morphAttributes.position;
            if (t) {
                var n = this.boundingSphere.center;
                if (us.setFromBufferAttribute(t), e)
                    for (var i = 0, r = e.length; i < r; i++) {
                        var a = e[i];
                        cs.setFromBufferAttribute(a), this.morphTargetsRelative ? (ps.addVectors(us.min, cs.min), us.expandByPoint(ps), ps.addVectors(us.max, cs.max), us.expandByPoint(ps)) : (us.expandByPoint(cs.min), us.expandByPoint(cs.max))
                    }
                us.getCenter(n);
                var s = 0;
                for (i = 0, r = t.count; i < r; i++) ps.fromBufferAttribute(t, i), s = Math.max(s, n.distanceToSquared(ps));
                if (e)
                    for (i = 0, r = e.length; i < r; i++) {
                        a = e[i];
                        for (var o = this.morphTargetsRelative, l = 0, h = a.count; l < h; l++) ps.fromBufferAttribute(a, l), o && (hs.fromBufferAttribute(t, l), ps.add(hs)), s = Math.max(s, n.distanceToSquared(ps))
                    }
                this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        },
        computeFaceNormals: function () {},
        computeVertexNormals: function () {
            var t = this.index,
                e = this.attributes;
            if (e.position) {
                var n = e.position.array;
                if (void 0 === e.normal) this.setAttribute("normal", new Ya(new Float32Array(n.length), 3));
                else
                    for (var i = e.normal.array, r = 0, a = i.length; r < a; r++) i[r] = 0;
                var s, o, l, h = e.normal.array,
                    u = new Lr,
                    c = new Lr,
                    p = new Lr,
                    f = new Lr,
                    d = new Lr;
                if (t) {
                    var m = t.array;
                    for (r = 0, a = t.count; r < a; r += 3) s = 3 * m[r + 0], o = 3 * m[r + 1], l = 3 * m[r + 2], u.fromArray(n, s), c.fromArray(n, o), p.fromArray(n, l), f.subVectors(p, c), d.subVectors(u, c), f.cross(d), h[s] += f.x, h[s + 1] += f.y, h[s + 2] += f.z, h[o] += f.x, h[o + 1] += f.y, h[o + 2] += f.z, h[l] += f.x, h[l + 1] += f.y, h[l + 2] += f.z
                } else
                    for (r = 0, a = n.length; r < a; r += 9) u.fromArray(n, r), c.fromArray(n, r + 3), p.fromArray(n, r + 6), f.subVectors(p, c), d.subVectors(u, c), f.cross(d), h[r] = f.x, h[r + 1] = f.y, h[r + 2] = f.z, h[r + 3] = f.x, h[r + 4] = f.y, h[r + 5] = f.z, h[r + 6] = f.x, h[r + 7] = f.y, h[r + 8] = f.z;
                this.normalizeNormals(), e.normal.needsUpdate = !0
            }
        },
        merge: function (t, e) {
            if (t && t.isBufferGeometry) {
                void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var n = this.attributes;
                for (var i in n)
                    if (void 0 !== t.attributes[i])
                        for (var r = n[i].array, a = t.attributes[i], s = a.array, o = a.itemSize * e, l = Math.min(s.length, r.length - o), h = 0, u = o; h < l; h++, u++) r[u] = s[h];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
        },
        normalizeNormals: function () {
            for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++) ps.x = t.getX(e), ps.y = t.getY(e), ps.z = t.getZ(e), ps.normalize(), t.setXYZ(e, ps.x, ps.y, ps.z)
        },
        toNonIndexed: function () {
            function t(t, e) {
                for (var n = t.array, i = t.itemSize, r = new n.constructor(e.length * i), a = 0, s = 0, o = 0, l = e.length; o < l; o++) {
                    a = e[o] * i;
                    for (var h = 0; h < i; h++) r[s++] = n[a++]
                }
                return new Ya(r, i)
            }
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var e = new fs,
                n = this.index.array,
                i = this.attributes;
            for (var r in i) {
                var a = t(i[r], n);
                e.setAttribute(r, a)
            }
            var s = this.morphAttributes;
            for (r in s) {
                for (var o = [], l = s[r], h = 0, u = l.length; h < u; h++) {
                    a = t(l[h], n);
                    o.push(a)
                }
                e.morphAttributes[r] = o
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            for (var c = this.groups, p = (h = 0, c.length); h < p; h++) {
                var f = c[h];
                e.addGroup(f.start, f.count, f.materialIndex)
            }
            return e
        },
        toJSON: function () {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                var e = this.parameters;
                for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            t.data = {
                attributes: {}
            };
            var i = this.index;
            null !== i && (t.data.index = {
                type: i.array.constructor.name,
                array: Array.prototype.slice.call(i.array)
            });
            var r = this.attributes;
            for (var n in r) {
                var a = (p = r[n]).toJSON();
                "" !== p.name && (a.name = p.name), t.data.attributes[n] = a
            }
            var s = {},
                o = !1;
            for (var n in this.morphAttributes) {
                for (var l = this.morphAttributes[n], h = [], u = 0, c = l.length; u < c; u++) {
                    var p;
                    a = (p = l[u]).toJSON();
                    "" !== p.name && (a.name = p.name), h.push(a)
                }
                h.length > 0 && (s[n] = h, o = !0)
            }
            o && (t.data.morphAttributes = s, t.data.morphTargetsRelative = this.morphTargetsRelative);
            var f = this.groups;
            f.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(f)));
            var d = this.boundingSphere;
            return null !== d && (t.data.boundingSphere = {
                center: d.center.toArray(),
                radius: d.radius
            }), t
        },
        clone: function () {
            return (new fs).copy(this)
        },
        copy: function (t) {
            var e, n, i;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
            var r = t.index;
            null !== r && this.setIndex(r.clone());
            var a = t.attributes;
            for (e in a) {
                var s = a[e];
                this.setAttribute(e, s.clone())
            }
            var o = t.morphAttributes;
            for (e in o) {
                var l = [],
                    h = o[e];
                for (n = 0, i = h.length; n < i; n++) l.push(h[n].clone());
                this.morphAttributes[e] = l
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            var u = t.groups;
            for (n = 0, i = u.length; n < i; n++) {
                var c = u[n];
                this.addGroup(c.start, c.count, c.materialIndex)
            }
            var p = t.boundingBox;
            null !== p && (this.boundingBox = p.clone());
            var f = t.boundingSphere;
            return null !== f && (this.boundingSphere = f.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    class ds extends fs {
        constructor(t, e, n, i, r, a) {
            super(), this.type = "BoxBufferGeometry", this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: a
            };
            var s = this;
            t = t || 1, e = e || 1, n = n || 1, i = Math.floor(i) || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1;
            var o = [],
                l = [],
                h = [],
                u = [],
                c = 0,
                p = 0;

            function f(t, e, n, i, r, a, f, d, m, g, v) {
                var y, _, x = a / m,
                    b = f / g,
                    E = a / 2,
                    w = f / 2,
                    D = d / 2,
                    M = m + 1,
                    S = g + 1,
                    T = 0,
                    A = 0,
                    C = new Lr;
                for (_ = 0; _ < S; _++) {
                    var P = _ * b - w;
                    for (y = 0; y < M; y++) {
                        var F = y * x - E;
                        C[t] = F * i, C[e] = P * r, C[n] = D, l.push(C.x, C.y, C.z), C[t] = 0, C[e] = 0, C[n] = d > 0 ? 1 : -1, h.push(C.x, C.y, C.z), u.push(y / m), u.push(1 - _ / g), T += 1
                    }
                }
                for (_ = 0; _ < g; _++)
                    for (y = 0; y < m; y++) {
                        var L = c + y + M * _,
                            R = c + y + M * (_ + 1),
                            I = c + (y + 1) + M * (_ + 1),
                            k = c + (y + 1) + M * _;
                        o.push(L, R, k), o.push(R, I, k), A += 6
                    }
                s.addGroup(p, A, v), p += A, c += T
            }
            f("z", "y", "x", -1, -1, n, e, t, a, r, 0), f("z", "y", "x", 1, -1, n, e, -t, a, r, 1), f("x", "z", "y", 1, 1, t, n, e, i, a, 2), f("x", "z", "y", 1, -1, t, n, -e, i, a, 3), f("x", "y", "z", 1, -1, t, e, n, i, r, 4), f("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new ns(l, 3)), this.setAttribute("normal", new ns(h, 3)), this.setAttribute("uv", new ns(u, 2))
        }
    }

    function ms(t, e, n, i) {
        Xa.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        }, this.fromBufferGeometry(new gs(t, e, n, i)), this.mergeVertices()
    }

    function gs(t, e, n, i) {
        fs.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        };
        var r, a, s = (t = t || 1) / 2,
            o = (e = e || 1) / 2,
            l = Math.floor(n) || 1,
            h = Math.floor(i) || 1,
            u = l + 1,
            c = h + 1,
            p = t / l,
            f = e / h,
            d = [],
            m = [],
            g = [],
            v = [];
        for (a = 0; a < c; a++) {
            var y = a * f - o;
            for (r = 0; r < u; r++) {
                var _ = r * p - s;
                m.push(_, -y, 0), g.push(0, 0, 1), v.push(r / l), v.push(1 - a / h)
            }
        }
        for (a = 0; a < h; a++)
            for (r = 0; r < l; r++) {
                var x = r + u * a,
                    b = r + u * (a + 1),
                    E = r + 1 + u * (a + 1),
                    w = r + 1 + u * a;
                d.push(x, b, w), d.push(b, E, w)
            }
        this.setIndex(d), this.setAttribute("position", new ns(m, 3)), this.setAttribute("normal", new ns(g, 3)), this.setAttribute("uv", new ns(v, 2))
    }
    ms.prototype = Object.create(Xa.prototype), ms.prototype.constructor = ms, gs.prototype = Object.create(fs.prototype), gs.prototype.constructor = gs;
    var vs = 0;

    function ys() {
        Object.defineProperty(this, "id", {
            value: vs++
        }), this.uuid = br.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
    }

    function _s(t) {
        var e = {};
        for (var n in t)
            for (var i in e[n] = {}, t[n]) {
                var r = t[n][i];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
            }
        return e
    }

    function xs(t) {
        for (var e = {}, n = 0; n < t.length; n++) {
            var i = _s(t[n]);
            for (var r in i) e[r] = i[r]
        }
        return e
    }
    ys.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: ys,
        isMaterial: !0,
        onBeforeCompile: function () {},
        setValues: function (t) {
            if (void 0 !== t)
                for (var e in t) {
                    var n = t[e];
                    if (void 0 !== n)
                        if ("shading" !== e) {
                            var i = this[e];
                            void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                        } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                    else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                }
        },
        toJSON: function (t) {
            var e = void 0 === t || "string" == typeof t;
            e && (t = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };

            function i(t) {
                var e = [];
                for (var n in t) {
                    var i = t[n];
                    delete i.metadata, e.push(i)
                }
                return e
            }
            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                var r = i(t.textures),
                    a = i(t.images);
                r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a)
            }
            return n
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
            var e = t.clippingPlanes,
                n = null;
            if (null !== e) {
                var i = e.length;
                n = new Array(i);
                for (var r = 0; r !== i; ++r) n[r] = e[r].clone()
            }
            return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty(ys.prototype, "needsUpdate", {
        set: function (t) {
            !0 === t && this.version++
        }
    });
    var bs = {
        clone: _s,
        merge: xs
    };

    function Es(t) {
        ys.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "\nvoid main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n", this.fragmentShader = "\nvoid main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
    }
    Es.prototype = Object.create(ys.prototype), Es.prototype.constructor = Es, Es.prototype.isShaderMaterial = !0, Es.prototype.copy = function (t) {
        return ys.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = _s(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
    }, Es.prototype.toJSON = function (t) {
        var e = ys.prototype.toJSON.call(this, t);
        for (var n in e.uniforms = {}, this.uniforms) {
            var i = this.uniforms[n].value;
            i && i.isTexture ? e.uniforms[n] = {
                type: "t",
                value: i.toJSON(t).uuid
            } : i && i.isColor ? e.uniforms[n] = {
                type: "c",
                value: i.getHex()
            } : i && i.isVector2 ? e.uniforms[n] = {
                type: "v2",
                value: i.toArray()
            } : i && i.isVector3 ? e.uniforms[n] = {
                type: "v3",
                value: i.toArray()
            } : i && i.isVector4 ? e.uniforms[n] = {
                type: "v4",
                value: i.toArray()
            } : i && i.isMatrix3 ? e.uniforms[n] = {
                type: "m3",
                value: i.toArray()
            } : i && i.isMatrix4 ? e.uniforms[n] = {
                type: "m4",
                value: i.toArray()
            } : e.uniforms[n] = {
                value: i
            }
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
        var r = {};
        for (var a in this.extensions) !0 === this.extensions[a] && (r[a] = !0);
        return Object.keys(r).length > 0 && (e.extensions = r), e
    };
    var ws = new Lr,
        Ds = new Lr,
        Ms = new Lr,
        Ss = new Lr,
        Ts = new Lr,
        As = new Lr,
        Cs = new Lr;

    function Ps(t, e) {
        this.origin = void 0 !== t ? t : new Lr, this.direction = void 0 !== e ? e : new Lr(0, 0, -1)
    }
    Object.assign(Ps.prototype, {
        set: function (t, e) {
            return this.origin.copy(t), this.direction.copy(e), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this
        },
        at: function (t, e) {
            return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new Lr), e.copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        lookAt: function (t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this
        },
        recast: function (t) {
            return this.origin.copy(this.at(t, ws)), this
        },
        closestPointToPoint: function (t, e) {
            void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new Lr), e.subVectors(t, this.origin);
            var n = e.dot(this.direction);
            return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
        },
        distanceToPoint: function (t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        },
        distanceSqToPoint: function (t) {
            var e = ws.subVectors(t, this.origin).dot(this.direction);
            return e < 0 ? this.origin.distanceToSquared(t) : (ws.copy(this.direction).multiplyScalar(e).add(this.origin), ws.distanceToSquared(t))
        },
        distanceSqToSegment: function (t, e, n, i) {
            Ds.copy(t).add(e).multiplyScalar(.5), Ms.copy(e).sub(t).normalize(), Ss.copy(this.origin).sub(Ds);
            var r, a, s, o, l = .5 * t.distanceTo(e),
                h = -this.direction.dot(Ms),
                u = Ss.dot(this.direction),
                c = -Ss.dot(Ms),
                p = Ss.lengthSq(),
                f = Math.abs(1 - h * h);
            if (f > 0)
                if (a = h * u - c, o = l * f, (r = h * c - u) >= 0)
                    if (a >= -o)
                        if (a <= o) {
                            var d = 1 / f;
                            s = (r *= d) * (r + h * (a *= d) + 2 * u) + a * (h * r + a + 2 * c) + p
                        } else a = l, s = -(r = Math.max(0, -(h * a + u))) * r + a * (a + 2 * c) + p;
            else a = -l, s = -(r = Math.max(0, -(h * a + u))) * r + a * (a + 2 * c) + p;
            else a <= -o ? s = -(r = Math.max(0, -(-h * l + u))) * r + (a = r > 0 ? -l : Math.min(Math.max(-l, -c), l)) * (a + 2 * c) + p : a <= o ? (r = 0, s = (a = Math.min(Math.max(-l, -c), l)) * (a + 2 * c) + p) : s = -(r = Math.max(0, -(h * l + u))) * r + (a = r > 0 ? l : Math.min(Math.max(-l, -c), l)) * (a + 2 * c) + p;
            else a = h > 0 ? -l : l, s = -(r = Math.max(0, -(h * a + u))) * r + a * (a + 2 * c) + p;
            return n && n.copy(this.direction).multiplyScalar(r).add(this.origin), i && i.copy(Ms).multiplyScalar(a).add(Ds), s
        },
        intersectSphere: function (t, e) {
            ws.subVectors(t.center, this.origin);
            var n = ws.dot(this.direction),
                i = ws.dot(ws) - n * n,
                r = t.radius * t.radius;
            if (i > r) return null;
            var a = Math.sqrt(r - i),
                s = n - a,
                o = n + a;
            return s < 0 && o < 0 ? null : s < 0 ? this.at(o, e) : this.at(s, e)
        },
        intersectsSphere: function (t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
        },
        distanceToPlane: function (t) {
            var e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            var n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null
        },
        intersectPlane: function (t, e) {
            var n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e)
        },
        intersectsPlane: function (t) {
            var e = t.distanceToPoint(this.origin);
            return 0 === e || t.normal.dot(this.direction) * e < 0
        },
        intersectBox: function (t, e) {
            var n, i, r, a, s, o, l = 1 / this.direction.x,
                h = 1 / this.direction.y,
                u = 1 / this.direction.z,
                c = this.origin;
            return l >= 0 ? (n = (t.min.x - c.x) * l, i = (t.max.x - c.x) * l) : (n = (t.max.x - c.x) * l, i = (t.min.x - c.x) * l), h >= 0 ? (r = (t.min.y - c.y) * h, a = (t.max.y - c.y) * h) : (r = (t.max.y - c.y) * h, a = (t.min.y - c.y) * h), n > a || r > i ? null : ((r > n || n != n) && (n = r), (a < i || i != i) && (i = a), u >= 0 ? (s = (t.min.z - c.z) * u, o = (t.max.z - c.z) * u) : (s = (t.max.z - c.z) * u, o = (t.min.z - c.z) * u), n > o || s > i ? null : ((s > n || n != n) && (n = s), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
        },
        intersectsBox: function (t) {
            return null !== this.intersectBox(t, ws)
        },
        intersectTriangle: function (t, e, n, i, r) {
            Ts.subVectors(e, t), As.subVectors(n, t), Cs.crossVectors(Ts, As);
            var a, s = this.direction.dot(Cs);
            if (s > 0) {
                if (i) return null;
                a = 1
            } else {
                if (!(s < 0)) return null;
                a = -1, s = -s
            }
            Ss.subVectors(this.origin, t);
            var o = a * this.direction.dot(As.crossVectors(Ss, As));
            if (o < 0) return null;
            var l = a * this.direction.dot(Ts.cross(Ss));
            if (l < 0) return null;
            if (o + l > s) return null;
            var h = -a * Ss.dot(Cs);
            return h < 0 ? null : this.at(h / s, r)
        },
        applyMatrix4: function (t) {
            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
        },
        equals: function (t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
    });
    var Fs = new Lr,
        Ls = new Lr,
        Rs = new Lr,
        Is = new Lr,
        ks = new Lr,
        Os = new Lr,
        Ns = new Lr,
        Bs = new Lr,
        zs = new Lr,
        Us = new Lr;

    function Vs(t, e, n) {
        this.a = void 0 !== t ? t : new Lr, this.b = void 0 !== e ? e : new Lr, this.c = void 0 !== n ? n : new Lr
    }

    function Gs(t) {
        ys.call(this), this.type = "MeshBasicMaterial", this.color = new da(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
    }
    Object.assign(Vs, {
        getNormal: function (t, e, n, i) {
            void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new Lr), i.subVectors(n, e), Fs.subVectors(t, e), i.cross(Fs);
            var r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
        },
        getBarycoord: function (t, e, n, i, r) {
            Fs.subVectors(i, e), Ls.subVectors(n, e), Rs.subVectors(t, e);
            var a = Fs.dot(Fs),
                s = Fs.dot(Ls),
                o = Fs.dot(Rs),
                l = Ls.dot(Ls),
                h = Ls.dot(Rs),
                u = a * l - s * s;
            if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new Lr), 0 === u) return r.set(-2, -1, -1);
            var c = 1 / u,
                p = (l * o - s * h) * c,
                f = (a * h - s * o) * c;
            return r.set(1 - p - f, f, p)
        },
        containsPoint: function (t, e, n, i) {
            return Vs.getBarycoord(t, e, n, i, Is), Is.x >= 0 && Is.y >= 0 && Is.x + Is.y <= 1
        },
        getUV: function (t, e, n, i, r, a, s, o) {
            return this.getBarycoord(t, e, n, i, Is), o.set(0, 0), o.addScaledVector(r, Is.x), o.addScaledVector(a, Is.y), o.addScaledVector(s, Is.z), o
        },
        isFrontFacing: function (t, e, n, i) {
            return Fs.subVectors(n, e), Ls.subVectors(t, e), Fs.cross(Ls).dot(i) < 0
        }
    }), Object.assign(Vs.prototype, {
        set: function (t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
        },
        setFromPointsAndIndices: function (t, e, n, i) {
            return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
        },
        getArea: function () {
            return Fs.subVectors(this.c, this.b), Ls.subVectors(this.a, this.b), .5 * Fs.cross(Ls).length()
        },
        getMidpoint: function (t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new Lr), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function (t) {
            return Vs.getNormal(this.a, this.b, this.c, t)
        },
        getPlane: function (t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Qr), t.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function (t, e) {
            return Vs.getBarycoord(t, this.a, this.b, this.c, e)
        },
        getUV: function (t, e, n, i, r) {
            return Vs.getUV(t, this.a, this.b, this.c, e, n, i, r)
        },
        containsPoint: function (t) {
            return Vs.containsPoint(t, this.a, this.b, this.c)
        },
        isFrontFacing: function (t) {
            return Vs.isFrontFacing(this.a, this.b, this.c, t)
        },
        intersectsBox: function (t) {
            return t.intersectsTriangle(this)
        },
        closestPointToPoint: function (t, e) {
            void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new Lr);
            var n, i, r = this.a,
                a = this.b,
                s = this.c;
            ks.subVectors(a, r), Os.subVectors(s, r), Bs.subVectors(t, r);
            var o = ks.dot(Bs),
                l = Os.dot(Bs);
            if (o <= 0 && l <= 0) return e.copy(r);
            zs.subVectors(t, a);
            var h = ks.dot(zs),
                u = Os.dot(zs);
            if (h >= 0 && u <= h) return e.copy(a);
            var c = o * u - h * l;
            if (c <= 0 && o >= 0 && h <= 0) return n = o / (o - h), e.copy(r).addScaledVector(ks, n);
            Us.subVectors(t, s);
            var p = ks.dot(Us),
                f = Os.dot(Us);
            if (f >= 0 && p <= f) return e.copy(s);
            var d = p * l - o * f;
            if (d <= 0 && l >= 0 && f <= 0) return i = l / (l - f), e.copy(r).addScaledVector(Os, i);
            var m = h * f - p * u;
            if (m <= 0 && u - h >= 0 && p - f >= 0) return Ns.subVectors(s, a), i = (u - h) / (u - h + (p - f)), e.copy(a).addScaledVector(Ns, i);
            var g = 1 / (m + d + c);
            return n = d * g, i = c * g, e.copy(r).addScaledVector(ks, n).addScaledVector(Os, i)
        },
        equals: function (t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    }), Gs.prototype = Object.create(ys.prototype), Gs.prototype.constructor = Gs, Gs.prototype.isMeshBasicMaterial = !0, Gs.prototype.copy = function (t) {
        return ys.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
    };
    var Hs = new ua,
        js = new Ps,
        Ws = new Zr,
        Xs = new Lr,
        qs = new Lr,
        Ys = new Lr,
        Zs = new Lr,
        Js = new Lr,
        Ks = new Lr,
        $s = new Lr,
        Qs = new Lr,
        to = new Lr,
        eo = new wr,
        no = new wr,
        io = new wr,
        ro = new Lr,
        ao = new Lr;

    function so(t, e) {
        Na.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new fs, this.material = void 0 !== e ? e : new Gs, this.updateMorphTargets()
    }

    function oo(t, e, n, i, r, a, s, o) {
        if (null === (1 === e.side ? i.intersectTriangle(s, a, r, !0, o) : i.intersectTriangle(r, a, s, 2 !== e.side, o))) return null;
        ao.copy(o), ao.applyMatrix4(t.matrixWorld);
        var l = n.ray.origin.distanceTo(ao);
        return l < n.near || l > n.far ? null : {
            distance: l,
            point: ao.clone(),
            object: t
        }
    }

    function lo(t, e, n, i, r, a, s, o, l, h, u, c) {
        Xs.fromBufferAttribute(r, h), qs.fromBufferAttribute(r, u), Ys.fromBufferAttribute(r, c);
        var p = t.morphTargetInfluences;
        if (e.morphTargets && a && p) {
            $s.set(0, 0, 0), Qs.set(0, 0, 0), to.set(0, 0, 0);
            for (var f = 0, d = a.length; f < d; f++) {
                var m = p[f],
                    g = a[f];
                0 !== m && (Zs.fromBufferAttribute(g, h), Js.fromBufferAttribute(g, u), Ks.fromBufferAttribute(g, c), s ? ($s.addScaledVector(Zs, m), Qs.addScaledVector(Js, m), to.addScaledVector(Ks, m)) : ($s.addScaledVector(Zs.sub(Xs), m), Qs.addScaledVector(Js.sub(qs), m), to.addScaledVector(Ks.sub(Ys), m)))
            }
            Xs.add($s), qs.add(Qs), Ys.add(to)
        }
        t.isSkinnedMesh && (t.boneTransform(h, Xs), t.boneTransform(u, qs), t.boneTransform(c, Ys));
        var v = oo(t, e, n, i, Xs, qs, Ys, ro);
        if (v) {
            o && (eo.fromBufferAttribute(o, h), no.fromBufferAttribute(o, u), io.fromBufferAttribute(o, c), v.uv = Vs.getUV(ro, Xs, qs, Ys, eo, no, io, new wr)), l && (eo.fromBufferAttribute(l, h), no.fromBufferAttribute(l, u), io.fromBufferAttribute(l, c), v.uv2 = Vs.getUV(ro, Xs, qs, Ys, eo, no, io, new wr));
            var y = new Va(h, u, c);
            Vs.getNormal(Xs, qs, Ys, y.normal), v.face = y
        }
        return v
    }
    so.prototype = Object.assign(Object.create(Na.prototype), {
        constructor: so,
        isMesh: !0,
        copy: function (t) {
            return Na.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
        },
        updateMorphTargets: function () {
            var t, e, n, i = this.geometry;
            if (i.isBufferGeometry) {
                var r = i.morphAttributes,
                    a = Object.keys(r);
                if (a.length > 0) {
                    var s = r[a[0]];
                    if (void 0 !== s)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = s.length; t < e; t++) n = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                }
            } else {
                var o = i.morphTargets;
                void 0 !== o && o.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        raycast: function (t, e) {
            var n, i = this.geometry,
                r = this.material,
                a = this.matrixWorld;
            if (void 0 !== r && (null === i.boundingSphere && i.computeBoundingSphere(), Ws.copy(i.boundingSphere), Ws.applyMatrix4(a), !1 !== t.ray.intersectsSphere(Ws) && (Hs.getInverse(a), js.copy(t.ray).applyMatrix4(Hs), null === i.boundingBox || !1 !== js.intersectsBox(i.boundingBox))))
                if (i.isBufferGeometry) {
                    var s, o, l, h, u, c, p, f, d, m = i.index,
                        g = i.attributes.position,
                        v = i.morphAttributes.position,
                        y = i.morphTargetsRelative,
                        _ = i.attributes.uv,
                        x = i.attributes.uv2,
                        b = i.groups,
                        E = i.drawRange;
                    if (null !== m)
                        if (Array.isArray(r))
                            for (h = 0, c = b.length; h < c; h++)
                                for (d = r[(f = b[h]).materialIndex], u = Math.max(f.start, E.start), p = Math.min(f.start + f.count, E.start + E.count); u < p; u += 3) s = m.getX(u), o = m.getX(u + 1), l = m.getX(u + 2), (n = lo(this, d, t, js, g, v, y, _, x, s, o, l)) && (n.faceIndex = Math.floor(u / 3), n.face.materialIndex = f.materialIndex, e.push(n));
                        else
                            for (h = Math.max(0, E.start), c = Math.min(m.count, E.start + E.count); h < c; h += 3) s = m.getX(h), o = m.getX(h + 1), l = m.getX(h + 2), (n = lo(this, r, t, js, g, v, y, _, x, s, o, l)) && (n.faceIndex = Math.floor(h / 3), e.push(n));
                    else if (void 0 !== g)
                        if (Array.isArray(r))
                            for (h = 0, c = b.length; h < c; h++)
                                for (d = r[(f = b[h]).materialIndex], u = Math.max(f.start, E.start), p = Math.min(f.start + f.count, E.start + E.count); u < p; u += 3)(n = lo(this, d, t, js, g, v, y, _, x, s = u, o = u + 1, l = u + 2)) && (n.faceIndex = Math.floor(u / 3), n.face.materialIndex = f.materialIndex, e.push(n));
                        else
                            for (h = Math.max(0, E.start), c = Math.min(g.count, E.start + E.count); h < c; h += 3)(n = lo(this, r, t, js, g, v, y, _, x, s = h, o = h + 1, l = h + 2)) && (n.faceIndex = Math.floor(h / 3), e.push(n))
                } else if (i.isGeometry) {
                var w, D, M, S, T = Array.isArray(r),
                    A = i.vertices,
                    C = i.faces,
                    P = i.faceVertexUvs[0];
                P.length > 0 && (S = P);
                for (var F = 0, L = C.length; F < L; F++) {
                    var R = C[F],
                        I = T ? r[R.materialIndex] : r;
                    if (void 0 !== I && (w = A[R.a], D = A[R.b], M = A[R.c], n = oo(this, I, t, js, w, D, M, ro))) {
                        if (S && S[F]) {
                            var k = S[F];
                            eo.copy(k[0]), no.copy(k[1]), io.copy(k[2]), n.uv = Vs.getUV(ro, w, D, M, eo, no, io, new wr)
                        }
                        n.face = R, n.faceIndex = F, e.push(n)
                    }
                }
            }
        },
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    });
    var ho = {
            alphamap_fragment: "\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n",
            alphamap_pars_fragment: "\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n",
            alphatest_fragment: "\n#ifdef ALPHATEST\n\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n",
            aomap_fragment: "\n#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n\t#endif\n\n#endif\n",
            aomap_pars_fragment: "\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n",
            begin_vertex: "\nvec3 transformed = vec3( position );\n",
            beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n\n#ifdef USE_TANGENT\n\n\tvec3 objectTangent = vec3( tangent.xyz );\n\n#endif\n",
            bsdfs: '\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via \'environmentBRDF\' from "Physically Based Shading on Mobile"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n}\n\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t// this is intended to be used on spot and point lights who are represented as luminous intensity\n\t// but who must be converted to luminous irradiance for surface lighting calculation\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n\tif( cutoffDistance > 0.0 ) {\n\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t}\n\n\treturn distanceFalloff;\n\n#else\n\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t}\n\n\treturn 1.0;\n\n#endif\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n\t// Original approximation by Christophe Schlick \'94\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH \'13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\n\t// See F_Schlick\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\n\treturn Fr * fresnel + F0;\n\n}\n\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disneys reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\t// geometry term (normalized) = G(l)G(v) / 4(nl)(nv)\n\t// also see #12151\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n\treturn 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disneys reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4\'s roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\tfloat dotNV = saturate( dot( N, V ) );\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\treturn uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tfloat l = length( f );\n\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n\tfloat x = dot( v1, v2 );\n\n\tfloat y = abs( x );\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n\treturn cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n\t// alternate method of adjusting for horizon clipping (see referece)\n\t// refactoring required\n\tfloat len = length( vectorFormFactor );\n\tfloat z = vectorFormFactor.z / len;\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\t// tabulated horizon-clipped sphere, apparently...\n\tvec2 uv = vec2( z * 0.5 + 0.5, len );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\tfloat scale = texture2D( ltc_2, uv ).w;\n\n\tfloat result = len * scale;\n*/\n\n\treturn vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\n\treturn specularColor * brdf.x + brdf.y;\n\n} // validated\n\n// Fdez-Agera\'s "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21\n\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\t//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\t//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n\n#if defined( USE_SHEEN )\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94\nfloat D_Charlie(float roughness, float NoH) {\n\t// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136\nfloat V_Neubelt(float NoV, float NoL) {\n\t// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\n\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n\n}\n\n#endif\n',
            bumpmap_pars_fragment: "\n#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n\t// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n",
            clipping_planes_fragment: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvec4 plane;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n\t\tbool clipped = true;\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t\tif ( clipped ) discard;\n\n\t#endif\n\n#endif\n",
            clipping_planes_pars_fragment: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n",
            clipping_planes_pars_vertex: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n#endif\n",
            clipping_planes_vertex: "\n#if NUM_CLIPPING_PLANES > 0\n\n\tvClipPosition = - mvPosition.xyz;\n\n#endif\n",
            color_fragment: "\n#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif\n",
            color_pars_fragment: "\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n",
            color_pars_vertex: "\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n",
            color_vertex: "\n#ifdef USE_COLOR\n\n\tvColor.xyz = color.xyz;\n\n#endif\n",
            common: "\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#ifndef saturate\n// <tonemapping_pars_fragment> may have defined saturate() already\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t// dir can be either a direction vector or a normal vector\n\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\n\treturn - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n\treturn dot( weights, color.rgb );\n\n}\n\nbool isPerspectiveMatrix( mat4 m ) {\n\n  return m[ 2 ][ 3 ] == - 1.0;\n\n}\n",
            cube_uv_reflection_fragment: "\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized).\n\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\n\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\n\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n\n// These defines must match with PMREMGenerator\n\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\n\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\n  }\n  return mip;\n}\n\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif\n",
            defaultnormal_vertex: "\nvec3 transformedNormal = objectNormal;\n\n#ifdef USE_INSTANCING\n\n\t// this is in lieu of a per-instance normal-matrix\n\t// shear transforms in the instance matrix are not supported\n\n\tmat3 m = mat3( instanceMatrix );\n\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\n\ttransformedNormal = m * transformedNormal;\n\n#endif\n\ntransformedNormal = normalMatrix * transformedNormal;\n\n#ifdef FLIP_SIDED\n\n\ttransformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#ifdef FLIP_SIDED\n\n\t\ttransformedTangent = - transformedTangent;\n\n\t#endif\n\n#endif\n",
            displacementmap_pars_vertex: "\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n",
            displacementmap_vertex: "\n#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n\n#endif\n",
            emissivemap_fragment: "\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n",
            emissivemap_pars_fragment: "\n#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n",
            encodings_fragment: "\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n",
            encodings_pars_fragment: "\n// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\n\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\n\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\n\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\n\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\t// NOTE: The implementation with min causes the shader to not compile on\n\t// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests \n\t// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.\n\t// D = min( floor( D ) / 255.0, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n",
            envmap_fragment: "\n#ifdef USE_ENVMAP\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n\t\t}  else {\n\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\n\t\t}\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\tvec2 sampleUV;\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\n\t#else\n\n\t\tvec4 envColor = vec4( 0.0 );\n\n\t#endif\n\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\n\t\tenvColor = envMapTexelToLinear( envColor );\n\n\t#endif\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n",
            envmap_common_pars_fragment: "\n#ifdef USE_ENVMAP\n\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n",
            envmap_pars_fragment: "\n#ifdef USE_ENVMAP\n\n\tuniform float reflectivity;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\t#define ENV_WORLDPOS\n\n\t#endif\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n\n#endif\n",
            envmap_pars_vertex: "\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\n\t\t#define ENV_WORLDPOS\n\n\t#endif\n\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n#endif\n",
            envmap_physical_pars_fragment: "\n#if defined( USE_ENVMAP )\n\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\n\tvec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n\t\t\t// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n\t\t\t// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#else\n\n\t\t\t\t// force the bias high to get the last LOD level as it is the most blurred.\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\n\t\t#else\n\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\n\t\t#endif\n\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t}\n\n\t// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\n\t\t// clamp to allowable LOD ranges.\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n\t}\n\n\tvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\n\t\t  // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\n\t\t#else\n\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\n\t\t#endif\n\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#endif\n\n\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t}\n\n#endif\n",
            envmap_vertex: "\n#ifdef USE_ENVMAP\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvWorldPosition = worldPosition.xyz;\n\n\t#else\n\n\t\tvec3 cameraToVertex;\n\n\t\tif ( isOrthographic ) { \n\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n\t\t} else {\n\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t\t}\n\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n",
            fog_vertex: "\n#ifdef USE_FOG\n\n\tfogDepth = -mvPosition.z;\n\n#endif\n",
            fog_pars_vertex: "\n#ifdef USE_FOG\n\n\tvarying float fogDepth;\n\n#endif\n",
            fog_fragment: "\n#ifdef USE_FOG\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n\t#endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n",
            fog_pars_fragment: "\n#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\n\t#endif\n\n#endif\n",
            gradientmap_pars_fragment: "\n\n#ifdef USE_GRADIENTMAP\n\n\tuniform sampler2D gradientMap;\n\n#endif\n\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n\t// dotNL will be from -1.0 to 1.0\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n\t#ifdef USE_GRADIENTMAP\n\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\n\t#else\n\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n\t#endif\n\n}\n\n",
            lightmap_fragment: "\n#ifdef USE_LIGHTMAP\n\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n",
            lightmap_pars_fragment: "\n#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif\n",
            lights_lambert_vertex: "\nvec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n\n#ifdef DOUBLE_SIDED\n\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n\n#endif\n\n#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n/*\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\t// TODO (abelnation): implement\n\n\t}\n\n#endif\n*/\n\n#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n",
            lights_pars_begin: "\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\n\n// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n\t// normal is assumed to have unit length\n\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\n\treturn result;\n\n}\n\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\n\treturn irradiance;\n\n}\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance = ambientLightColor;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI;\n\n\t#endif\n\n\treturn irradiance;\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\n\t\tif ( angleCos > spotLight.coneCos ) {\n\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\n\t\t} else {\n\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\n\t\t}\n\t}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\n\t// BRDF approximation Texture is 64x64\n\tuniform sampler2D ltc_1; // RGBA Float\n\tuniform sampler2D ltc_2; // RGBA Float\n\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tirradiance *= PI;\n\n\t\t#endif\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n",
            lights_toon_fragment: "\nToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
            lights_toon_pars_fragment: "\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n\nstruct ToonMaterial {\n\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n\n};\n\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n\n#define Material_LightProbeLOD( material )\t(0)\n",
            lights_phong_fragment: "\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
            lights_phong_pars_fragment: "\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )\t(0)\n",
            lights_physical_fragment: "\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.\nmaterial.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n\n#ifdef REFLECTIVITY\n\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\n#else\n\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\n#endif\n\n#ifdef CLEARCOAT\n\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\n\t#ifdef USE_CLEARCOATMAP\n\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\n\t#endif\n\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\n\t#endif\n\n\tmaterial.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model\n\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n\n#endif\n\n#ifdef USE_SHEEN\n\n\tmaterial.sheenColor = sheen;\n\n#endif\n",
            lights_physical_pars_fragment: "\nstruct PhysicalMaterial {\n\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n\t}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\t#ifdef CLEARCOAT\n\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tccIrradiance *= PI; // punctual light\n\n\t\t#endif\n\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\n\t#else\n\n\t\tfloat clearcoatDHR = 0.0;\n\n\t#endif\n\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n\t#ifdef CLEARCOAT\n\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\n\t#else\n\n\t\tfloat clearcoatDHR = 0.0;\n\n\t#endif\n\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\n\t// Both indirect specular and indirect diffuse light accumulate here\n\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n",
            lights_fragment_begin: "\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef CLEARCOAT\n\n\tgeometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n",
            lights_fragment_maps: "\n#if defined( RE_IndirectDiffuse )\n\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tlightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n\t\t#endif\n\n\t\tirradiance += lightMapIrradiance;\n\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\n\n\t#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\tradiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\n\t#ifdef CLEARCOAT\n\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\n\t#endif\n\n#endif\n",
            lights_fragment_end: "\n#if defined( RE_IndirectDiffuse )\n\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n\n#endif\n",
            logdepthbuf_fragment: "\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\t// Doing a strict comparison with == 1.0 can cause noise artifacts\n\t// on some platforms. See issue #17623.\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif\n",
            logdepthbuf_pars_fragment: "\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n\n#endif\n",
            logdepthbuf_pars_vertex: "\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\n\t#else\n\n\t\tuniform float logDepthBufFC;\n\n\t#endif\n\n#endif\n",
            logdepthbuf_vertex: "\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\n\t#else\n\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n\t\t\tgl_Position.z *= gl_Position.w;\n\n\t\t}\n\n\t#endif\n\n#endif\n",
            map_fragment: "\n#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n\n#endif\n",
            map_pars_fragment: "\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n",
            map_particle_fragment: "\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\n#endif\n\n#ifdef USE_MAP\n\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n\n#endif\n",
            map_particle_pars_fragment: "\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n\tuniform mat3 uvTransform;\n\n#endif\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n",
            metalnessmap_fragment: "\nfloat metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n",
            metalnessmap_pars_fragment: "\n#ifdef USE_METALNESSMAP\n\n\tuniform sampler2D metalnessMap;\n\n#endif\n",
            morphnormal_vertex: "\n#ifdef USE_MORPHNORMALS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\n#endif\n",
            morphtarget_pars_vertex: "\n#ifdef USE_MORPHTARGETS\n\n\tuniform float morphTargetBaseInfluence;\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif\n",
            morphtarget_vertex: "\n#ifdef USE_MORPHTARGETS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n#endif\n",
            normal_fragment_begin: "\n#ifdef FLAT_SHADED\n\n\t// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t#endif\n\n\t#ifdef USE_TANGENT\n\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#endif\n\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n// non perturbed normal for clearcoat among others\n\nvec3 geometryNormal = normal;\n\n",
            normal_fragment_maps: "\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n\t#ifdef FLIP_SIDED\n\n\t\tnormal = - normal;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t#endif\n\n\tnormal = normalize( normalMatrix * normal );\n\n#elif defined( TANGENTSPACE_NORMALMAP )\n\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tnormal = normalize( vTBN * mapN );\n\n\t#else\n\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\n\t#endif\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n",
            normalmap_pars_fragment: "\n#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tuniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\n\t// Per-Pixel Tangent Space Normal Mapping\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tmat3 tsn = mat3( S, T, N );\n\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n",
            clearcoat_normal_fragment_begin: "\n#ifdef CLEARCOAT\n\n\tvec3 clearcoatNormal = geometryNormal;\n\n#endif\n",
            clearcoat_normal_fragment_maps: "\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\n\t#else\n\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\n\t#endif\n\n#endif\n",
            clearcoat_pars_fragment: "\n\n#ifdef USE_CLEARCOATMAP\n\n\tuniform sampler2D clearcoatMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform sampler2D clearcoatRoughnessMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n\n#endif\n",
            packing: "\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
            premultiplied_alpha_fragment: "\n#ifdef PREMULTIPLIED_ALPHA\n\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n\tgl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n",
            project_vertex: "\nvec4 mvPosition = vec4( transformed, 1.0 );\n\n#ifdef USE_INSTANCING\n\n\tmvPosition = instanceMatrix * mvPosition;\n\n#endif\n\nmvPosition = modelViewMatrix * mvPosition;\n\ngl_Position = projectionMatrix * mvPosition;\n",
            dithering_fragment: "\n#ifdef DITHERING\n\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n",
            dithering_pars_fragment: "\n#ifdef DITHERING\n\n\t// based on https://www.shadertoy.com/view/MslGR8\n\tvec3 dithering( vec3 color ) {\n\t\t//Calculate grid position\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n\t\t//modify shift acording to grid position.\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n\t\t//shift the color by dither_shift\n\t\treturn color + dither_shift_RGB;\n\t}\n\n#endif\n",
            roughnessmap_fragment: "\nfloat roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n",
            roughnessmap_pars_fragment: "\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform sampler2D roughnessMap;\n\n#endif\n",
            shadowmap_pars_fragment: "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): create uniforms for area light shadows\n\n\t#endif\n\t*/\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n\t}\n\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n\t\tfloat occlusion = 1.0;\n\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\n\t\tfloat hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n\t\tif (hard_shadow != 1.0 ) {\n\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n\t\t}\n\t\treturn occlusion;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n",
            shadowmap_pars_vertex: "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): uniforms for area light shadows\n\n\t#endif\n\t*/\n\n#endif\n",
            shadowmap_vertex: "\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update vAreaShadowCoord with area light info\n\n\t#endif\n\t*/\n\n#endif\n",
            shadowmask_pars_fragment: "\nfloat getShadowMask() {\n\n\tfloat shadow = 1.0;\n\n\t#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\tDirectionalLightShadow directionalLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\tSpotLightShadow spotLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\tPointLightShadow pointLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update shadow for Area light\n\n\t#endif\n\t*/\n\n\t#endif\n\n\treturn shadow;\n\n}\n",
            skinbase_vertex: "\n#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n",
            skinning_pars_vertex: "\n#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n",
            skinning_vertex: "\n#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n",
            skinnormal_vertex: "\n#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n\t#ifdef USE_TANGENT\n\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#endif\n\n#endif\n",
            specularmap_fragment: "\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif\n",
            specularmap_pars_fragment: "\n#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif\n",
            tonemapping_fragment: "\n#if defined( TONE_MAPPING )\n\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n",
            tonemapping_pars_fragment: "\n#ifndef saturate\n// <common> may have defined saturate() already\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n\treturn toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n\t// John Hable's filmic operator from Uncharted 2 video game\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n\t// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n\n// source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n\n}\n",
            uv_pars_fragment: "\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\n\tvarying vec2 vUv;\n\n#endif\n",
            uv_pars_vertex: "\n#ifdef USE_UV\n\n\t#ifdef UVS_VERTEX_ONLY\n\n\t\tvec2 vUv;\n\n\t#else\n\n\t\tvarying vec2 vUv;\n\n\t#endif\n\n\tuniform mat3 uvTransform;\n\n#endif\n",
            uv_vertex: "\n#ifdef USE_UV\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif\n",
            uv2_pars_fragment: "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif\n",
            uv2_pars_vertex: "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n\tuniform mat3 uv2Transform;\n\n#endif\n",
            uv2_vertex: "\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n\n#endif\n",
            worldpos_vertex: "\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t#ifdef USE_INSTANCING\n\n\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t#endif\n\n\tworldPosition = modelMatrix * worldPosition;\n\n#endif\n",
            background_frag: "\nuniform sampler2D t2D;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvec4 texColor = texture2D( t2D, vUv );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
            background_vert: "\nvarying vec2 vUv;\nuniform mat3 uvTransform;\n\nvoid main() {\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n\n}\n",
            cube_frag: "\n\n#include <envmap_common_pars_fragment>\nuniform float opacity;\n\nvarying vec3 vWorldDirection;\n\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
            cube_vert: "\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n}\n",
            depth_frag: "\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n",
            depth_vert: "\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.\n// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for\n// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvHighPrecisionZW = gl_Position.zw;\n\n}\n",
            distanceRGBA_frag: "\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n",
            distanceRGBA_vert: "\n#define DISTANCE\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvWorldPosition = worldPosition.xyz;\n\n}\n",
            equirect_frag: "\nuniform sampler2D tEquirect;\n\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvec3 direction = normalize( vWorldDirection );\n\n\tvec2 sampleUV;\n\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n",
            equirect_vert: "\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n}\n",
            linedashed_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n\t\tdiscard;\n\n\t}\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\n\toutgoingLight = diffuseColor.rgb; // simple shader\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n",
            linedashed_vert: "\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\tvLineDistance = scale * lineDistance;\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n",
            meshbasic_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\n\t#endif\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshbasic_vert: "\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_ENVMAP\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
            meshlambert_frag: "\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t#endif\n\n\t#include <lightmap_fragment>\n\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t#else\n\n\t\treflectedLight.directDiffuse = vLightFront;\n\n\t#endif\n\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t// modulation\n\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshlambert_vert: "\n#define LAMBERT\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshmatcap_frag: "\n#define MATCAP\n\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n\t#ifdef USE_MATCAP\n\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\n\t#else\n\n\t\tvec4 matcapColor = vec4( 1.0 );\n\n\t#endif\n\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshmatcap_vert: "\n#define MATCAP\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\t\tvNormal = normalize( transformedNormal );\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n}\n",
            meshtoon_frag: "\n#define TOON\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshtoon_vert: "\n#define TOON\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
            meshphong_frag: "\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshphong_vert: "\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
            meshphysical_frag: "\n#define STANDARD\n\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t// this is a stub for the transparency model\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",
            meshphysical_vert: "\n#define STANDARD\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
            normal_frag: "\n#define NORMAL\n\nuniform float opacity;\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\n}\n",
            normal_vert: "\n#define NORMAL\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvViewPosition = - mvPosition.xyz;\n\n#endif\n\n}\n",
            points_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n",
            points_vert: "\nuniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\n\tgl_PointSize = size;\n\n\t#ifdef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n\t#endif\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n\n}\n",
            shadow_frag: "\nuniform vec3 color;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n",
            shadow_vert: "\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvoid main() {\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",
            sprite_frag: "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n",
            sprite_vert: "\nuniform float rotation;\nuniform vec2 center;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n\t#ifndef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\n\t#endif\n\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\n\tmvPosition.xy += rotatedPosition;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n"
        },
        uo = {
            basic: {
                uniforms: xs([ya.common, ya.specularmap, ya.envmap, ya.aomap, ya.lightmap, ya.fog]),
                vertexShader: ho.meshbasic_vert,
                fragmentShader: ho.meshbasic_frag
            },
            lambert: {
                uniforms: xs([ya.common, ya.specularmap, ya.envmap, ya.aomap, ya.lightmap, ya.emissivemap, ya.fog, ya.lights, {
                    emissive: {
                        value: new da(0)
                    }
                }]),
                vertexShader: ho.meshlambert_vert,
                fragmentShader: ho.meshlambert_frag
            },
            phong: {
                uniforms: xs([ya.common, ya.specularmap, ya.envmap, ya.aomap, ya.lightmap, ya.emissivemap, ya.bumpmap, ya.normalmap, ya.displacementmap, ya.fog, ya.lights, {
                    emissive: {
                        value: new da(0)
                    },
                    specular: {
                        value: new da(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: ho.meshphong_vert,
                fragmentShader: ho.meshphong_frag
            },
            standard: {
                uniforms: xs([ya.common, ya.envmap, ya.aomap, ya.lightmap, ya.emissivemap, ya.bumpmap, ya.normalmap, ya.displacementmap, ya.roughnessmap, ya.metalnessmap, ya.fog, ya.lights, {
                    emissive: {
                        value: new da(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: ho.meshphysical_vert,
                fragmentShader: ho.meshphysical_frag
            },
            toon: {
                uniforms: xs([ya.common, ya.specularmap, ya.aomap, ya.lightmap, ya.emissivemap, ya.bumpmap, ya.normalmap, ya.displacementmap, ya.gradientmap, ya.fog, ya.lights, {
                    emissive: {
                        value: new da(0)
                    },
                    specular: {
                        value: new da(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: ho.meshtoon_vert,
                fragmentShader: ho.meshtoon_frag
            },
            matcap: {
                uniforms: xs([ya.common, ya.bumpmap, ya.normalmap, ya.displacementmap, ya.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: ho.meshmatcap_vert,
                fragmentShader: ho.meshmatcap_frag
            },
            points: {
                uniforms: xs([ya.points, ya.fog]),
                vertexShader: ho.points_vert,
                fragmentShader: ho.points_frag
            },
            dashed: {
                uniforms: xs([ya.common, ya.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: ho.linedashed_vert,
                fragmentShader: ho.linedashed_frag
            },
            depth: {
                uniforms: xs([ya.common, ya.displacementmap]),
                vertexShader: ho.depth_vert,
                fragmentShader: ho.depth_frag
            },
            normal: {
                uniforms: xs([ya.common, ya.bumpmap, ya.normalmap, ya.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ho.normal_vert,
                fragmentShader: ho.normal_frag
            },
            sprite: {
                uniforms: xs([ya.sprite, ya.fog]),
                vertexShader: ho.sprite_vert,
                fragmentShader: ho.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new Dr
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: ho.background_vert,
                fragmentShader: ho.background_frag
            },
            cube: {
                uniforms: xs([ya.envmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ho.cube_vert,
                fragmentShader: ho.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: ho.equirect_vert,
                fragmentShader: ho.equirect_frag
            },
            distanceRGBA: {
                uniforms: xs([ya.common, ya.displacementmap, {
                    referencePosition: {
                        value: new Lr
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: ho.distanceRGBA_vert,
                fragmentShader: ho.distanceRGBA_frag
            },
            shadow: {
                uniforms: xs([ya.lights, ya.fog, {
                    color: {
                        value: new da(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ho.shadow_vert,
                fragmentShader: ho.shadow_frag
            }
        };

    function co(t, e, n, i) {
        var r, a, s = new da(0),
            o = 0,
            l = null,
            h = 0,
            u = null;

        function c(t, n) {
            e.buffers.color.setClear(t.r, t.g, t.b, n, i)
        }
        return {
            getClearColor: function () {
                return s
            },
            setClearColor: function (t, e) {
                s.set(t), c(s, o = void 0 !== e ? e : 1)
            },
            getClearAlpha: function () {
                return o
            },
            setClearAlpha: function (t) {
                c(s, o = t)
            },
            render: function (e, i, p, f) {
                var d = i.background,
                    m = t.xr,
                    g = m.getSession && m.getSession();
                if (g && "additive" === g.environmentBlendMode && (d = null), null === d ? c(s, o) : d && d.isColor && (c(d, 1), f = !0), (t.autoClear || f) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), d && (d.isCubeTexture || d.isWebGLCubeRenderTarget || 306 === d.mapping)) {
                    void 0 === a && ((a = new so(new ds(1, 1, 1), new Es({
                        type: "BackgroundCubeMaterial",
                        uniforms: _s(uo.cube.uniforms),
                        vertexShader: uo.cube.vertexShader,
                        fragmentShader: uo.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(a.material, "envMap", {
                        get: function () {
                            return this.uniforms.envMap.value
                        }
                    }), n.update(a));
                    var v = d.isWebGLCubeRenderTarget ? d.texture : d;
                    a.material.uniforms.envMap.value = v, a.material.uniforms.flipEnvMap.value = v.isCubeTexture ? -1 : 1, l === d && h === v.version && u === t.toneMapping || (a.material.needsUpdate = !0, l = d, h = v.version, u = t.toneMapping), e.unshift(a, a.geometry, a.material, 0, 0, null)
                } else d && d.isTexture && (void 0 === r && ((r = new so(new gs(2, 2), new Es({
                    type: "BackgroundMaterial",
                    uniforms: _s(uo.background.uniforms),
                    vertexShader: uo.background.vertexShader,
                    fragmentShader: uo.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.deleteAttribute("normal"), Object.defineProperty(r.material, "map", {
                    get: function () {
                        return this.uniforms.t2D.value
                    }
                }), n.update(r)), r.material.uniforms.t2D.value = d, !0 === d.matrixAutoUpdate && d.updateMatrix(), r.material.uniforms.uvTransform.value.copy(d.matrix), l === d && h === d.version && u === t.toneMapping || (r.material.needsUpdate = !0, l = d, h = d.version, u = t.toneMapping), e.unshift(r, r.geometry, r.material, 0, 0, null))
            }
        }
    }

    function po(t, e, n, i) {
        var r, a = i.isWebGL2;
        this.setMode = function (t) {
            r = t
        }, this.render = function (e, i) {
            t.drawArrays(r, e, i), n.update(i, r)
        }, this.renderInstances = function (i, s, o, l) {
            if (0 !== l) {
                var h, u;
                if (a) h = t, u = "drawArraysInstanced";
                else if (u = "drawArraysInstancedANGLE", null === (h = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                h[u](r, s, o, l), n.update(o, r, l)
            }
        }
    }

    function fo(t, e, n) {
        var i;

        function r(e) {
            if ("highp" === e) {
                if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                e = "mediump"
            }
            return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
        }
        var a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext,
            s = void 0 !== n.precision ? n.precision : "highp",
            o = r(s);
        o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."), s = o);
        var l = !0 === n.logarithmicDepthBuffer,
            h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
            u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            c = t.getParameter(t.MAX_TEXTURE_SIZE),
            p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
            f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            d = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
            m = t.getParameter(t.MAX_VARYING_VECTORS),
            g = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
            v = u > 0,
            y = a || !!e.get("OES_texture_float");
        return {
            isWebGL2: a,
            getMaxAnisotropy: function () {
                if (void 0 !== i) return i;
                var n = e.get("EXT_texture_filter_anisotropic");
                return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: r,
            precision: s,
            logarithmicDepthBuffer: l,
            maxTextures: h,
            maxVertexTextures: u,
            maxTextureSize: c,
            maxCubemapSize: p,
            maxAttributes: f,
            maxVertexUniforms: d,
            maxVaryings: m,
            maxFragmentUniforms: g,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y,
            maxSamples: a ? t.getParameter(t.MAX_SAMPLES) : 0
        }
    }

    function mo() {
        var t = this,
            e = null,
            n = 0,
            i = !1,
            r = !1,
            a = new Qr,
            s = new Dr,
            o = {
                value: null,
                needsUpdate: !1
            };

        function l() {
            o.value !== e && (o.value = e, o.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
        }

        function h(e, n, i, r) {
            var l = null !== e ? e.length : 0,
                h = null;
            if (0 !== l) {
                if (h = o.value, !0 !== r || null === h) {
                    var u = i + 4 * l,
                        c = n.matrixWorldInverse;
                    s.getNormalMatrix(c), (null === h || h.length < u) && (h = new Float32Array(u));
                    for (var p = 0, f = i; p !== l; ++p, f += 4) a.copy(e[p]).applyMatrix4(c, s), a.normal.toArray(h, f), h[f + 3] = a.constant
                }
                o.value = h, o.needsUpdate = !0
            }
            return t.numPlanes = l, t.numIntersection = 0, h
        }
        this.uniform = o, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, r, a) {
            var s = 0 !== t.length || r || 0 !== n || i;
            return i = r, e = h(t, a, 0), n = t.length, s
        }, this.beginShadows = function () {
            r = !0, h(null)
        }, this.endShadows = function () {
            r = !1, l()
        }, this.setState = function (t, a, s, u, c, p) {
            if (!i || null === t || 0 === t.length || r && !s) r ? h(null) : l();
            else {
                var f = r ? 0 : n,
                    d = 4 * f,
                    m = c.clippingState || null;
                o.value = m, m = h(t, u, d, p);
                for (var g = 0; g !== d; ++g) m[g] = e[g];
                c.clippingState = m, this.numIntersection = a ? this.numPlanes : 0, this.numPlanes += f
            }
        }
    }

    function go(t) {
        var e = {};
        return {
            get: function (n) {
                if (void 0 !== e[n]) return e[n];
                var i;
                switch (n) {
                    case "WEBGL_depth_texture":
                        i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        i = t.getExtension(n)
                }
                return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n] = i, i
            }
        }
    }

    function vo(t, e, n) {
        var i = new WeakMap,
            r = new WeakMap;

        function a(t) {
            var s = t.target,
                o = i.get(s);
            for (var l in null !== o.index && e.remove(o.index), o.attributes) e.remove(o.attributes[l]);
            s.removeEventListener("dispose", a), i.delete(s);
            var h = r.get(o);
            h && (e.remove(h), r.delete(o)), n.memory.geometries--
        }

        function s(n) {
            var i = [],
                a = n.index,
                s = n.attributes.position,
                o = 0;
            if (null !== a) {
                var l = a.array;
                o = a.version;
                for (var h = 0, u = l.length; h < u; h += 3) {
                    var c = l[h + 0],
                        p = l[h + 1],
                        f = l[h + 2];
                    i.push(c, p, p, f, f, c)
                }
            } else {
                l = s.array;
                o = s.version;
                for (h = 0, u = l.length / 3 - 1; h < u; h += 3) {
                    c = h + 0, p = h + 1, f = h + 2;
                    i.push(c, p, p, f, f, c)
                }
            }
            var d = new(as(i) > 65535 ? es : Qa)(i, 1);
            d.version = o, e.update(d, t.ELEMENT_ARRAY_BUFFER);
            var m = r.get(n);
            m && e.remove(m), r.set(n, d)
        }
        return {
            get: function (t, e) {
                var r = i.get(e);
                return r || (e.addEventListener("dispose", a), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new fs).setFromObject(t)), r = e._bufferGeometry), i.set(e, r), n.memory.geometries++, r)
            },
            update: function (n) {
                var i = n.index,
                    r = n.attributes;
                for (var a in null !== i && e.update(i, t.ELEMENT_ARRAY_BUFFER), r) e.update(r[a], t.ARRAY_BUFFER);
                var s = n.morphAttributes;
                for (var a in s)
                    for (var o = s[a], l = 0, h = o.length; l < h; l++) e.update(o[l], t.ARRAY_BUFFER)
            },
            getWireframeAttribute: function (t) {
                var e = r.get(t);
                if (e) {
                    var n = t.index;
                    null !== n && e.version < n.version && s(t)
                } else s(t);
                return r.get(t)
            }
        }
    }

    function yo(t, e, n, i) {
        var r, a, s, o = i.isWebGL2;
        this.setMode = function (t) {
            r = t
        }, this.setIndex = function (t) {
            a = t.type, s = t.bytesPerElement
        }, this.render = function (e, i) {
            t.drawElements(r, i, a, e * s), n.update(i, r)
        }, this.renderInstances = function (i, l, h, u) {
            if (0 !== u) {
                var c, p;
                if (o) c = t, p = "drawElementsInstanced";
                else if (p = "drawElementsInstancedANGLE", null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                c[p](r, h, a, l * s, u), n.update(h, r, u)
            }
        }
    }

    function _o(t) {
        var e = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function () {
                e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
            },
            update: function (n, i, r) {
                switch (r = r || 1, e.calls++, i) {
                    case t.TRIANGLES:
                        e.triangles += r * (n / 3);
                        break;
                    case t.LINES:
                        e.lines += r * (n / 2);
                        break;
                    case t.LINE_STRIP:
                        e.lines += r * (n - 1);
                        break;
                    case t.LINE_LOOP:
                        e.lines += r * n;
                        break;
                    case t.POINTS:
                        e.points += r * n;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                }
            }
        }
    }

    function xo(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }

    function bo(t) {
        var e = {},
            n = new Float32Array(8);
        return {
            update: function (i, r, a, s) {
                var o = i.morphTargetInfluences,
                    l = void 0 === o ? 0 : o.length,
                    h = e[r.id];
                if (void 0 === h) {
                    h = [];
                    for (var u = 0; u < l; u++) h[u] = [u, 0];
                    e[r.id] = h
                }
                var c = a.morphTargets && r.morphAttributes.position,
                    p = a.morphNormals && r.morphAttributes.normal;
                for (u = 0; u < l; u++) {
                    0 !== (d = h[u])[1] && (c && r.deleteAttribute("morphTarget" + u), p && r.deleteAttribute("morphNormal" + u))
                }
                for (u = 0; u < l; u++) {
                    (d = h[u])[0] = u, d[1] = o[u]
                }
                h.sort(xo);
                var f = 0;
                for (u = 0; u < 8; u++) {
                    var d;
                    if (d = h[u]) {
                        var m = d[0],
                            g = d[1];
                        if (g) {
                            c && r.setAttribute("morphTarget" + u, c[m]), p && r.setAttribute("morphNormal" + u, p[m]), n[u] = g, f += g;
                            continue
                        }
                    }
                    n[u] = 0
                }
                var v = r.morphTargetsRelative ? 1 : 1 - f;
                s.getUniforms().setValue(t, "morphTargetBaseInfluence", v), s.getUniforms().setValue(t, "morphTargetInfluences", n)
            }
        }
    }

    function Eo(t, e, n, i) {
        var r = new WeakMap;
        return {
            update: function (a) {
                var s = i.render.frame,
                    o = a.geometry,
                    l = e.get(a, o);
                return r.get(l) !== s && (o.isGeometry && l.updateFromObject(a), e.update(l), r.set(l, s)), a.isInstancedMesh && n.update(a.instanceMatrix, t.ARRAY_BUFFER), l
            },
            dispose: function () {
                r = new WeakMap
            }
        }
    }

    function wo(t, e, n, i, r, a, s, o, l, h) {
        t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, s = void 0 !== s ? s : 1022, Tr.call(this, t, e, n, i, r, a, s, o, l, h), this.flipY = !1
    }

    function Do(t, e, n, i) {
        Tr.call(this, null), this.image = {
            data: t || null,
            width: e || 1,
            height: n || 1,
            depth: i || 1
        }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
    }

    function Mo(t, e, n, i) {
        Tr.call(this, null), this.image = {
            data: t || null,
            width: e || 1,
            height: n || 1,
            depth: i || 1
        }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
    }
    uo.physical = {
        uniforms: xs([uo.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new wr(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new da(0)
            },
            transparency: {
                value: 0
            }
        }]),
        vertexShader: ho.meshphysical_vert,
        fragmentShader: ho.meshphysical_frag
    }, wo.prototype = Object.create(Tr.prototype), wo.prototype.constructor = wo, wo.prototype.isCubeTexture = !0, Object.defineProperty(wo.prototype, "images", {
        get: function () {
            return this.image
        },
        set: function (t) {
            this.image = t
        }
    }), Do.prototype = Object.create(Tr.prototype), Do.prototype.constructor = Do, Do.prototype.isDataTexture2DArray = !0, Mo.prototype = Object.create(Tr.prototype), Mo.prototype.constructor = Mo, Mo.prototype.isDataTexture3D = !0;
    var So = new Tr,
        To = new Do,
        Ao = new Mo,
        Co = new wo,
        Po = [],
        Fo = [],
        Lo = new Float32Array(16),
        Ro = new Float32Array(9),
        Io = new Float32Array(4);

    function ko(t, e, n) {
        var i = t[0];
        if (i <= 0 || i > 0) return t;
        var r = e * n,
            a = Po[r];
        if (void 0 === a && (a = new Float32Array(r), Po[r] = a), 0 !== e) {
            i.toArray(a, 0);
            for (var s = 1, o = 0; s !== e; ++s) o += n, t[s].toArray(a, o)
        }
        return a
    }

    function Oo(t, e) {
        if (t.length !== e.length) return !1;
        for (var n = 0, i = t.length; n < i; n++)
            if (t[n] !== e[n]) return !1;
        return !0
    }

    function No(t, e) {
        for (var n = 0, i = e.length; n < i; n++) t[n] = e[n]
    }

    function Bo(t, e) {
        var n = Fo[e];
        void 0 === n && (n = new Int32Array(e), Fo[e] = n);
        for (var i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
        return n
    }

    function zo(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
    }

    function Uo(t, e) {
        var n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
        else {
            if (Oo(n, e)) return;
            t.uniform2fv(this.addr, e), No(n, e)
        }
    }

    function Vo(t, e) {
        var n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
        else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
        else {
            if (Oo(n, e)) return;
            t.uniform3fv(this.addr, e), No(n, e)
        }
    }

    function Go(t, e) {
        var n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
        else {
            if (Oo(n, e)) return;
            t.uniform4fv(this.addr, e), No(n, e)
        }
    }

    function Ho(t, e) {
        var n = this.cache,
            i = e.elements;
        if (void 0 === i) {
            if (Oo(n, e)) return;
            t.uniformMatrix2fv(this.addr, !1, e), No(n, e)
        } else {
            if (Oo(n, i)) return;
            Io.set(i), t.uniformMatrix2fv(this.addr, !1, Io), No(n, i)
        }
    }

    function jo(t, e) {
        var n = this.cache,
            i = e.elements;
        if (void 0 === i) {
            if (Oo(n, e)) return;
            t.uniformMatrix3fv(this.addr, !1, e), No(n, e)
        } else {
            if (Oo(n, i)) return;
            Ro.set(i), t.uniformMatrix3fv(this.addr, !1, Ro), No(n, i)
        }
    }

    function Wo(t, e) {
        var n = this.cache,
            i = e.elements;
        if (void 0 === i) {
            if (Oo(n, e)) return;
            t.uniformMatrix4fv(this.addr, !1, e), No(n, e)
        } else {
            if (Oo(n, i)) return;
            Lo.set(i), t.uniformMatrix4fv(this.addr, !1, Lo), No(n, i)
        }
    }

    function Xo(t, e, n) {
        var i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || So, r)
    }

    function qo(t, e, n) {
        var i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || To, r)
    }

    function Yo(t, e, n) {
        var i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Ao, r)
    }

    function Zo(t, e, n) {
        var i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || Co, r)
    }

    function Jo(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
    }

    function Ko(t, e) {
        var n = this.cache;
        Oo(n, e) || (t.uniform2iv(this.addr, e), No(n, e))
    }

    function $o(t, e) {
        var n = this.cache;
        Oo(n, e) || (t.uniform3iv(this.addr, e), No(n, e))
    }

    function Qo(t, e) {
        var n = this.cache;
        Oo(n, e) || (t.uniform4iv(this.addr, e), No(n, e))
    }

    function tl(t, e) {
        var n = this.cache;
        n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
    }

    function el(t, e) {
        t.uniform1fv(this.addr, e)
    }

    function nl(t, e) {
        t.uniform1iv(this.addr, e)
    }

    function il(t, e) {
        t.uniform2iv(this.addr, e)
    }

    function rl(t, e) {
        t.uniform3iv(this.addr, e)
    }

    function al(t, e) {
        t.uniform4iv(this.addr, e)
    }

    function sl(t, e) {
        var n = ko(e, this.size, 2);
        t.uniform2fv(this.addr, n)
    }

    function ol(t, e) {
        var n = ko(e, this.size, 3);
        t.uniform3fv(this.addr, n)
    }

    function ll(t, e) {
        var n = ko(e, this.size, 4);
        t.uniform4fv(this.addr, n)
    }

    function hl(t, e) {
        var n = ko(e, this.size, 4);
        t.uniformMatrix2fv(this.addr, !1, n)
    }

    function ul(t, e) {
        var n = ko(e, this.size, 9);
        t.uniformMatrix3fv(this.addr, !1, n)
    }

    function cl(t, e) {
        var n = ko(e, this.size, 16);
        t.uniformMatrix4fv(this.addr, !1, n)
    }

    function pl(t, e, n) {
        var i = e.length,
            r = Bo(n, i);
        t.uniform1iv(this.addr, r);
        for (var a = 0; a !== i; ++a) n.safeSetTexture2D(e[a] || So, r[a])
    }

    function fl(t, e, n) {
        var i = e.length,
            r = Bo(n, i);
        t.uniform1iv(this.addr, r);
        for (var a = 0; a !== i; ++a) n.safeSetTextureCube(e[a] || Co, r[a])
    }

    function dl(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) {
            switch (t) {
                case 5126:
                    return zo;
                case 35664:
                    return Uo;
                case 35665:
                    return Vo;
                case 35666:
                    return Go;
                case 35674:
                    return Ho;
                case 35675:
                    return jo;
                case 35676:
                    return Wo;
                case 5124:
                case 35670:
                    return Jo;
                case 35667:
                case 35671:
                    return Ko;
                case 35668:
                case 35672:
                    return $o;
                case 35669:
                case 35673:
                    return Qo;
                case 5125:
                    return tl;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return Xo;
                case 35679:
                case 36299:
                case 36307:
                    return Yo;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return Zo;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return qo
            }
        }(e.type)
    }

    function ml(t, e, n) {
        this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) {
            switch (t) {
                case 5126:
                    return el;
                case 35664:
                    return sl;
                case 35665:
                    return ol;
                case 35666:
                    return ll;
                case 35674:
                    return hl;
                case 35675:
                    return ul;
                case 35676:
                    return cl;
                case 5124:
                case 35670:
                    return nl;
                case 35667:
                case 35671:
                    return il;
                case 35668:
                case 35672:
                    return rl;
                case 35669:
                case 35673:
                    return al;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return pl;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return fl
            }
        }(e.type)
    }

    function gl(t) {
        this.id = t, this.seq = [], this.map = {}
    }
    ml.prototype.updateCache = function (t) {
        var e = this.cache;
        t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), No(e, t)
    }, gl.prototype.setValue = function (t, e, n) {
        for (var i = this.seq, r = 0, a = i.length; r !== a; ++r) {
            var s = i[r];
            s.setValue(t, e[s.id], n)
        }
    };
    var vl = /([\w\d_]+)(\])?(\[|\.)?/g;

    function yl(t, e) {
        t.seq.push(e), t.map[e.id] = e
    }

    function _l(t, e, n) {
        var i = t.name,
            r = i.length;
        for (vl.lastIndex = 0;;) {
            var a = vl.exec(i),
                s = vl.lastIndex,
                o = a[1],
                l = "]" === a[2],
                h = a[3];
            if (l && (o |= 0), void 0 === h || "[" === h && s + 2 === r) {
                yl(n, void 0 === h ? new dl(o, t, e) : new ml(o, t, e));
                break
            }
            var u = n.map[o];
            void 0 === u && yl(n, u = new gl(o)), n = u
        }
    }

    function xl(t, e) {
        this.seq = [], this.map = {};
        for (var n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), i = 0; i < n; ++i) {
            var r = t.getActiveUniform(e, i);
            _l(r, t.getUniformLocation(e, r.name), this)
        }
    }

    function bl(t, e, n) {
        var i = t.createShader(e);
        return t.shaderSource(i, n), t.compileShader(i), i
    }
    xl.prototype.setValue = function (t, e, n, i) {
        var r = this.map[e];
        void 0 !== r && r.setValue(t, n, i)
    }, xl.prototype.setOptional = function (t, e, n) {
        var i = e[n];
        void 0 !== i && this.setValue(t, n, i)
    }, xl.upload = function (t, e, n, i) {
        for (var r = 0, a = e.length; r !== a; ++r) {
            var s = e[r],
                o = n[s.id];
            !1 !== o.needsUpdate && s.setValue(t, o.value, i)
        }
    }, xl.seqWithValue = function (t, e) {
        for (var n = [], i = 0, r = t.length; i !== r; ++i) {
            var a = t[i];
            a.id in e && n.push(a)
        }
        return n
    };
    var El = 0;

    function wl(t) {
        switch (t) {
            case 3e3:
                return ["Linear", "( value )"];
            case 3001:
                return ["sRGB", "( value )"];
            case 3002:
                return ["RGBE", "( value )"];
            case 3004:
                return ["RGBM", "( value, 7.0 )"];
            case 3005:
                return ["RGBM", "( value, 16.0 )"];
            case 3006:
                return ["RGBD", "( value, 256.0 )"];
            case 3007:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case 3003:
                return ["LogLuv", "( value )"];
            default:
                throw new Error("unsupported encoding: " + t)
        }
    }

    function Dl(t, e, n) {
        var i = t.getShaderParameter(e, t.COMPILE_STATUS),
            r = t.getShaderInfoLog(e).trim();
        return i && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function (t) {
            for (var e = t.split("\n"), n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
            return e.join("\n")
        }(t.getShaderSource(e))
    }

    function Ml(t, e) {
        var n = wl(e);
        return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }

    function Sl(t, e) {
        var n;
        switch (e) {
            case 1:
                n = "Linear";
                break;
            case 2:
                n = "Reinhard";
                break;
            case 3:
                n = "Uncharted2";
                break;
            case 4:
                n = "OptimizedCineon";
                break;
            case 5:
                n = "ACESFilmic";
                break;
            default:
                throw new Error("unsupported toneMapping: " + e)
        }
        return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }

    function Tl(t) {
        return "" !== t
    }

    function Al(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
    }

    function Cl(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    var Pl = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function Fl(t) {
        return t.replace(Pl, Ll)
    }

    function Ll(t, e) {
        var n = ho[e];
        if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
        return Fl(n)
    }
    var Rl = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        Il = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;

    function kl(t) {
        return t.replace(Il, Nl).replace(Rl, Ol)
    }

    function Ol(t, e, n, i) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Nl(t, e, n, i)
    }

    function Nl(t, e, n, i) {
        for (var r = "", a = parseInt(e); a < parseInt(n); a++) r += i.replace(/\[ i \]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
        return r
    }

    function Bl(t) {
        var e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
        return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
    }

    function zl(t, e, n) {
        var i, r, a, s, o, l = t.getContext(),
            h = n.defines,
            u = n.vertexShader,
            c = n.fragmentShader,
            p = function (t) {
                var e = "SHADOWMAP_TYPE_BASIC";
                return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
            }(n),
            f = function (t) {
                var e = "ENVMAP_TYPE_CUBE";
                if (t.envMap) switch (t.envMapMode) {
                    case 301:
                    case 302:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case 306:
                    case 307:
                        e = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case 303:
                    case 304:
                        e = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case 305:
                        e = "ENVMAP_TYPE_SPHERE"
                }
                return e
            }(n),
            d = function (t) {
                var e = "ENVMAP_MODE_REFLECTION";
                if (t.envMap) switch (t.envMapMode) {
                    case 302:
                    case 304:
                        e = "ENVMAP_MODE_REFRACTION"
                }
                return e
            }(n),
            m = function (t) {
                var e = "ENVMAP_BLENDING_NONE";
                if (t.envMap) switch (t.combine) {
                    case 0:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        e = "ENVMAP_BLENDING_ADD"
                }
                return e
            }(n),
            g = t.gammaFactor > 0 ? t.gammaFactor : 1,
            v = n.isWebGL2 ? "" : function (t) {
                return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Tl).join("\n")
            }(n),
            y = function (t) {
                var e = [];
                for (var n in t) {
                    var i = t[n];
                    !1 !== i && e.push("#define " + n + " " + i)
                }
                return e.join("\n")
            }(h),
            _ = l.createProgram();
        if (n.isRawShaderMaterial ? ((i = [y].filter(Tl).join("\n")).length > 0 && (i += "\n"), (r = [v, y].filter(Tl).join("\n")).length > 0 && (r += "\n")) : (i = [Bl(n), "#define SHADER_NAME " + n.shaderName, y, n.instancing ? "#define USE_INSTANCING" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + g, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Tl).join("\n"), r = [v, Bl(n), "#define SHADER_NAME " + n.shaderName, y, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + f : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? ho.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Sl("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.outputEncoding || n.mapEncoding || n.matcapEncoding || n.envMapEncoding || n.emissiveMapEncoding || n.lightMapEncoding ? ho.encodings_pars_fragment : "", n.mapEncoding ? Ml("mapTexelToLinear", n.mapEncoding) : "", n.matcapEncoding ? Ml("matcapTexelToLinear", n.matcapEncoding) : "", n.envMapEncoding ? Ml("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMapEncoding ? Ml("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMapEncoding ? Ml("lightMapTexelToLinear", n.lightMapEncoding) : "", n.outputEncoding ? (a = "linearToOutputTexel", s = n.outputEncoding, o = wl(s), "vec4 " + a + "( vec4 value ) { return LinearTo" + o[0] + o[1] + "; }") : "", n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Tl).join("\n")), u = Cl(u = Al(u = Fl(u), n), n), c = Cl(c = Al(c = Fl(c), n), n), u = kl(u), c = kl(c), n.isWebGL2 && !n.isRawShaderMaterial) {
            var x = !1,
                b = /^\s*#version\s+300\s+es\s*\n/;
            n.isShaderMaterial && null !== u.match(b) && null !== c.match(b) && (x = !0, u = u.replace(b, ""), c = c.replace(b, "")), i = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + i, r = ["#version 300 es\n", "#define varying in", x ? "" : "out highp vec4 pc_fragColor;", x ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + r
        }
        var E, w, D = i + u,
            M = r + c,
            S = bl(l, l.VERTEX_SHADER, D),
            T = bl(l, l.FRAGMENT_SHADER, M);
        if (l.attachShader(_, S), l.attachShader(_, T), void 0 !== n.index0AttributeName ? l.bindAttribLocation(_, 0, n.index0AttributeName) : !0 === n.morphTargets && l.bindAttribLocation(_, 0, "position"), l.linkProgram(_), t.debug.checkShaderErrors) {
            var A = l.getProgramInfoLog(_).trim(),
                C = l.getShaderInfoLog(S).trim(),
                P = l.getShaderInfoLog(T).trim(),
                F = !0,
                L = !0;
            if (!1 === l.getProgramParameter(_, l.LINK_STATUS)) {
                F = !1;
                var R = Dl(l, S, "vertex"),
                    I = Dl(l, T, "fragment");
                console.error("THREE.WebGLProgram: shader error: ", l.getError(), "gl.VALIDATE_STATUS", l.getProgramParameter(_, l.VALIDATE_STATUS), "gl.getProgramInfoLog", A, R, I)
            } else "" !== A ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", A) : "" !== C && "" !== P || (L = !1);
            L && (this.diagnostics = {
                runnable: F,
                programLog: A,
                vertexShader: {
                    log: C,
                    prefix: i
                },
                fragmentShader: {
                    log: P,
                    prefix: r
                }
            })
        }
        return l.deleteShader(S), l.deleteShader(T), this.getUniforms = function () {
            return void 0 === E && (E = new xl(l, _)), E
        }, this.getAttributes = function () {
            return void 0 === w && (w = function (t, e) {
                for (var n = {}, i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), r = 0; r < i; r++) {
                    var a = t.getActiveAttrib(e, r).name;
                    n[a] = t.getAttribLocation(e, a)
                }
                return n
            }(l, _)), w
        }, this.destroy = function () {
            l.deleteProgram(_), this.program = void 0
        }, this.name = n.shaderName, this.id = El++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = S, this.fragmentShader = T, this
    }

    function Ul(t, e, n) {
        var i = [],
            r = n.isWebGL2,
            a = n.logarithmicDepthBuffer,
            s = n.floatVertexTextures,
            o = n.precision,
            l = n.maxVertexUniforms,
            h = n.vertexTextures,
            u = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            },
            c = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

        function p(t) {
            var e;
            return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = 3e3, e
        }
        this.getParameters = function (i, c, f, d, m, g, v) {
            var y = d.fog,
                _ = i.isMeshStandardMaterial ? d.environment : null,
                x = i.envMap || _,
                b = u[i.type],
                E = v.isSkinnedMesh ? function (t) {
                    var e = t.skeleton.bones;
                    if (s) return 1024;
                    var n = l,
                        i = Math.floor((n - 20) / 4),
                        r = Math.min(i, e.length);
                    return r < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + r + "."), 0) : r
                }(v) : 0;
            null !== i.precision && (o = n.getMaxPrecision(i.precision)) !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", o, "instead.");
            var w = function (t, e) {
                var n;
                if (e) {
                    var i = uo[e];
                    n = {
                        name: t.type,
                        uniforms: bs.clone(i.uniforms),
                        vertexShader: i.vertexShader,
                        fragmentShader: i.fragmentShader
                    }
                } else n = {
                    name: t.type,
                    uniforms: t.uniforms,
                    vertexShader: t.vertexShader,
                    fragmentShader: t.fragmentShader
                };
                return n
            }(i, b);
            i.onBeforeCompile(w, t);
            var D = t.getRenderTarget();
            return {
                isWebGL2: r,
                shaderID: b,
                shaderName: w.name,
                uniforms: w.uniforms,
                vertexShader: w.vertexShader,
                fragmentShader: w.fragmentShader,
                defines: i.defines,
                isRawShaderMaterial: i.isRawShaderMaterial,
                isShaderMaterial: i.isShaderMaterial,
                precision: o,
                instancing: !0 === v.isInstancedMesh,
                supportsVertexTextures: h,
                outputEncoding: null !== D ? p(D.texture) : t.outputEncoding,
                map: !!i.map,
                mapEncoding: p(i.map),
                matcap: !!i.matcap,
                matcapEncoding: p(i.matcap),
                envMap: !!x,
                envMapMode: x && x.mapping,
                envMapEncoding: p(x),
                envMapCubeUV: !!x && (306 === x.mapping || 307 === x.mapping),
                lightMap: !!i.lightMap,
                lightMapEncoding: p(i.lightMap),
                aoMap: !!i.aoMap,
                emissiveMap: !!i.emissiveMap,
                emissiveMapEncoding: p(i.emissiveMap),
                bumpMap: !!i.bumpMap,
                normalMap: !!i.normalMap,
                objectSpaceNormalMap: 1 === i.normalMapType,
                tangentSpaceNormalMap: 0 === i.normalMapType,
                clearcoatMap: !!i.clearcoatMap,
                clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
                clearcoatNormalMap: !!i.clearcoatNormalMap,
                displacementMap: !!i.displacementMap,
                roughnessMap: !!i.roughnessMap,
                metalnessMap: !!i.metalnessMap,
                specularMap: !!i.specularMap,
                alphaMap: !!i.alphaMap,
                gradientMap: !!i.gradientMap,
                sheen: !!i.sheen,
                combine: i.combine,
                vertexTangents: i.normalMap && i.vertexTangents,
                vertexColors: i.vertexColors,
                vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap),
                uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || !i.displacementMap),
                fog: !!y,
                useFog: i.fog,
                fogExp2: y && y.isFogExp2,
                flatShading: i.flatShading,
                sizeAttenuation: i.sizeAttenuation,
                logarithmicDepthBuffer: a,
                skinning: i.skinning && E > 0,
                maxBones: E,
                useVertexTexture: s,
                morphTargets: i.morphTargets,
                morphNormals: i.morphNormals,
                maxMorphTargets: t.maxMorphTargets,
                maxMorphNormals: t.maxMorphNormals,
                numDirLights: c.directional.length,
                numPointLights: c.point.length,
                numSpotLights: c.spot.length,
                numRectAreaLights: c.rectArea.length,
                numHemiLights: c.hemi.length,
                numDirLightShadows: c.directionalShadowMap.length,
                numPointLightShadows: c.pointShadowMap.length,
                numSpotLightShadows: c.spotShadowMap.length,
                numClippingPlanes: m,
                numClipIntersection: g,
                dithering: i.dithering,
                shadowMapEnabled: t.shadowMap.enabled && f.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: i.toneMapped ? t.toneMapping : 0,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: i.premultipliedAlpha,
                alphaTest: i.alphaTest,
                doubleSided: 2 === i.side,
                flipSided: 1 === i.side,
                depthPacking: void 0 !== i.depthPacking && i.depthPacking,
                index0AttributeName: i.index0AttributeName,
                extensionDerivatives: i.extensions && i.extensions.derivatives,
                extensionFragDepth: i.extensions && i.extensions.fragDepth,
                extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
                extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: r || null !== e.get("EXT_frag_depth"),
                rendererExtensionDrawBuffers: r || null !== e.get("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod: r || null !== e.get("EXT_shader_texture_lod"),
                onBeforeCompile: i.onBeforeCompile
            }
        }, this.getProgramCacheKey = function (e) {
            var n = [];
            if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                for (var i in e.defines) n.push(i), n.push(e.defines[i]);
            if (void 0 === e.isRawShaderMaterial) {
                for (var r = 0; r < c.length; r++) n.push(e[c[r]]);
                n.push(t.outputEncoding), n.push(t.gammaFactor)
            }
            return n.push(e.onBeforeCompile.toString()), n.join()
        }, this.acquireProgram = function (e, n) {
            for (var r, a = 0, s = i.length; a < s; a++) {
                var o = i[a];
                if (o.cacheKey === n) {
                    ++(r = o).usedTimes;
                    break
                }
            }
            return void 0 === r && (r = new zl(t, n, e), i.push(r)), r
        }, this.releaseProgram = function (t) {
            if (0 == --t.usedTimes) {
                var e = i.indexOf(t);
                i[e] = i[i.length - 1], i.pop(), t.destroy()
            }
        }, this.programs = i
    }

    function Vl() {
        var t = new WeakMap;
        return {
            get: function (e) {
                var n = t.get(e);
                return void 0 === n && (n = {}, t.set(e, n)), n
            },
            remove: function (e) {
                t.delete(e)
            },
            update: function (e, n, i) {
                t.get(e)[n] = i
            },
            dispose: function () {
                t = new WeakMap
            }
        }
    }

    function Gl(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }

    function Hl(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }

    function jl() {
        var t = [],
            e = 0,
            n = [],
            i = [],
            r = {
                id: -1
            };

        function a(n, i, a, s, o, l) {
            var h = t[e];
            return void 0 === h ? (h = {
                id: n.id,
                object: n,
                geometry: i,
                material: a,
                program: a.program || r,
                groupOrder: s,
                renderOrder: n.renderOrder,
                z: o,
                group: l
            }, t[e] = h) : (h.id = n.id, h.object = n, h.geometry = i, h.material = a, h.program = a.program || r, h.groupOrder = s, h.renderOrder = n.renderOrder, h.z = o, h.group = l), e++, h
        }
        return {
            opaque: n,
            transparent: i,
            init: function () {
                e = 0, n.length = 0, i.length = 0
            },
            push: function (t, e, r, s, o, l) {
                var h = a(t, e, r, s, o, l);
                (!0 === r.transparent ? i : n).push(h)
            },
            unshift: function (t, e, r, s, o, l) {
                var h = a(t, e, r, s, o, l);
                (!0 === r.transparent ? i : n).unshift(h)
            },
            finish: function () {
                for (var n = e, i = t.length; n < i; n++) {
                    var r = t[n];
                    if (null === r.id) break;
                    r.id = null, r.object = null, r.geometry = null, r.material = null, r.program = null, r.group = null
                }
            },
            sort: function (t, e) {
                n.length > 1 && n.sort(t || Gl), i.length > 1 && i.sort(e || Hl)
            }
        }
    }

    function Wl() {
        var t = new WeakMap;

        function e(n) {
            var i = n.target;
            i.removeEventListener("dispose", e), t.delete(i)
        }
        return {
            get: function (n, i) {
                var r, a = t.get(n);
                return void 0 === a ? (r = new jl, t.set(n, new WeakMap), t.get(n).set(i, r), n.addEventListener("dispose", e)) : void 0 === (r = a.get(i)) && (r = new jl, a.set(i, r)), r
            },
            dispose: function () {
                t = new WeakMap
            }
        }
    }

    function Xl() {
        var t = {};
        return {
            get: function (e) {
                if (void 0 !== t[e.id]) return t[e.id];
                var n;
                switch (e.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new Lr,
                            color: new da
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new Lr,
                            direction: new Lr,
                            color: new da,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new Lr,
                            color: new da,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new Lr,
                            skyColor: new da,
                            groundColor: new da
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new da,
                            position: new Lr,
                            halfWidth: new Lr,
                            halfHeight: new Lr
                        }
                }
                return t[e.id] = n, n
            }
        }
    }
    var ql = 0;

    function Yl(t, e) {
        return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
    }

    function Zl() {
        for (var t, e = new Xl, n = (t = {}, {
                get: function (e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    var n;
                    switch (e.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            n = {
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new wr
                            };
                            break;
                        case "PointLight":
                            n = {
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new wr,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                    }
                    return t[e.id] = n, n
                }
            }), i = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadow: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            }, r = 0; r < 9; r++) i.probe.push(new Lr);
        var a = new Lr,
            s = new ua,
            o = new ua;
        return {
            setup: function (t, r, l) {
                for (var h = 0, u = 0, c = 0, p = 0; p < 9; p++) i.probe[p].set(0, 0, 0);
                var f = 0,
                    d = 0,
                    m = 0,
                    g = 0,
                    v = 0,
                    y = 0,
                    _ = 0,
                    x = 0,
                    b = l.matrixWorldInverse;
                t.sort(Yl), p = 0;
                for (var E = t.length; p < E; p++) {
                    var w = t[p],
                        D = w.color,
                        M = w.intensity,
                        S = w.distance,
                        T = w.shadow && w.shadow.map ? w.shadow.map.texture : null;
                    if (w.isAmbientLight) h += D.r * M, u += D.g * M, c += D.b * M;
                    else if (w.isLightProbe)
                        for (var A = 0; A < 9; A++) i.probe[A].addScaledVector(w.sh.coefficients[A], M);
                    else if (w.isDirectionalLight) {
                        if ((F = e.get(w)).color.copy(w.color).multiplyScalar(w.intensity), F.direction.setFromMatrixPosition(w.matrixWorld), a.setFromMatrixPosition(w.target.matrixWorld), F.direction.sub(a), F.direction.transformDirection(b), w.castShadow) {
                            var C = w.shadow;
                            (P = n.get(w)).shadowBias = C.bias, P.shadowRadius = C.radius, P.shadowMapSize = C.mapSize, i.directionalShadow[f] = P, i.directionalShadowMap[f] = T, i.directionalShadowMatrix[f] = w.shadow.matrix, y++
                        }
                        i.directional[f] = F, f++
                    } else if (w.isSpotLight) {
                        if ((F = e.get(w)).position.setFromMatrixPosition(w.matrixWorld), F.position.applyMatrix4(b), F.color.copy(D).multiplyScalar(M), F.distance = S, F.direction.setFromMatrixPosition(w.matrixWorld), a.setFromMatrixPosition(w.target.matrixWorld), F.direction.sub(a), F.direction.transformDirection(b), F.coneCos = Math.cos(w.angle), F.penumbraCos = Math.cos(w.angle * (1 - w.penumbra)), F.decay = w.decay, w.castShadow) {
                            C = w.shadow;
                            (P = n.get(w)).shadowBias = C.bias, P.shadowRadius = C.radius, P.shadowMapSize = C.mapSize, i.spotShadow[m] = P, i.spotShadowMap[m] = T, i.spotShadowMatrix[m] = w.shadow.matrix, x++
                        }
                        i.spot[m] = F, m++
                    } else if (w.isRectAreaLight) {
                        (F = e.get(w)).color.copy(D).multiplyScalar(M), F.position.setFromMatrixPosition(w.matrixWorld), F.position.applyMatrix4(b), o.identity(), s.copy(w.matrixWorld), s.premultiply(b), o.extractRotation(s), F.halfWidth.set(.5 * w.width, 0, 0), F.halfHeight.set(0, .5 * w.height, 0), F.halfWidth.applyMatrix4(o), F.halfHeight.applyMatrix4(o), i.rectArea[g] = F, g++
                    } else if (w.isPointLight) {
                        if ((F = e.get(w)).position.setFromMatrixPosition(w.matrixWorld), F.position.applyMatrix4(b), F.color.copy(w.color).multiplyScalar(w.intensity), F.distance = w.distance, F.decay = w.decay, w.castShadow) {
                            var P;
                            C = w.shadow;
                            (P = n.get(w)).shadowBias = C.bias, P.shadowRadius = C.radius, P.shadowMapSize = C.mapSize, P.shadowCameraNear = C.camera.near, P.shadowCameraFar = C.camera.far, i.pointShadow[d] = P, i.pointShadowMap[d] = T, i.pointShadowMatrix[d] = w.shadow.matrix, _++
                        }
                        i.point[d] = F, d++
                    } else if (w.isHemisphereLight) {
                        var F;
                        (F = e.get(w)).direction.setFromMatrixPosition(w.matrixWorld), F.direction.transformDirection(b), F.direction.normalize(), F.skyColor.copy(w.color).multiplyScalar(M), F.groundColor.copy(w.groundColor).multiplyScalar(M), i.hemi[v] = F, v++
                    }
                }
                i.ambient[0] = h, i.ambient[1] = u, i.ambient[2] = c;
                var L = i.hash;
                L.directionalLength === f && L.pointLength === d && L.spotLength === m && L.rectAreaLength === g && L.hemiLength === v && L.numDirectionalShadows === y && L.numPointShadows === _ && L.numSpotShadows === x || (i.directional.length = f, i.spot.length = m, i.rectArea.length = g, i.point.length = d, i.hemi.length = v, i.directionalShadow.length = y, i.directionalShadowMap.length = y, i.pointShadow.length = _, i.pointShadowMap.length = _, i.spotShadow.length = x, i.spotShadowMap.length = x, i.directionalShadowMatrix.length = y, i.pointShadowMatrix.length = _, i.spotShadowMatrix.length = x, L.directionalLength = f, L.pointLength = d, L.spotLength = m, L.rectAreaLength = g, L.hemiLength = v, L.numDirectionalShadows = y, L.numPointShadows = _, L.numSpotShadows = x, i.version = ql++)
            },
            state: i
        }
    }

    function Jl() {
        var t = new Zl,
            e = [],
            n = [];
        return {
            init: function () {
                e.length = 0, n.length = 0
            },
            state: {
                lightsArray: e,
                shadowsArray: n,
                lights: t
            },
            setupLights: function (i) {
                t.setup(e, n, i)
            },
            pushLight: function (t) {
                e.push(t)
            },
            pushShadow: function (t) {
                n.push(t)
            }
        }
    }

    function Kl() {
        var t = new WeakMap;

        function e(n) {
            var i = n.target;
            i.removeEventListener("dispose", e), t.delete(i)
        }
        return {
            get: function (n, i) {
                var r;
                return !1 === t.has(n) ? (r = new Jl, t.set(n, new WeakMap), t.get(n).set(i, r), n.addEventListener("dispose", e)) : !1 === t.get(n).has(i) ? (r = new Jl, t.get(n).set(i, r)) : r = t.get(n).get(i), r
            },
            dispose: function () {
                t = new WeakMap
            }
        }
    }

    function $l(t, e, n) {
        this.width = t, this.height = e, this.scissor = new _a(0, 0, t, e), this.scissorTest = !1, this.viewport = new _a(0, 0, t, e), n = n || {}, this.texture = new Tr(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }

    function Ql(t) {
        ys.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
    }

    function th(t) {
        ys.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Lr, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
    }
    $l.prototype = Object.assign(Object.create(Er.prototype), {
        constructor: $l,
        isWebGLRenderTarget: !0,
        setSize: function (t, e) {
            this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
        },
        dispose: function () {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Ql.prototype = Object.create(ys.prototype), Ql.prototype.constructor = Ql, Ql.prototype.isMeshDepthMaterial = !0, Ql.prototype.copy = function (t) {
        return ys.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }, th.prototype = Object.create(ys.prototype), th.prototype.constructor = th, th.prototype.isMeshDistanceMaterial = !0, th.prototype.copy = function (t) {
        return ys.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
    };

    function eh(t, e, n) {
        var i = new na,
            r = new wr,
            a = new wr,
            s = new _a,
            o = [],
            l = [],
            h = {},
            u = {
                0: 1,
                1: 0,
                2: 2
            },
            c = new Es({
                defines: {
                    SAMPLE_RATE: 2 / 8,
                    HALF_SAMPLE_RATE: 1 / 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new wr
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: "\n\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}\n\n",
                fragmentShader: "\nuniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n\n#include <packing>\n\nvoid main() {\n\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\n\t// This seems totally useless but it's a crazy work around for a Adreno compiler bug\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\n    #ifdef HORIZONAL_PASS\n\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\n    #else\n\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n\n    #endif\n\n  }\n\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n\n  float std_dev = sqrt( squared_mean - mean * mean );\n\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n\n}\n"
            }),
            p = c.clone();
        p.defines.HORIZONAL_PASS = 1;
        var f = new fs;
        f.setAttribute("position", new Ya(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        var d = new so(f, c),
            m = this;

        function g(n, i) {
            var r = e.update(d);
            c.uniforms.shadow_pass.value = n.map.texture, c.uniforms.resolution.value = n.mapSize, c.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, c, d, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, p, d, null)
        }

        function v(t, e, n) {
            var i = t << 0 | e << 1 | n << 2,
                r = o[i];
            return void 0 === r && (r = new Ql({
                depthPacking: 3201,
                morphTargets: t,
                skinning: e
            }), o[i] = r), r
        }

        function y(t, e, n) {
            var i = t << 0 | e << 1 | n << 2,
                r = l[i];
            return void 0 === r && (r = new th({
                morphTargets: t,
                skinning: e
            }), l[i] = r), r
        }

        function _(e, n, i, r, a, s, o) {
            var l = null,
                c = v,
                p = e.customDepthMaterial;
            if (!0 === r.isPointLight && (c = y, p = e.customDistanceMaterial), void 0 === p) {
                var f = !1;
                !0 === i.morphTargets && (f = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                var d = !1;
                !0 === e.isSkinnedMesh && (!0 === i.skinning ? d = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)), l = c(f, d, !0 === e.isInstancedMesh)
            } else l = p;
            if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                var m = l.uuid,
                    g = i.uuid,
                    _ = h[m];
                void 0 === _ && (_ = {}, h[m] = _);
                var x = _[g];
                void 0 === x && (x = l.clone(), _[g] = x), l = x
            }
            return l.visible = i.visible, l.wireframe = i.wireframe, l.side = 3 === o ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld), l.nearDistance = a, l.farDistance = s), l
        }

        function x(n, r, a, s, o) {
            if (!1 !== n.visible) {
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                    var l = e.update(n),
                        h = n.material;
                    if (Array.isArray(h))
                        for (var u = l.groups, c = 0, p = u.length; c < p; c++) {
                            var f = u[c],
                                d = h[f.materialIndex];
                            if (d && d.visible) {
                                var m = _(n, l, d, s, a.near, a.far, o);
                                t.renderBufferDirect(a, null, l, m, n, f)
                            }
                        } else if (h.visible) {
                            m = _(n, l, h, s, a.near, a.far, o);
                            t.renderBufferDirect(a, null, l, m, n, null)
                        }
                }
                for (var g = n.children, v = 0, y = g.length; v < y; v++) x(g[v], r, a, s, o)
            }
        }
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, o, l) {
            if (!1 !== m.enabled && (!1 !== m.autoUpdate || !1 !== m.needsUpdate) && 0 !== e.length) {
                var h = t.getRenderTarget(),
                    u = t.getActiveCubeFace(),
                    c = t.getActiveMipmapLevel(),
                    p = t.state;
                p.setBlending(0), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
                for (var f = 0, d = e.length; f < d; f++) {
                    var v = e[f],
                        y = v.shadow;
                    if (void 0 !== y) {
                        r.copy(y.mapSize);
                        var _ = y.getFrameExtents();
                        if (r.multiply(_), a.copy(y.mapSize), (r.x > n || r.y > n) && (r.x > n && (a.x = Math.floor(n / _.x), r.x = a.x * _.x, y.mapSize.x = a.x), r.y > n && (a.y = Math.floor(n / _.y), r.y = a.y * _.y, y.mapSize.y = a.y)), null === y.map && !y.isPointLightShadow && 3 === this.type) {
                            var b = {
                                minFilter: 1006,
                                magFilter: 1006,
                                format: 1023
                            };
                            y.map = new $l(r.x, r.y, b), y.map.texture.name = v.name + ".shadowMap", y.mapPass = new $l(r.x, r.y, b), y.camera.updateProjectionMatrix()
                        }
                        if (null === y.map) {
                            b = {
                                minFilter: 1003,
                                magFilter: 1003,
                                format: 1023
                            };
                            y.map = new $l(r.x, r.y, b), y.map.texture.name = v.name + ".shadowMap", y.camera.updateProjectionMatrix()
                        }
                        t.setRenderTarget(y.map), t.clear();
                        for (var E = y.getViewportCount(), w = 0; w < E; w++) {
                            var D = y.getViewport(w);
                            s.set(a.x * D.x, a.y * D.y, a.x * D.z, a.y * D.w), p.viewport(s), y.updateMatrices(v, w), i = y.getFrustum(), x(o, l, y.camera, v, this.type)
                        }
                        y.isPointLightShadow || 3 !== this.type || g(y, l)
                    } else console.warn("THREE.WebGLShadowMap:", v, "has no shadow.")
                }
                m.needsUpdate = !1, t.setRenderTarget(h, u, c)
            }
        }
    }

    function nh(t, e, n) {
        var i = n.isWebGL2;
        var r = new function () {
                var e = !1,
                    n = new _a,
                    i = null,
                    r = new _a(0, 0, 0, 0);
                return {
                    setMask: function (n) {
                        i === n || e || (t.colorMask(n, n, n, n), i = n)
                    },
                    setLocked: function (t) {
                        e = t
                    },
                    setClear: function (e, i, a, s, o) {
                        !0 === o && (e *= s, i *= s, a *= s), n.set(e, i, a, s), !1 === r.equals(n) && (t.clearColor(e, i, a, s), r.copy(n))
                    },
                    reset: function () {
                        e = !1, i = null, r.set(-1, 0, 0, 0)
                    }
                }
            },
            a = new function () {
                var e = !1,
                    n = null,
                    i = null,
                    r = null;
                return {
                    setTest: function (e) {
                        e ? B(t.DEPTH_TEST) : z(t.DEPTH_TEST)
                    },
                    setMask: function (i) {
                        n === i || e || (t.depthMask(i), n = i)
                    },
                    setFunc: function (e) {
                        if (i !== e) {
                            if (e) switch (e) {
                                case 0:
                                    t.depthFunc(t.NEVER);
                                    break;
                                case 1:
                                    t.depthFunc(t.ALWAYS);
                                    break;
                                case 2:
                                    t.depthFunc(t.LESS);
                                    break;
                                case 3:
                                    t.depthFunc(t.LEQUAL);
                                    break;
                                case 4:
                                    t.depthFunc(t.EQUAL);
                                    break;
                                case 5:
                                    t.depthFunc(t.GEQUAL);
                                    break;
                                case 6:
                                    t.depthFunc(t.GREATER);
                                    break;
                                case 7:
                                    t.depthFunc(t.NOTEQUAL);
                                    break;
                                default:
                                    t.depthFunc(t.LEQUAL)
                            } else t.depthFunc(t.LEQUAL);
                            i = e
                        }
                    },
                    setLocked: function (t) {
                        e = t
                    },
                    setClear: function (e) {
                        r !== e && (t.clearDepth(e), r = e)
                    },
                    reset: function () {
                        e = !1, n = null, i = null, r = null
                    }
                }
            },
            s = new function () {
                var e = !1,
                    n = null,
                    i = null,
                    r = null,
                    a = null,
                    s = null,
                    o = null,
                    l = null,
                    h = null;
                return {
                    setTest: function (n) {
                        e || (n ? B(t.STENCIL_TEST) : z(t.STENCIL_TEST))
                    },
                    setMask: function (i) {
                        n === i || e || (t.stencilMask(i), n = i)
                    },
                    setFunc: function (e, n, s) {
                        i === e && r === n && a === s || (t.stencilFunc(e, n, s), i = e, r = n, a = s)
                    },
                    setOp: function (e, n, i) {
                        s === e && o === n && l === i || (t.stencilOp(e, n, i), s = e, o = n, l = i)
                    },
                    setLocked: function (t) {
                        e = t
                    },
                    setClear: function (e) {
                        h !== e && (t.clearStencil(e), h = e)
                    },
                    reset: function () {
                        e = !1, n = null, i = null, r = null, a = null, s = null, o = null, l = null, h = null
                    }
                }
            },
            o = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            l = new Uint8Array(o),
            h = new Uint8Array(o),
            u = new Uint8Array(o),
            c = {},
            p = null,
            f = null,
            d = null,
            m = null,
            g = null,
            v = null,
            y = null,
            _ = null,
            x = null,
            b = !1,
            E = null,
            w = null,
            D = null,
            M = null,
            S = null,
            T = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
            A = !1,
            C = 0,
            P = t.getParameter(t.VERSION); - 1 !== P.indexOf("WebGL") ? (C = parseFloat(/^WebGL\ ([0-9])/.exec(P)[1]), A = C >= 1) : -1 !== P.indexOf("OpenGL ES") && (C = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(P)[1]), A = C >= 2);
        var F = null,
            L = {},
            R = new _a,
            I = new _a;

        function k(e, n, i) {
            var r = new Uint8Array(4),
                a = t.createTexture();
            t.bindTexture(e, a), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
            for (var s = 0; s < i; s++) t.texImage2D(n + s, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
            return a
        }
        var O = {};

        function N(n, r) {
            (l[n] = 1, 0 === h[n] && (t.enableVertexAttribArray(n), h[n] = 1), u[n] !== r) && ((i ? t : e.get("ANGLE_instanced_arrays"))[i ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), u[n] = r)
        }

        function B(e) {
            !0 !== c[e] && (t.enable(e), c[e] = !0)
        }

        function z(e) {
            !1 !== c[e] && (t.disable(e), c[e] = !1)
        }
        O[t.TEXTURE_2D] = k(t.TEXTURE_2D, t.TEXTURE_2D, 1), O[t.TEXTURE_CUBE_MAP] = k(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), r.setClear(0, 0, 0, 1), a.setClear(1), s.setClear(0), B(t.DEPTH_TEST), a.setFunc(3), j(!1), W(1), B(t.CULL_FACE), H(0);
        var U = {
            100: t.FUNC_ADD,
            101: t.FUNC_SUBTRACT,
            102: t.FUNC_REVERSE_SUBTRACT
        };
        if (i) U[103] = t.MIN, U[104] = t.MAX;
        else {
            var V = e.get("EXT_blend_minmax");
            null !== V && (U[103] = V.MIN_EXT, U[104] = V.MAX_EXT)
        }
        var G = {
            200: t.ZERO,
            201: t.ONE,
            202: t.SRC_COLOR,
            204: t.SRC_ALPHA,
            210: t.SRC_ALPHA_SATURATE,
            208: t.DST_COLOR,
            206: t.DST_ALPHA,
            203: t.ONE_MINUS_SRC_COLOR,
            205: t.ONE_MINUS_SRC_ALPHA,
            209: t.ONE_MINUS_DST_COLOR,
            207: t.ONE_MINUS_DST_ALPHA
        };

        function H(e, n, i, r, a, s, o, l) {
            if (0 !== e) {
                if (f || (B(t.BLEND), f = !0), 5 === e) a = a || n, s = s || i, o = o || r, n === m && a === y || (t.blendEquationSeparate(U[n], U[a]), m = n, y = a), i === g && r === v && s === _ && o === x || (t.blendFuncSeparate(G[i], G[r], G[s], G[o]), g = i, v = r, _ = s, x = o), d = e, b = null;
                else if (e !== d || l !== b) {
                    if (100 === m && 100 === y || (t.blendEquation(t.FUNC_ADD), m = 100, y = 100), l) switch (e) {
                        case 1:
                            t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 2:
                            t.blendFunc(t.ONE, t.ONE);
                            break;
                        case 3:
                            t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 4:
                            t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                    } else switch (e) {
                        case 1:
                            t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                            break;
                        case 2:
                            t.blendFunc(t.SRC_ALPHA, t.ONE);
                            break;
                        case 3:
                            t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR);
                            break;
                        case 4:
                            t.blendFunc(t.ZERO, t.SRC_COLOR);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                    }
                    g = null, v = null, _ = null, x = null, d = e, b = l
                }
            } else f && (z(t.BLEND), f = !1)
        }

        function j(e) {
            E !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), E = e)
        }

        function W(e) {
            0 !== e ? (B(t.CULL_FACE), e !== w && (1 === e ? t.cullFace(t.BACK) : 2 === e ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : z(t.CULL_FACE), w = e
        }

        function X(e, n, i) {
            e ? (B(t.POLYGON_OFFSET_FILL), M === n && S === i || (t.polygonOffset(n, i), M = n, S = i)) : z(t.POLYGON_OFFSET_FILL)
        }

        function q(e) {
            void 0 === e && (e = t.TEXTURE0 + T - 1), F !== e && (t.activeTexture(e), F = e)
        }
        return {
            buffers: {
                color: r,
                depth: a,
                stencil: s
            },
            initAttributes: function () {
                for (var t = 0, e = l.length; t < e; t++) l[t] = 0
            },
            enableAttribute: function (t) {
                N(t, 0)
            },
            enableAttributeAndDivisor: N,
            disableUnusedAttributes: function () {
                for (var e = 0, n = h.length; e !== n; ++e) h[e] !== l[e] && (t.disableVertexAttribArray(e), h[e] = 0)
            },
            vertexAttribPointer: function (e, n, r, a, s, o) {
                !0 !== i || r !== t.INT && r !== t.UNSIGNED_INT ? t.vertexAttribPointer(e, n, r, a, s, o) : t.vertexAttribIPointer(e, n, r, a, s, o)
            },
            enable: B,
            disable: z,
            useProgram: function (e) {
                return p !== e && (t.useProgram(e), p = e, !0)
            },
            setBlending: H,
            setMaterial: function (e, n) {
                2 === e.side ? z(t.CULL_FACE) : B(t.CULL_FACE);
                var i = 1 === e.side;
                n && (i = !i), j(i), 1 === e.blending && !1 === e.transparent ? H(0) : H(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), r.setMask(e.colorWrite);
                var o = e.stencilWrite;
                s.setTest(o), o && (s.setMask(e.stencilWriteMask), s.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), s.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), X(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            },
            setFlipSided: j,
            setCullFace: W,
            setLineWidth: function (e) {
                e !== D && (A && t.lineWidth(e), D = e)
            },
            setPolygonOffset: X,
            setScissorTest: function (e) {
                e ? B(t.SCISSOR_TEST) : z(t.SCISSOR_TEST)
            },
            activeTexture: q,
            bindTexture: function (e, n) {
                null === F && q();
                var i = L[F];
                void 0 === i && (i = {
                    type: void 0,
                    texture: void 0
                }, L[F] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || O[e]), i.type = e, i.texture = n)
            },
            unbindTexture: function () {
                var e = L[F];
                void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
            },
            compressedTexImage2D: function () {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage2D: function () {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage3D: function () {
                try {
                    t.texImage3D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            scissor: function (e) {
                !1 === R.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), R.copy(e))
            },
            viewport: function (e) {
                !1 === I.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), I.copy(e))
            },
            reset: function () {
                for (var e = 0; e < h.length; e++) 1 === h[e] && (t.disableVertexAttribArray(e), h[e] = 0);
                c = {}, F = null, L = {}, p = null, d = null, E = null, w = null, r.reset(), a.reset(), s.reset()
            }
        }
    }

    function ih(t, e, n, i, r, a, s) {
        var o, l = r.isWebGL2,
            h = r.maxTextures,
            u = r.maxCubemapSize,
            c = r.maxTextureSize,
            p = r.maxSamples,
            f = new WeakMap,
            d = !1;
        try {
            d = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
        } catch (t) {}

        function m(t, e) {
            return d ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }

        function g(t, e, n, i) {
            var r = 1;
            if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    var a = e ? br.floorPowerOfTwo : Math.floor,
                        s = a(r * t.width),
                        l = a(r * t.height);
                    void 0 === o && (o = m(s, l));
                    var h = n ? m(s, l) : o;
                    return h.width = s, h.height = l, h.getContext("2d").drawImage(t, 0, 0, s, l), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + l + ")."), h
                }
                return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
            }
            return t
        }

        function v(t) {
            return br.isPowerOfTwo(t.width) && br.isPowerOfTwo(t.height)
        }

        function y(t, e) {
            return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
        }

        function _(e, n, r, a) {
            t.generateMipmap(e), i.get(n).__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E
        }

        function x(n, i, r) {
            if (!1 === l) return i;
            if (null !== n) {
                if (void 0 !== t[n]) return t[n];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
            }
            var a = i;
            return i === t.RED && (r === t.FLOAT && (a = t.R32F), r === t.HALF_FLOAT && (a = t.R16F), r === t.UNSIGNED_BYTE && (a = t.R8)), i === t.RGB && (r === t.FLOAT && (a = t.RGB32F), r === t.HALF_FLOAT && (a = t.RGB16F), r === t.UNSIGNED_BYTE && (a = t.RGB8)), i === t.RGBA && (r === t.FLOAT && (a = t.RGBA32F), r === t.HALF_FLOAT && (a = t.RGBA16F), r === t.UNSIGNED_BYTE && (a = t.RGBA8)), a !== t.R16F && a !== t.R32F && a !== t.RGBA16F && a !== t.RGBA32F || e.get("EXT_color_buffer_float"), a
        }

        function b(e) {
            return 1003 === e || 1004 === e || 1005 === e ? t.NEAREST : t.LINEAR
        }

        function E(e) {
            var n = e.target;
            n.removeEventListener("dispose", E),
                function (e) {
                    var n = i.get(e);
                    if (void 0 === n.__webglInit) return;
                    t.deleteTexture(n.__webglTexture), i.remove(e)
                }(n), n.isVideoTexture && f.delete(n), s.memory.textures--
        }

        function w(e) {
            var n = e.target;
            n.removeEventListener("dispose", w),
                function (e) {
                    var n = i.get(e),
                        r = i.get(e.texture);
                    if (!e) return;
                    void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
                    e.depthTexture && e.depthTexture.dispose();
                    if (e.isWebGLCubeRenderTarget)
                        for (var a = 0; a < 6; a++) t.deleteFramebuffer(n.__webglFramebuffer[a]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[a]);
                    else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && t.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                    i.remove(e.texture), i.remove(e)
                }(n), s.memory.textures--
        }
        var D = 0;

        function M(e, r) {
            var a = i.get(e);
            if (e.isVideoTexture && function (t) {
                    var e = s.render.frame;
                    f.get(t) !== e && (f.set(t, e), t.update())
                }(e), e.version > 0 && a.__version !== e.version) {
                var o = e.image;
                if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== o.complete) return void L(a, e, r);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_2D, a.__webglTexture)
        }

        function S(e, r) {
            if (6 === e.image.length) {
                var s = i.get(e);
                if (e.version > 0 && s.__version !== e.version) {
                    F(s, e), n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, s.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                    for (var o = e && (e.isCompressedTexture || e.image[0].isCompressedTexture), h = e.image[0] && e.image[0].isDataTexture, c = [], p = 0; p < 6; p++) c[p] = o || h ? h ? e.image[p].image : e.image[p] : g(e.image[p], !1, !0, u);
                    var f, d = c[0],
                        m = v(d) || l,
                        b = a.convert(e.format),
                        E = a.convert(e.type),
                        w = x(e.internalFormat, b, E);
                    if (P(t.TEXTURE_CUBE_MAP, e, m), o) {
                        for (p = 0; p < 6; p++) {
                            f = c[p].mipmaps;
                            for (var D = 0; D < f.length; D++) {
                                var M = f[D];
                                1023 !== e.format && 1022 !== e.format ? null !== b ? n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + p, D, w, M.width, M.height, 0, M.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + p, D, w, M.width, M.height, 0, b, E, M.data)
                            }
                        }
                        s.__maxMipLevel = f.length - 1
                    } else {
                        f = e.mipmaps;
                        for (p = 0; p < 6; p++)
                            if (h) {
                                n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, w, c[p].width, c[p].height, 0, b, E, c[p].data);
                                for (D = 0; D < f.length; D++) {
                                    var S = (M = f[D]).image[p].image;
                                    n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + p, D + 1, w, S.width, S.height, 0, b, E, S.data)
                                }
                            } else {
                                n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, w, b, E, c[p]);
                                for (D = 0; D < f.length; D++) {
                                    M = f[D];
                                    n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + p, D + 1, w, b, E, M.image[p])
                                }
                            } s.__maxMipLevel = f.length
                    }
                    y(e, m) && _(t.TEXTURE_CUBE_MAP, e, d.width, d.height), s.__version = e.version, e.onUpdate && e.onUpdate(e)
                } else n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, s.__webglTexture)
            }
        }

        function T(e, r) {
            n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, i.get(e).__webglTexture)
        }
        var A = {
                1e3: t.REPEAT,
                1001: t.CLAMP_TO_EDGE,
                1002: t.MIRRORED_REPEAT
            },
            C = {
                1003: t.NEAREST,
                1004: t.NEAREST_MIPMAP_NEAREST,
                1005: t.NEAREST_MIPMAP_LINEAR,
                1006: t.LINEAR,
                1007: t.LINEAR_MIPMAP_NEAREST,
                1008: t.LINEAR_MIPMAP_LINEAR
            };

        function P(n, a, s) {
            s ? (t.texParameteri(n, t.TEXTURE_WRAP_S, A[a.wrapS]), t.texParameteri(n, t.TEXTURE_WRAP_T, A[a.wrapT]), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, A[a.wrapR]), t.texParameteri(n, t.TEXTURE_MAG_FILTER, C[a.magFilter]), t.texParameteri(n, t.TEXTURE_MIN_FILTER, C[a.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), 1001 === a.wrapS && 1001 === a.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, t.TEXTURE_MAG_FILTER, b(a.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, b(a.minFilter)), 1003 !== a.minFilter && 1006 !== a.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
            var o = e.get("EXT_texture_filter_anisotropic");
            if (o) {
                if (1015 === a.type && null === e.get("OES_texture_float_linear")) return;
                if (1016 === a.type && null === (l || e.get("OES_texture_half_float_linear"))) return;
                (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), i.get(a).__currentAnisotropy = a.anisotropy)
            }
        }

        function F(e, n) {
            void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", E), e.__webglTexture = t.createTexture(), s.memory.textures++)
        }

        function L(e, i, r) {
            var s = t.TEXTURE_2D;
            i.isDataTexture2DArray && (s = t.TEXTURE_2D_ARRAY), i.isDataTexture3D && (s = t.TEXTURE_3D), F(e, i), n.activeTexture(t.TEXTURE0 + r), n.bindTexture(s, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment);
            var o = function (t) {
                    return !l && (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter)
                }(i) && !1 === v(i.image),
                h = g(i.image, o, !1, c),
                u = v(h) || l,
                p = a.convert(i.format),
                f = a.convert(i.type),
                d = x(i.internalFormat, p, f);
            P(s, i, u);
            var m, b = i.mipmaps;
            if (i.isDepthTexture) d = t.DEPTH_COMPONENT, l ? d = 1015 === i.type ? t.DEPTH_COMPONENT32F : 1014 === i.type ? t.DEPTH_COMPONENT24 : 1020 === i.type ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : 1015 === i.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === i.format && d === t.DEPTH_COMPONENT && 1012 !== i.type && 1014 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = 1012, f = a.convert(i.type)), 1027 === i.format && d === t.DEPTH_COMPONENT && (d = t.DEPTH_STENCIL, 1020 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = 1020, f = a.convert(i.type))), n.texImage2D(t.TEXTURE_2D, 0, d, h.width, h.height, 0, p, f, null);
            else if (i.isDataTexture)
                if (b.length > 0 && u) {
                    for (var E = 0, w = b.length; E < w; E++) m = b[E], n.texImage2D(t.TEXTURE_2D, E, d, m.width, m.height, 0, p, f, m.data);
                    i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                } else n.texImage2D(t.TEXTURE_2D, 0, d, h.width, h.height, 0, p, f, h.data), e.__maxMipLevel = 0;
            else if (i.isCompressedTexture) {
                for (E = 0, w = b.length; E < w; E++) m = b[E], 1023 !== i.format && 1022 !== i.format ? null !== p ? n.compressedTexImage2D(t.TEXTURE_2D, E, d, m.width, m.height, 0, m.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(t.TEXTURE_2D, E, d, m.width, m.height, 0, p, f, m.data);
                e.__maxMipLevel = b.length - 1
            } else if (i.isDataTexture2DArray) n.texImage3D(t.TEXTURE_2D_ARRAY, 0, d, h.width, h.height, h.depth, 0, p, f, h.data), e.__maxMipLevel = 0;
            else if (i.isDataTexture3D) n.texImage3D(t.TEXTURE_3D, 0, d, h.width, h.height, h.depth, 0, p, f, h.data), e.__maxMipLevel = 0;
            else if (b.length > 0 && u) {
                for (E = 0, w = b.length; E < w; E++) m = b[E], n.texImage2D(t.TEXTURE_2D, E, d, p, f, m);
                i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
            } else n.texImage2D(t.TEXTURE_2D, 0, d, p, f, h), e.__maxMipLevel = 0;
            y(i, u) && _(s, i, h.width, h.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
        }

        function R(e, r, s, o) {
            var l = a.convert(r.texture.format),
                h = a.convert(r.texture.type),
                u = x(r.texture.internalFormat, l, h);
            n.texImage2D(o, 0, u, r.width, r.height, 0, l, h, null), t.bindFramebuffer(t.FRAMEBUFFER, e), t.framebufferTexture2D(t.FRAMEBUFFER, s, o, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(t.FRAMEBUFFER, null)
        }

        function I(e, n, i) {
            if (t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer) {
                var r = t.DEPTH_COMPONENT16;
                if (i) {
                    var s = n.depthTexture;
                    s && s.isDepthTexture && (1015 === s.type ? r = t.DEPTH_COMPONENT32F : 1014 === s.type && (r = t.DEPTH_COMPONENT24));
                    var o = O(n);
                    t.renderbufferStorageMultisample(t.RENDERBUFFER, o, r, n.width, n.height)
                } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
                t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)
            } else if (n.depthBuffer && n.stencilBuffer) {
                if (i) {
                    o = O(n);
                    t.renderbufferStorageMultisample(t.RENDERBUFFER, o, t.DEPTH24_STENCIL8, n.width, n.height)
                } else t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height);
                t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
            } else {
                var l = a.convert(n.texture.format),
                    h = a.convert(n.texture.type);
                r = x(n.texture.internalFormat, l, h);
                if (i) {
                    o = O(n);
                    t.renderbufferStorageMultisample(t.RENDERBUFFER, o, r, n.width, n.height)
                } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height)
            }
            t.bindRenderbuffer(t.RENDERBUFFER, null)
        }

        function k(e) {
            var n = i.get(e),
                r = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture) {
                if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                ! function (e, n) {
                    if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                    if (t.bindFramebuffer(t.FRAMEBUFFER, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), M(n.depthTexture, 0);
                    var r = i.get(n.depthTexture).__webglTexture;
                    if (1026 === n.depthTexture.format) t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, r, 0);
                    else {
                        if (1027 !== n.depthTexture.format) throw new Error("Unknown depthTexture format");
                        t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, r, 0)
                    }
                }(n.__webglFramebuffer, e)
            } else if (r) {
                n.__webglDepthbuffer = [];
                for (var a = 0; a < 6; a++) t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer[a]), n.__webglDepthbuffer[a] = t.createRenderbuffer(), I(n.__webglDepthbuffer[a], e, !1)
            } else t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), I(n.__webglDepthbuffer, e, !1);
            t.bindFramebuffer(t.FRAMEBUFFER, null)
        }

        function O(t) {
            return l && t.isWebGLMultisampleRenderTarget ? Math.min(p, t.samples) : 0
        }
        var N = !1,
            B = !1;
        this.allocateTextureUnit = function () {
            var t = D;
            return t >= h && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + h), D += 1, t
        }, this.resetTextureUnits = function () {
            D = 0
        }, this.setTexture2D = M, this.setTexture2DArray = function (e, r) {
            var a = i.get(e);
            e.version > 0 && a.__version !== e.version ? L(a, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_2D_ARRAY, a.__webglTexture))
        }, this.setTexture3D = function (e, r) {
            var a = i.get(e);
            e.version > 0 && a.__version !== e.version ? L(a, e, r) : (n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_3D, a.__webglTexture))
        }, this.setTextureCube = S, this.setTextureCubeDynamic = T, this.setupRenderTarget = function (e) {
            var r = i.get(e),
                o = i.get(e.texture);
            e.addEventListener("dispose", w), o.__webglTexture = t.createTexture(), s.memory.textures++;
            var h = !0 === e.isWebGLCubeRenderTarget,
                u = !0 === e.isWebGLMultisampleRenderTarget,
                c = v(e) || l;
            if (!l || 1022 !== e.texture.format || 1015 !== e.texture.type && 1016 !== e.texture.type || (e.texture.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), h) {
                r.__webglFramebuffer = [];
                for (var p = 0; p < 6; p++) r.__webglFramebuffer[p] = t.createFramebuffer()
            } else if (r.__webglFramebuffer = t.createFramebuffer(), u)
                if (l) {
                    r.__webglMultisampledFramebuffer = t.createFramebuffer(), r.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, r.__webglColorRenderbuffer);
                    var f = a.convert(e.texture.format),
                        d = a.convert(e.texture.type),
                        m = x(e.texture.internalFormat, f, d),
                        g = O(e);
                    t.renderbufferStorageMultisample(t.RENDERBUFFER, g, m, e.width, e.height), t.bindFramebuffer(t.FRAMEBUFFER, r.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, r.__webglColorRenderbuffer), t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (r.__webglDepthRenderbuffer = t.createRenderbuffer(), I(r.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(t.FRAMEBUFFER, null)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (h) {
                n.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture), P(t.TEXTURE_CUBE_MAP, e.texture, c);
                for (p = 0; p < 6; p++) R(r.__webglFramebuffer[p], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + p);
                y(e.texture, c) && _(t.TEXTURE_CUBE_MAP, e.texture, e.width, e.height), n.bindTexture(t.TEXTURE_CUBE_MAP, null)
            } else n.bindTexture(t.TEXTURE_2D, o.__webglTexture), P(t.TEXTURE_2D, e.texture, c), R(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), y(e.texture, c) && _(t.TEXTURE_2D, e.texture, e.width, e.height), n.bindTexture(t.TEXTURE_2D, null);
            e.depthBuffer && k(e)
        }, this.updateRenderTargetMipmap = function (e) {
            var r = e.texture;
            if (y(r, v(e) || l)) {
                var a = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                    s = i.get(r).__webglTexture;
                n.bindTexture(a, s), _(a, r, e.width, e.height), n.bindTexture(a, null)
            }
        }, this.updateMultisampleRenderTarget = function (e) {
            if (e.isWebGLMultisampleRenderTarget)
                if (l) {
                    var n = i.get(e);
                    t.bindFramebuffer(t.READ_FRAMEBUFFER, n.__webglMultisampledFramebuffer), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, n.__webglFramebuffer);
                    var r = e.width,
                        a = e.height,
                        s = t.COLOR_BUFFER_BIT;
                    e.depthBuffer && (s |= t.DEPTH_BUFFER_BIT), e.stencilBuffer && (s |= t.STENCIL_BUFFER_BIT), t.blitFramebuffer(0, 0, r, a, 0, 0, r, a, s, t.NEAREST), t.bindFramebuffer(t.FRAMEBUFFER, n.__webglMultisampledFramebuffer)
                } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }, this.safeSetTexture2D = function (t, e) {
            t && t.isWebGLRenderTarget && (!1 === N && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), N = !0), t = t.texture), M(t, e)
        }, this.safeSetTextureCube = function (t, e) {
            t && t.isWebGLCubeRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? S(t, e) : T(t, e)
        }
    }

    function rh(t, e, n) {
        var i = n.isWebGL2;
        return {
            convert: function (n) {
                var r;
                if (1009 === n) return t.UNSIGNED_BYTE;
                if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
                if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
                if (1019 === n) return t.UNSIGNED_SHORT_5_6_5;
                if (1010 === n) return t.BYTE;
                if (1011 === n) return t.SHORT;
                if (1012 === n) return t.UNSIGNED_SHORT;
                if (1013 === n) return t.INT;
                if (1014 === n) return t.UNSIGNED_INT;
                if (1015 === n) return t.FLOAT;
                if (1016 === n) return i ? t.HALF_FLOAT : null !== (r = e.get("OES_texture_half_float")) ? r.HALF_FLOAT_OES : null;
                if (1021 === n) return t.ALPHA;
                if (1022 === n) return t.RGB;
                if (1023 === n) return t.RGBA;
                if (1024 === n) return t.LUMINANCE;
                if (1025 === n) return t.LUMINANCE_ALPHA;
                if (1026 === n) return t.DEPTH_COMPONENT;
                if (1027 === n) return t.DEPTH_STENCIL;
                if (1028 === n) return t.RED;
                if (1029 === n) return t.RED_INTEGER;
                if (1030 === n) return t.RG;
                if (1031 === n) return t.RG_INTEGER;
                if (1032 === n) return t.RGB_INTEGER;
                if (1033 === n) return t.RGBA_INTEGER;
                if (33776 === n || 33777 === n || 33778 === n || 33779 === n) {
                    if (null === (r = e.get("WEBGL_compressed_texture_s3tc"))) return null;
                    if (33776 === n) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === n) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === n) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === n) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
                    if (null === (r = e.get("WEBGL_compressed_texture_pvrtc"))) return null;
                    if (35840 === n) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === n) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === n) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === n) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === n) return null !== (r = e.get("WEBGL_compressed_texture_etc1")) ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((37492 === n || 37496 === n) && null !== (r = e.get("WEBGL_compressed_texture_etc"))) {
                    if (37492 === n) return r.COMPRESSED_RGB8_ETC2;
                    if (37496 === n) return r.COMPRESSED_RGBA8_ETC2_EAC
                }
                return 37808 === n || 37809 === n || 37810 === n || 37811 === n || 37812 === n || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n || 37840 === n || 37841 === n || 37842 === n || 37843 === n || 37844 === n || 37845 === n || 37846 === n || 37847 === n || 37848 === n || 37849 === n || 37850 === n || 37851 === n || 37852 === n || 37853 === n ? null !== (r = e.get("WEBGL_compressed_texture_astc")) ? n : null : 36492 === n ? null !== (r = e.get("EXT_texture_compression_bptc")) ? n : null : 1020 === n ? i ? t.UNSIGNED_INT_24_8 : null !== (r = e.get("WEBGL_depth_texture")) ? r.UNSIGNED_INT_24_8_WEBGL : null : void 0
            }
        }
    }

    function ah() {
        Na.call(this), this.type = "Camera", this.matrixWorldInverse = new ua, this.projectionMatrix = new ua, this.projectionMatrixInverse = new ua
    }

    function sh(t, e, n, i) {
        ah.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    function oh(t) {
        sh.call(this), this.cameras = t || []
    }

    function lh() {
        Na.call(this), this.type = "Group"
    }

    function hh() {
        this._targetRay = null, this._grip = null
    }

    function uh(t, e) {
        var n = this,
            i = null,
            r = 1,
            a = null,
            s = "local-floor",
            o = null,
            l = [],
            h = new Map,
            u = new sh;
        u.layers.enable(1), u.viewport = new _a;
        var c = new sh;
        c.layers.enable(2), c.viewport = new _a;
        var p = [u, c],
            f = new oh;
        f.layers.enable(1), f.layers.enable(2);
        var d = null,
            m = null;

        function g(t) {
            var e = h.get(t.inputSource);
            e && e.dispatchEvent({
                type: t.type
            })
        }

        function v() {
            h.forEach((function (t, e) {
                t.disconnect(e)
            })), h.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), D.stop(), n.isPresenting = !1, n.dispatchEvent({
                type: "sessionend"
            })
        }

        function y(t) {
            a = t, D.setContext(i), D.start(), n.isPresenting = !0, n.dispatchEvent({
                type: "sessionstart"
            })
        }

        function _(t) {
            for (var e = i.inputSources, n = 0; n < l.length; n++) h.set(e[n], l[n]);
            for (n = 0; n < t.removed.length; n++) {
                var r = t.removed[n];
                (a = h.get(r)) && (a.dispatchEvent({
                    type: "disconnected",
                    data: r
                }), h.delete(r))
            }
            for (n = 0; n < t.added.length; n++) {
                var a;
                r = t.added[n];
                (a = h.get(r)) && a.dispatchEvent({
                    type: "connected",
                    data: r
                })
            }
        }
        this.enabled = !1, this.isPresenting = !1, this.getController = function (t) {
            var e = l[t];
            return void 0 === e && (e = new hh, l[t] = e), e.getTargetRaySpace()
        }, this.getControllerGrip = function (t) {
            var e = l[t];
            return void 0 === e && (e = new hh, l[t] = e), e.getGripSpace()
        }, this.setFramebufferScaleFactor = function (t) {
            r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function (t) {
            s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function () {
            return a
        }, this.getSession = function () {
            return i
        }, this.setSession = function (t) {
            if (null !== (i = t)) {
                i.addEventListener("select", g), i.addEventListener("selectstart", g), i.addEventListener("selectend", g), i.addEventListener("squeeze", g), i.addEventListener("squeezestart", g), i.addEventListener("squeezeend", g), i.addEventListener("end", v);
                var n = e.getContextAttributes(),
                    a = {
                        antialias: n.antialias,
                        alpha: n.alpha,
                        depth: n.depth,
                        stencil: n.stencil,
                        framebufferScaleFactor: r
                    },
                    o = new XRWebGLLayer(i, e, a);
                i.updateRenderState({
                    baseLayer: o
                }), i.requestReferenceSpace(s).then(y), i.addEventListener("inputsourceschange", _)
            }
        };
        var x = new Lr,
            b = new Lr;

        function E(t, e) {
            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
        }
        this.getCamera = function (t) {
            f.near = c.near = u.near = t.near, f.far = c.far = u.far = t.far, d === f.near && m === f.far || (i.updateRenderState({
                depthNear: f.near,
                depthFar: f.far
            }), d = f.near, m = f.far);
            var e = t.parent,
                n = f.cameras;
            E(f, e);
            for (var r = 0; r < n.length; r++) E(n[r], e);
            t.matrixWorld.copy(f.matrixWorld);
            for (var a = t.children, s = (r = 0, a.length); r < s; r++) a[r].updateMatrixWorld(!0);
            return 2 === n.length ? function (t, e, n) {
                x.setFromMatrixPosition(e.matrixWorld), b.setFromMatrixPosition(n.matrixWorld);
                var i = x.distanceTo(b),
                    r = e.projectionMatrix.elements,
                    a = n.projectionMatrix.elements,
                    s = r[14] / (r[10] - 1),
                    o = r[14] / (r[10] + 1),
                    l = (r[9] + 1) / r[5],
                    h = (r[9] - 1) / r[5],
                    u = (r[8] - 1) / r[0],
                    c = (a[8] + 1) / a[0],
                    p = s * u,
                    f = s * c,
                    d = i / (-u + c),
                    m = d * -u;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(d), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
                var g = s + d,
                    v = o + d,
                    y = p - m,
                    _ = f + (i - m),
                    E = l * o / v * g,
                    w = h * o / v * g;
                t.projectionMatrix.makePerspective(y, _, E, w, g, v)
            }(f, u, c) : f.projectionMatrix.copy(u.projectionMatrix), f
        };
        var w = null;
        var D = new za;
        D.setAnimationLoop((function (e, n) {
            if (null !== (o = n.getViewerPose(a))) {
                var r = o.views,
                    s = i.renderState.baseLayer;
                t.setFramebuffer(s.framebuffer);
                var h = !1;
                r.length !== f.cameras.length && (f.cameras.length = 0, h = !0);
                for (var u = 0; u < r.length; u++) {
                    var c = r[u],
                        d = s.getViewport(c),
                        m = p[u];
                    m.matrix.fromArray(c.transform.matrix), m.projectionMatrix.fromArray(c.projectionMatrix), m.viewport.set(d.x, d.y, d.width, d.height), 0 === u && f.matrix.copy(m.matrix), !0 === h && f.cameras.push(m)
                }
            }
            var g = i.inputSources;
            for (u = 0; u < l.length; u++) {
                var v = l[u],
                    y = g[u];
                v.update(y, n, a)
            }
            w && w(e, n)
        })), this.setAnimationLoop = function (t) {
            w = t
        }, this.dispose = function () {}
    }

    function ch(t) {
        var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            n = void 0 !== t.context ? t.context : null,
            i = void 0 !== t.alpha && t.alpha,
            r = void 0 === t.depth || t.depth,
            a = void 0 === t.stencil || t.stencil,
            s = void 0 !== t.antialias && t.antialias,
            o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            h = void 0 !== t.powerPreference ? t.powerPreference : "default",
            u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat,
            c = null,
            p = null;
        this.domElement = e, this.debug = {
            checkShaderErrors: !0
        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var f, d, m, g, v, y, _, x, b, E, w, D, M, S, T, A, C, P, F = this,
            L = !1,
            R = null,
            I = 0,
            k = 0,
            O = null,
            N = null,
            B = -1,
            z = {
                geometry: null,
                program: null,
                wireframe: !1
            },
            U = null,
            V = null,
            G = new _a,
            H = new _a,
            j = null,
            W = e.width,
            X = e.height,
            q = 1,
            Y = null,
            Z = null,
            J = new _a(0, 0, W, X),
            K = new _a(0, 0, W, X),
            $ = !1,
            Q = new na,
            tt = new mo,
            et = !1,
            nt = !1,
            it = new ua,
            rt = new Lr;

        function at() {
            return null === O ? q : 1
        }
        try {
            var st = {
                alpha: i,
                depth: r,
                stencil: a,
                antialias: s,
                premultipliedAlpha: o,
                preserveDrawingBuffer: l,
                powerPreference: h,
                failIfMajorPerformanceCaveat: u,
                xrCompatible: !0
            };
            if (e.addEventListener("webglcontextlost", ut, !1), e.addEventListener("webglcontextrestored", ct, !1), null === (f = n || e.getContext("webgl", st) || e.getContext("experimental-webgl", st))) throw null !== e.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            void 0 === f.getShaderPrecisionFormat && (f.getShaderPrecisionFormat = function () {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (t) {
            throw console.error("THREE.WebGLRenderer: " + t.message), t
        }

        function ot() {
            d = new go(f), !1 === (m = new fo(f, d, t)).isWebGL2 && (d.get("WEBGL_depth_texture"), d.get("OES_texture_float"), d.get("OES_texture_half_float"), d.get("OES_texture_half_float_linear"), d.get("OES_standard_derivatives"), d.get("OES_element_index_uint"), d.get("ANGLE_instanced_arrays")), d.get("OES_texture_float_linear"), P = new rh(f, d, m), (g = new nh(f, d, m)).scissor(H.copy(K).multiplyScalar(q).floor()), g.viewport(G.copy(J).multiplyScalar(q).floor()), v = new _o(f), y = new Vl, _ = new ih(f, d, g, y, m, P, v), x = new Ua(f, m), b = new vo(f, x, v), E = new Eo(f, b, x, v), T = new bo(f), w = new Ul(F, d, m), D = new Wl, M = new Kl, S = new co(F, g, E, o), A = new po(f, d, v, m), C = new yo(f, d, v, m), v.programs = w.programs, F.capabilities = m, F.extensions = d, F.properties = y, F.renderLists = D, F.state = g, F.info = v
        }
        ot();
        var lt = new uh(F, f);
        this.xr = lt;
        var ht = new eh(F, E, m.maxTextureSize);

        function ut(t) {
            t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), L = !0
        }

        function ct() {
            console.log("THREE.WebGLRenderer: Context Restored."), L = !1, ot()
        }

        function pt(t) {
            var e = t.target;
            e.removeEventListener("dispose", pt),
                function (t) {
                    ft(t), y.remove(t)
                }(e)
        }

        function ft(t) {
            var e = y.get(t).program;
            t.program = void 0, void 0 !== e && w.releaseProgram(e)
        }
        this.shadowMap = ht, this.getContext = function () {
            return f
        }, this.getContextAttributes = function () {
            return f.getContextAttributes()
        }, this.forceContextLoss = function () {
            var t = d.get("WEBGL_lose_context");
            t && t.loseContext()
        }, this.forceContextRestore = function () {
            var t = d.get("WEBGL_lose_context");
            t && t.restoreContext()
        }, this.getPixelRatio = function () {
            return q
        }, this.setPixelRatio = function (t) {
            void 0 !== t && (q = t, this.setSize(W, X, !1))
        }, this.getSize = function (t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new wr), t.set(W, X)
        }, this.setSize = function (t, n, i) {
            lt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (W = t, X = n, e.width = Math.floor(t * q), e.height = Math.floor(n * q), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
        }, this.getDrawingBufferSize = function (t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new wr), t.set(W * q, X * q).floor()
        }, this.setDrawingBufferSize = function (t, n, i) {
            W = t, X = n, q = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
        }, this.getCurrentViewport = function (t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new _a), t.copy(G)
        }, this.getViewport = function (t) {
            return t.copy(J)
        }, this.setViewport = function (t, e, n, i) {
            t.isVector4 ? J.set(t.x, t.y, t.z, t.w) : J.set(t, e, n, i), g.viewport(G.copy(J).multiplyScalar(q).floor())
        }, this.getScissor = function (t) {
            return t.copy(K)
        }, this.setScissor = function (t, e, n, i) {
            t.isVector4 ? K.set(t.x, t.y, t.z, t.w) : K.set(t, e, n, i), g.scissor(H.copy(K).multiplyScalar(q).floor())
        }, this.getScissorTest = function () {
            return $
        }, this.setScissorTest = function (t) {
            g.setScissorTest($ = t)
        }, this.setOpaqueSort = function (t) {
            Y = t
        }, this.setTransparentSort = function (t) {
            Z = t
        }, this.getClearColor = function () {
            return S.getClearColor()
        }, this.setClearColor = function () {
            S.setClearColor.apply(S, arguments)
        }, this.getClearAlpha = function () {
            return S.getClearAlpha()
        }, this.setClearAlpha = function () {
            S.setClearAlpha.apply(S, arguments)
        }, this.clear = function (t, e, n) {
            var i = 0;
            (void 0 === t || t) && (i |= f.COLOR_BUFFER_BIT), (void 0 === e || e) && (i |= f.DEPTH_BUFFER_BIT), (void 0 === n || n) && (i |= f.STENCIL_BUFFER_BIT), f.clear(i)
        }, this.clearColor = function () {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function () {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function () {
            this.clear(!1, !1, !0)
        }, this.dispose = function () {
            e.removeEventListener("webglcontextlost", ut, !1), e.removeEventListener("webglcontextrestored", ct, !1), D.dispose(), M.dispose(), y.dispose(), E.dispose(), lt.dispose(), gt.stop()
        }, this.renderBufferImmediate = function (t, e) {
            g.initAttributes();
            var n = y.get(t);
            t.hasPositions && !n.position && (n.position = f.createBuffer()), t.hasNormals && !n.normal && (n.normal = f.createBuffer()), t.hasUvs && !n.uv && (n.uv = f.createBuffer()), t.hasColors && !n.color && (n.color = f.createBuffer());
            var i = e.getAttributes();
            t.hasPositions && (f.bindBuffer(f.ARRAY_BUFFER, n.position), f.bufferData(f.ARRAY_BUFFER, t.positionArray, f.DYNAMIC_DRAW), g.enableAttribute(i.position), f.vertexAttribPointer(i.position, 3, f.FLOAT, !1, 0, 0)), t.hasNormals && (f.bindBuffer(f.ARRAY_BUFFER, n.normal), f.bufferData(f.ARRAY_BUFFER, t.normalArray, f.DYNAMIC_DRAW), g.enableAttribute(i.normal), f.vertexAttribPointer(i.normal, 3, f.FLOAT, !1, 0, 0)), t.hasUvs && (f.bindBuffer(f.ARRAY_BUFFER, n.uv), f.bufferData(f.ARRAY_BUFFER, t.uvArray, f.DYNAMIC_DRAW), g.enableAttribute(i.uv), f.vertexAttribPointer(i.uv, 2, f.FLOAT, !1, 0, 0)), t.hasColors && (f.bindBuffer(f.ARRAY_BUFFER, n.color), f.bufferData(f.ARRAY_BUFFER, t.colorArray, f.DYNAMIC_DRAW), g.enableAttribute(i.color), f.vertexAttribPointer(i.color, 3, f.FLOAT, !1, 0, 0)), g.disableUnusedAttributes(), f.drawArrays(f.TRIANGLES, 0, t.count), t.count = 0
        };
        var dt = new Ba;
        this.renderBufferDirect = function (t, e, n, i, r, a) {
            null === e && (e = dt);
            var s = r.isMesh && r.matrixWorld.determinant() < 0,
                o = bt(t, e, i, r);
            g.setMaterial(i, s);
            var l = !1;
            z.geometry === n.id && z.program === o.id && z.wireframe === (!0 === i.wireframe) || (z.geometry = n.id, z.program = o.id, z.wireframe = !0 === i.wireframe, l = !0), (i.morphTargets || i.morphNormals) && (T.update(r, n, i, o), l = !0), !0 === r.isInstancedMesh && (l = !0);
            var h = n.index,
                u = n.attributes.position;
            if (null === h) {
                if (void 0 === u || 0 === u.count) return
            } else if (0 === h.count) return;
            var c, p = 1;
            !0 === i.wireframe && (h = b.getWireframeAttribute(n), p = 2);
            var v = A;
            null !== h && (c = x.get(h), (v = C).setIndex(c)), l && (! function (t, e, n, i) {
                if (!1 === m.isWebGL2 && (t.isInstancedMesh || e.isInstancedBufferGeometry) && null === d.get("ANGLE_instanced_arrays")) return;
                g.initAttributes();
                var r = e.attributes,
                    a = i.getAttributes(),
                    s = n.defaultAttributeValues;
                for (var o in a) {
                    var l = a[o];
                    if (l >= 0) {
                        var h = r[o];
                        if (void 0 !== h) {
                            var u = h.normalized,
                                c = h.itemSize;
                            if (void 0 === (w = x.get(h))) continue;
                            var p = w.buffer,
                                v = w.type,
                                y = w.bytesPerElement;
                            if (h.isInterleavedBufferAttribute) {
                                var _ = h.data,
                                    b = _.stride,
                                    E = h.offset;
                                _ && _.isInstancedInterleavedBuffer ? (g.enableAttributeAndDivisor(l, _.meshPerAttribute), void 0 === e.maxInstancedCount && (e.maxInstancedCount = _.meshPerAttribute * _.count)) : g.enableAttribute(l), f.bindBuffer(f.ARRAY_BUFFER, p), g.vertexAttribPointer(l, c, v, u, b * y, E * y)
                            } else h.isInstancedBufferAttribute ? (g.enableAttributeAndDivisor(l, h.meshPerAttribute), void 0 === e.maxInstancedCount && (e.maxInstancedCount = h.meshPerAttribute * h.count)) : g.enableAttribute(l), f.bindBuffer(f.ARRAY_BUFFER, p), g.vertexAttribPointer(l, c, v, u, 0, 0)
                        } else if ("instanceMatrix" === o) {
                            var w;
                            if (void 0 === (w = x.get(t.instanceMatrix))) continue;
                            p = w.buffer, v = w.type;
                            g.enableAttributeAndDivisor(l + 0, 1), g.enableAttributeAndDivisor(l + 1, 1), g.enableAttributeAndDivisor(l + 2, 1), g.enableAttributeAndDivisor(l + 3, 1), f.bindBuffer(f.ARRAY_BUFFER, p), f.vertexAttribPointer(l + 0, 4, v, !1, 64, 0), f.vertexAttribPointer(l + 1, 4, v, !1, 64, 16), f.vertexAttribPointer(l + 2, 4, v, !1, 64, 32), f.vertexAttribPointer(l + 3, 4, v, !1, 64, 48)
                        } else if (void 0 !== s) {
                            var D = s[o];
                            if (void 0 !== D) switch (D.length) {
                                case 2:
                                    f.vertexAttrib2fv(l, D);
                                    break;
                                case 3:
                                    f.vertexAttrib3fv(l, D);
                                    break;
                                case 4:
                                    f.vertexAttrib4fv(l, D);
                                    break;
                                default:
                                    f.vertexAttrib1fv(l, D)
                            }
                        }
                    }
                }
                g.disableUnusedAttributes()
            }(r, n, i, o), null !== h && f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, c.buffer));
            var y = null !== h ? h.count : u.count,
                _ = n.drawRange.start * p,
                E = n.drawRange.count * p,
                w = null !== a ? a.start * p : 0,
                D = null !== a ? a.count * p : 1 / 0,
                M = Math.max(_, w),
                S = Math.min(y, _ + E, w + D) - 1,
                P = Math.max(0, S - M + 1);
            if (0 !== P) {
                if (r.isMesh) !0 === i.wireframe ? (g.setLineWidth(i.wireframeLinewidth * at()), v.setMode(f.LINES)) : v.setMode(f.TRIANGLES);
                else if (r.isLine) {
                    var F = i.linewidth;
                    void 0 === F && (F = 1), g.setLineWidth(F * at()), r.isLineSegments ? v.setMode(f.LINES) : r.isLineLoop ? v.setMode(f.LINE_LOOP) : v.setMode(f.LINE_STRIP)
                } else r.isPoints ? v.setMode(f.POINTS) : r.isSprite && v.setMode(f.TRIANGLES);
                r.isInstancedMesh ? v.renderInstances(n, M, P, r.count) : n.isInstancedBufferGeometry ? v.renderInstances(n, M, P, n.maxInstancedCount) : v.render(M, P)
            }
        }, this.compile = function (t, e) {
            (p = M.get(t, e)).init(), t.traverse((function (t) {
                t.isLight && (p.pushLight(t), t.castShadow && p.pushShadow(t))
            })), p.setupLights(e);
            var n = {};
            t.traverse((function (e) {
                if (e.material)
                    if (Array.isArray(e.material))
                        for (var i = 0; i < e.material.length; i++) e.material[i].uuid in n == !1 && (xt(e.material[i], t, e), n[e.material[i].uuid] = !0);
                    else e.material.uuid in n == !1 && (xt(e.material, t, e), n[e.material.uuid] = !0)
            }))
        };
        var mt = null;
        var gt = new za;

        function vt(t, e, n, i) {
            if (!1 !== t.visible) {
                if (t.layers.test(e.layers))
                    if (t.isGroup) n = t.renderOrder;
                    else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                else if (t.isLight) p.pushLight(t), t.castShadow && p.pushShadow(t);
                else if (t.isSprite) {
                    if (!t.frustumCulled || Q.intersectsSprite(t)) {
                        i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it);
                        var r = E.update(t);
                        (a = t.material).visible && c.push(t, r, a, n, rt.z, null)
                    }
                } else if (t.isImmediateRenderObject) i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it), c.push(t, null, t.material, n, rt.z, null);
                else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== v.render.frame && (t.skeleton.update(), t.skeleton.frame = v.render.frame), !t.frustumCulled || Q.intersectsObject(t))) {
                    i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it);
                    r = E.update(t);
                    var a = t.material;
                    if (Array.isArray(a))
                        for (var s = r.groups, o = 0, l = s.length; o < l; o++) {
                            var h = s[o],
                                u = a[h.materialIndex];
                            u && u.visible && c.push(t, r, u, n, rt.z, h)
                        } else a.visible && c.push(t, r, a, n, rt.z, null)
                }
                var f = t.children;
                for (o = 0, l = f.length; o < l; o++) vt(f[o], e, n, i)
            }
        }

        function yt(t, e, n, i) {
            for (var r = 0, a = t.length; r < a; r++) {
                var s = t[r],
                    o = s.object,
                    l = s.geometry,
                    h = void 0 === i ? s.material : i,
                    u = s.group;
                if (n.isArrayCamera) {
                    V = n;
                    for (var c = n.cameras, f = 0, d = c.length; f < d; f++) {
                        var m = c[f];
                        o.layers.test(m.layers) && (g.viewport(G.copy(m.viewport)), p.setupLights(m), _t(o, e, m, l, h, u))
                    }
                } else V = null, _t(o, e, n, l, h, u)
            }
        }

        function _t(t, e, n, i, r, a) {
            if (t.onBeforeRender(F, e, n, i, r, a), p = M.get(e, V || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                var s = bt(n, e, r, t);
                g.setMaterial(r), z.geometry = null, z.program = null, z.wireframe = !1,
                    function (t, e) {
                        t.render((function (t) {
                            F.renderBufferImmediate(t, e)
                        }))
                    }(t, s)
            } else F.renderBufferDirect(n, e, i, r, t, a);
            t.onAfterRender(F, e, n, i, r, a), p = M.get(e, V || n)
        }

        function xt(t, e, n) {
            var i = y.get(t),
                r = p.state.lights,
                a = p.state.shadowsArray,
                s = r.state.version,
                o = w.getParameters(t, r.state, a, e, tt.numPlanes, tt.numIntersection, n),
                l = w.getProgramCacheKey(o),
                h = i.program,
                u = !0;
            if (void 0 === h) t.addEventListener("dispose", pt);
            else if (h.cacheKey !== l) ft(t);
            else if (i.lightsStateVersion !== s) i.lightsStateVersion = s, u = !1;
            else {
                if (void 0 !== o.shaderID) return;
                u = !1
            }
            u && (h = w.acquireProgram(o, l), i.program = h, i.uniforms = o.uniforms, i.outputEncoding = o.outputEncoding, t.program = h);
            var c = h.getAttributes();
            if (t.morphTargets) {
                t.numSupportedMorphTargets = 0;
                for (var f = 0; f < F.maxMorphTargets; f++) c["morphTarget" + f] >= 0 && t.numSupportedMorphTargets++
            }
            if (t.morphNormals) {
                t.numSupportedMorphNormals = 0;
                for (f = 0; f < F.maxMorphNormals; f++) c["morphNormal" + f] >= 0 && t.numSupportedMorphNormals++
            }
            var d = i.uniforms;
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = tt.numPlanes, i.numIntersection = tt.numIntersection, d.clippingPlanes = tt.uniform), i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.needsLights = function (t) {
                return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
            }(t), i.lightsStateVersion = s, i.needsLights && (d.ambientLightColor.value = r.state.ambient, d.lightProbe.value = r.state.probe, d.directionalLights.value = r.state.directional, d.directionalLightShadows.value = r.state.directionalShadow, d.spotLights.value = r.state.spot, d.spotLightShadows.value = r.state.spotShadow, d.rectAreaLights.value = r.state.rectArea, d.pointLights.value = r.state.point, d.pointLightShadows.value = r.state.pointShadow, d.hemisphereLights.value = r.state.hemi, d.directionalShadowMap.value = r.state.directionalShadowMap, d.directionalShadowMatrix.value = r.state.directionalShadowMatrix, d.spotShadowMap.value = r.state.spotShadowMap, d.spotShadowMatrix.value = r.state.spotShadowMatrix, d.pointShadowMap.value = r.state.pointShadowMap, d.pointShadowMatrix.value = r.state.pointShadowMatrix);
            var m = i.program.getUniforms(),
                g = xl.seqWithValue(m.seq, d);
            i.uniformsList = g
        }

        function bt(t, e, n, i) {
            _.resetTextureUnits();
            var r = e.fog,
                a = n.isMeshStandardMaterial ? e.environment : null,
                s = null === O ? F.outputEncoding : O.texture.encoding,
                o = y.get(n),
                l = p.state.lights;
            if (et && (nt || t !== U)) {
                var h = t === U && n.id === B;
                tt.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, o, h)
            }
            n.version === o.__version ? void 0 === o.program || n.fog && o.fog !== r || o.environment !== a || o.needsLights && o.lightsStateVersion !== l.state.version ? xt(n, e, i) : void 0 === o.numClippingPlanes || o.numClippingPlanes === tt.numPlanes && o.numIntersection === tt.numIntersection ? o.outputEncoding !== s && xt(n, e, i) : xt(n, e, i) : (xt(n, e, i), o.__version = n.version);
            var u, c, d = !1,
                v = !1,
                x = !1,
                b = o.program,
                E = b.getUniforms(),
                w = o.uniforms;
            if (g.useProgram(b.program) && (d = !0, v = !0, x = !0), n.id !== B && (B = n.id, v = !0), d || U !== t) {
                if (E.setValue(f, "projectionMatrix", t.projectionMatrix), m.logarithmicDepthBuffer && E.setValue(f, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), U !== t && (U = t, v = !0, x = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                    var D = E.map.cameraPosition;
                    void 0 !== D && D.setValue(f, rt.setFromMatrixPosition(t.matrixWorld))
                }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && E.setValue(f, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && E.setValue(f, "viewMatrix", t.matrixWorldInverse)
            }
            if (n.skinning) {
                E.setOptional(f, i, "bindMatrix"), E.setOptional(f, i, "bindMatrixInverse");
                var M = i.skeleton;
                if (M) {
                    var S = M.bones;
                    if (m.floatVertexTextures) {
                        if (void 0 === M.boneTexture) {
                            var T = Math.sqrt(4 * S.length);
                            T = br.ceilPowerOfTwo(T), T = Math.max(T, 4);
                            var A = new Float32Array(T * T * 4);
                            A.set(M.boneMatrices);
                            var C = new Ar(A, T, T, 1023, 1015);
                            M.boneMatrices = A, M.boneTexture = C, M.boneTextureSize = T
                        }
                        E.setValue(f, "boneTexture", M.boneTexture, _), E.setValue(f, "boneTextureSize", M.boneTextureSize)
                    } else E.setOptional(f, M, "boneMatrices")
                }
            }
            return (v || o.receiveShadow !== i.receiveShadow) && (o.receiveShadow = i.receiveShadow, E.setValue(f, "receiveShadow", i.receiveShadow)), v && (E.setValue(f, "toneMappingExposure", F.toneMappingExposure), E.setValue(f, "toneMappingWhitePoint", F.toneMappingWhitePoint), o.needsLights && (c = x, (u = w).ambientLightColor.needsUpdate = c, u.lightProbe.needsUpdate = c, u.directionalLights.needsUpdate = c, u.directionalLightShadows.needsUpdate = c, u.pointLights.needsUpdate = c, u.pointLightShadows.needsUpdate = c, u.spotLights.needsUpdate = c, u.spotLightShadows.needsUpdate = c, u.rectAreaLights.needsUpdate = c, u.hemisphereLights.needsUpdate = c), r && n.fog && function (t, e) {
                t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            }(w, r), n.isMeshBasicMaterial ? Et(w, n) : n.isMeshLambertMaterial ? (Et(w, n), function (t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
            }(w, n)) : n.isMeshToonMaterial ? (Et(w, n), function (t, e) {
                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.gradientMap && (t.gradientMap.value = e.gradientMap);
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(w, n)) : n.isMeshPhongMaterial ? (Et(w, n), function (t, e) {
                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(w, n)) : n.isMeshStandardMaterial ? (Et(w, n, a), n.isMeshPhysicalMaterial ? function (t, e, n) {
                wt(t, e, n), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
                e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate());
                t.transparency.value = e.transparency
            }(w, n, a) : wt(w, n, a)) : n.isMeshMatcapMaterial ? (Et(w, n), function (t, e) {
                e.matcap && (t.matcap.value = e.matcap);
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(w, n)) : n.isMeshDepthMaterial ? (Et(w, n), function (t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(w, n)) : n.isMeshDistanceMaterial ? (Et(w, n), function (t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
            }(w, n)) : n.isMeshNormalMaterial ? (Et(w, n), function (t, e) {
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(w, n)) : n.isLineBasicMaterial ? (function (t, e) {
                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
            }(w, n), n.isLineDashedMaterial && function (t, e) {
                t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
            }(w, n)) : n.isPointsMaterial ? function (t, e) {
                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * q, t.scale.value = .5 * X, e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                var n;
                e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
            }(w, n) : n.isSpriteMaterial ? function (t, e) {
                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                var n;
                e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
            }(w, n) : n.isShadowMaterial && (w.color.value.copy(n.color), w.opacity.value = n.opacity), void 0 !== w.ltc_1 && (w.ltc_1.value = ya.LTC_1), void 0 !== w.ltc_2 && (w.ltc_2.value = ya.LTC_2), xl.upload(f, o.uniformsList, w, _), n.isShaderMaterial && (n.uniformsNeedUpdate = !1)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (xl.upload(f, o.uniformsList, w, _), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && E.setValue(f, "center", i.center), E.setValue(f, "modelViewMatrix", i.modelViewMatrix), E.setValue(f, "normalMatrix", i.normalMatrix), E.setValue(f, "modelMatrix", i.matrixWorld), b
        }

        function Et(t, e, n) {
            t.opacity.value = e.opacity, e.color && t.diffuse.value.copy(e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap);
            var i, r, a = e.envMap || n;
            a && (t.envMap.value = a, t.flipEnvMap.value = a.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = y.get(a).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix)), e.aoMap ? r = e.aoMap : e.lightMap && (r = e.lightMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uv2Transform.value.copy(r.matrix))
        }

        function wt(t, e, n) {
            t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), (e.envMap || n) && (t.envMapIntensity.value = e.envMapIntensity)
        }
        gt.setAnimationLoop((function (t) {
            lt.isPresenting || mt && mt(t)
        })), "undefined" != typeof window && gt.setContext(window), this.setAnimationLoop = function (t) {
            mt = t, lt.setAnimationLoop(t), gt.start()
        }, this.render = function (t, e) {
            var n, i;
            if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), e && e.isCamera) {
                if (!L) {
                    z.geometry = null, z.program = null, z.wireframe = !1, B = -1, U = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), lt.enabled && lt.isPresenting && (e = lt.getCamera(e)), t.onBeforeRender(F, t, e, n || O), (p = M.get(t, e)).init(), it.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), Q.setFromProjectionMatrix(it), nt = this.localClippingEnabled, et = tt.init(this.clippingPlanes, nt, e), (c = D.get(t, e)).init(), vt(t, e, 0, F.sortObjects), c.finish(), !0 === F.sortObjects && c.sort(Y, Z), et && tt.beginShadows();
                    var r = p.state.shadowsArray;
                    ht.render(r, t, e), p.setupLights(e), et && tt.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), S.render(c, t, e, i);
                    var a = c.opaque,
                        s = c.transparent;
                    if (t.overrideMaterial) {
                        var o = t.overrideMaterial;
                        a.length && yt(a, t, e, o), s.length && yt(s, t, e, o)
                    } else a.length && yt(a, t, e), s.length && yt(s, t, e);
                    t.onAfterRender(F, t, e), null !== O && (_.updateRenderTargetMipmap(O), _.updateMultisampleRenderTarget(O)), g.buffers.depth.setTest(!0), g.buffers.depth.setMask(!0), g.buffers.color.setMask(!0), g.setPolygonOffset(!1), c = null, p = null
                }
            } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }, this.setFramebuffer = function (t) {
            R !== t && null === O && f.bindFramebuffer(f.FRAMEBUFFER, t), R = t
        }, this.getActiveCubeFace = function () {
            return I
        }, this.getActiveMipmapLevel = function () {
            return k
        }, this.getRenderTarget = function () {
            return O
        }, this.setRenderTarget = function (t, e, n) {
            O = t, I = e, k = n, t && void 0 === y.get(t).__webglFramebuffer && _.setupRenderTarget(t);
            var i = R,
                r = !1;
            if (t) {
                var a = y.get(t).__webglFramebuffer;
                t.isWebGLCubeRenderTarget ? (i = a[e || 0], r = !0) : i = t.isWebGLMultisampleRenderTarget ? y.get(t).__webglMultisampledFramebuffer : a, G.copy(t.viewport), H.copy(t.scissor), j = t.scissorTest
            } else G.copy(J).multiplyScalar(q).floor(), H.copy(K).multiplyScalar(q).floor(), j = $;
            if (N !== i && (f.bindFramebuffer(f.FRAMEBUFFER, i), N = i), g.viewport(G), g.scissor(H), g.setScissorTest(j), r) {
                var s = y.get(t.texture);
                f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_CUBE_MAP_POSITIVE_X + (e || 0), s.__webglTexture, n || 0)
            }
        }, this.readRenderTargetPixels = function (t, e, n, i, r, a, s) {
            if (t && t.isWebGLRenderTarget) {
                var o = y.get(t).__webglFramebuffer;
                if (t.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]), o) {
                    var l = !1;
                    o !== N && (f.bindFramebuffer(f.FRAMEBUFFER, o), l = !0);
                    try {
                        var h = t.texture,
                            u = h.format,
                            c = h.type;
                        if (1023 !== u && P.convert(u) !== f.getParameter(f.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(1009 === c || P.convert(c) === f.getParameter(f.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === c && (m.isWebGL2 || d.get("OES_texture_float") || d.get("WEBGL_color_buffer_float")) || 1016 === c && (m.isWebGL2 ? d.get("EXT_color_buffer_float") : d.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        f.checkFramebufferStatus(f.FRAMEBUFFER) === f.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && f.readPixels(e, n, i, r, P.convert(u), P.convert(c), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        l && f.bindFramebuffer(f.FRAMEBUFFER, N)
                    }
                }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }, this.copyFramebufferToTexture = function (t, e, n) {
            void 0 === n && (n = 0);
            var i = Math.pow(2, -n),
                r = Math.floor(e.image.width * i),
                a = Math.floor(e.image.height * i),
                s = P.convert(e.format);
            _.setTexture2D(e, 0), f.copyTexImage2D(f.TEXTURE_2D, n, s, t.x, t.y, r, a, 0), g.unbindTexture()
        }, this.copyTextureToTexture = function (t, e, n, i) {
            void 0 === i && (i = 0);
            var r = e.image.width,
                a = e.image.height,
                s = P.convert(n.format),
                o = P.convert(n.type);
            _.setTexture2D(n, 0), e.isDataTexture ? f.texSubImage2D(f.TEXTURE_2D, i, t.x, t.y, r, a, s, o, e.image.data) : e.isCompressedTexture ? f.compressedTexSubImage2D(f.TEXTURE_2D, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : f.texSubImage2D(f.TEXTURE_2D, i, t.x, t.y, s, o, e.image), 0 === i && n.generateMipmaps && f.generateMipmap(f.TEXTURE_2D), g.unbindTexture()
        }, this.initTexture = function (t) {
            _.setTexture2D(t, 0), g.unbindTexture()
        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }

    function ph(t, e, n, i, r, a) {
        ah.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
    }

    function fh(t) {
        return function (t) {
            if (Array.isArray(t)) return dh(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return dh(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dh(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function dh(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function mh(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function gh(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    ah.prototype = Object.assign(Object.create(Na.prototype), {
        constructor: ah,
        isCamera: !0,
        copy: function (t, e) {
            return Na.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
        },
        getWorldDirection: function (t) {
            void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new Lr), this.updateMatrixWorld(!0);
            var e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize()
        },
        updateMatrixWorld: function (t) {
            Na.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        updateWorldMatrix: function (t, e) {
            Na.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        }
    }), sh.prototype = Object.assign(Object.create(ah.prototype), {
        constructor: sh,
        isPerspectiveCamera: !0,
        copy: function (t, e) {
            return ah.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
        },
        setFocalLength: function (t) {
            var e = .5 * this.getFilmHeight() / t;
            this.fov = 2 * br.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
        },
        getFocalLength: function () {
            var t = Math.tan(.5 * br.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / t
        },
        getEffectiveFOV: function () {
            return 2 * br.RAD2DEG * Math.atan(Math.tan(.5 * br.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function () {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function () {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function (t, e, n, i, r, a) {
            this.aspect = t / e, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
        },
        clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function () {
            var t = this.near,
                e = t * Math.tan(.5 * br.DEG2RAD * this.fov) / this.zoom,
                n = 2 * e,
                i = this.aspect * n,
                r = -.5 * i,
                a = this.view;
            if (null !== this.view && this.view.enabled) {
                var s = a.fullWidth,
                    o = a.fullHeight;
                r += a.offsetX * i / s, e -= a.offsetY * n / o, i *= a.width / s, n *= a.height / o
            }
            var l = this.filmOffset;
            0 !== l && (r += t * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function (t) {
            var e = Na.prototype.toJSON.call(this, t);
            return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
        }
    }), oh.prototype = Object.assign(Object.create(sh.prototype), {
        constructor: oh,
        isArrayCamera: !0
    }), lh.prototype = Object.assign(Object.create(Na.prototype), {
        constructor: lh,
        isGroup: !0
    }), Object.assign(hh.prototype, {
        constructor: hh,
        getTargetRaySpace: function () {
            return null === this._targetRay && (this._targetRay = new lh, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay
        },
        getGripSpace: function () {
            return null === this._grip && (this._grip = new lh, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip
        },
        dispatchEvent: function (t) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), this
        },
        disconnect: function (t) {
            return this.dispatchEvent({
                type: "disconnected",
                data: t
            }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), this
        },
        update: function (t, e, n) {
            var i = null,
                r = null,
                a = this._targetRay,
                s = this._grip;
            return t && (null !== a && null !== (i = e.getPose(t.targetRaySpace, n)) && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale)), null !== s && t.gripSpace && null !== (r = e.getPose(t.gripSpace, n)) && (s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale))), null !== a && (a.visible = null !== i), null !== s && (s.visible = null !== r), this
        }
    }), Object.assign(uh.prototype, Er.prototype), ph.prototype = Object.assign(Object.create(ah.prototype), {
        constructor: ph,
        isOrthographicCamera: !0,
        copy: function (t, e) {
            return ah.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
        },
        setViewOffset: function (t, e, n, i, r, a) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
        },
        clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function () {
            var t = (this.right - this.left) / (2 * this.zoom),
                e = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                i = (this.top + this.bottom) / 2,
                r = n - t,
                a = n + t,
                s = i + e,
                o = i - e;
            if (null !== this.view && this.view.enabled) {
                var l = (this.right - this.left) / this.view.fullWidth / this.zoom,
                    h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                a = (r += l * this.view.offsetX) + l * this.view.width, o = (s -= h * this.view.offsetY) - h * this.view.height
            }
            this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function (t) {
            var e = Na.prototype.toJSON.call(this, t);
            return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
        }
    });
    var vh = g.bounds,
        yh = new(function () {
            function t() {
                var e = this;
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), gh(this, "run", (function (t) {
                    var n = t.current,
                        i = t.diff,
                        r = e.state,
                        a = [].concat(fh(uu.group.children), fh(uu.slides.children));
                    r.current = n, r.x += .5, a && a.forEach((function (t) {
                        t.material && (t.st ? t.onRaf(r.current, i, e.visible(t.bounds, n)) : t.onRaf(r.current))
                    })), uu.toggleSlides(r.current), e.renderer.render(e.scene, e.camera)
                })), gh(this, "resize", (function () {
                    var t = vh.ww,
                        n = vh.wh;
                    e.camera.updateProjectionMatrix(), e.renderer.setSize(t, n), uu.resize()
                })), this.scene = new Ba, this.camera = null, this.renderer = null, this.state = {
                    current: 0,
                    x: 0
                }
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function (t) {
                    if (!this.initial) {
                        this.initial = !0;
                        var e = vh.ww,
                            n = vh.wh;
                        this.camera = new sh(45, e / n, .1, 100), this.camera.position.z = 50, this.renderer = new ch({
                            alpha: !0,
                            antialias: !0
                        }), this.renderer.setPixelRatio(1), this.renderer.setSize(e, n), this.renderer.setClearColor(16777215, 0), this.renderer.domElement.classList.add("gl"), this.scene.add(uu.group), this.scene.add(uu.slides)
                    }
                    this.el = t, this.el.appendChild(this.renderer.domElement), this.addEvents()
                }
            }, {
                key: "addEvents",
                value: function () {
                    U.on("tick", this.run), U.on("resize:on-reset", this.resize)
                }
            }, {
                key: "visible",
                value: function (t) {
                    var e = t.start,
                        n = t.end,
                        i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state.current;
                    return i > e && i < n
                }
            }, {
                key: "removeEvents",
                value: function () {
                    U.off("tick", this.run), U.off("resize:on-reset", this.resize)
                }
            }, {
                key: "destroy",
                value: function () {
                    this.removeEvents(), this.renderer.domElement.remove(), uu.removePlanes()
                }
            }]) && mh(e.prototype, n), i && mh(e, i), t
        }());

    function _h(t) {
        return (_h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
            return typeof t
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function xh(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function bh(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Eh(t, e) {
        return (Eh = Object.setPrototypeOf || function (t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function wh(t) {
        var e = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function () {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function () {
            var n, i = Mh(t);
            if (e) {
                var r = Mh(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Dh(this, n)
        }
    }

    function Dh(t, e) {
        return !e || "object" !== _h(e) && "function" != typeof e ? function (t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function Mh(t) {
        return (Mh = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Sh = g.dom,
        Th = g.bounds,
        Ah = function (t) {
            ! function (t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Eh(t, e)
            }(a, t);
            var e, n, i, r = wh(a);

            function a() {
                return xh(this, a), r.apply(this, arguments)
            }
            return e = a, (n = [{
                key: "init",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    this.args = t, this.el = this.args.el, this.name = this.args.name, this.progress = {
                        x: 0,
                        y: 0
                    }, this.static = !1, this.out = !0, this.setBounds()
                }
            }, {
                key: "update",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Sh.body;
                    this.removed = !1, this.el = y('[data-gl-id="'.concat(this.name, '"]'), t), this.resize()
                }
            }, {
                key: "setBounds",
                value: function () {
                    var t = Th.ww,
                        e = Th.wh,
                        n = Th.hero,
                        i = x(this.el),
                        r = i.left,
                        a = i.top,
                        s = i.bottom,
                        o = i.width,
                        l = i.height;
                    this.bounds = {
                        left: r,
                        width: o,
                        height: l,
                        top: a,
                        start: a - e - 100,
                        end: s + 100,
                        min: r < t ? -t : 0,
                        max: r > t ? n.w + t : n.w
                    }, this.updateSize(), this.updateY(), this.updateX()
                }
            }, {
                key: "resize",
                value: function () {
                    !this.removed && this.setBounds()
                }
            }, {
                key: "calculateUnitSize",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.position.z,
                        e = yh.camera.fov * Math.PI / 180,
                        n = 2 * Math.tan(e / 2) * t,
                        i = n * yh.camera.aspect;
                    return {
                        width: i,
                        height: n
                    }
                }
            }, {
                key: "updateSize",
                value: function () {
                    this.camUnit = this.calculateUnitSize(yh.camera.position.z - this.position.z);
                    var t = Th.ww,
                        e = Th.wh,
                        n = this.bounds,
                        i = n.width / t,
                        r = n.height / e;
                    i && r && (this.scale.x = this.camUnit.width * i, this.scale.y = this.camUnit.height * r)
                }
            }, {
                key: "updateY",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        e = Th.wh,
                        n = this.bounds.top,
                        i = this.camUnit.height;
                    this.position.y = i / 2 - this.scale.y / 2, this.position.y -= (n - t) / e * i
                }
            }, {
                key: "updateX",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        e = Th.ww,
                        n = this.bounds,
                        i = n.left,
                        r = n.min,
                        a = n.max,
                        s = this.camUnit.width;
                    if (this.position.x = -s / 2 + this.scale.x / 2, this.slide) {
                        var o = t + yh.state.x,
                            l = vr.utils.wrap(r, a, o);
                        this.position.x += (i - l) / e * s
                    } else this.position.x += (i + t) / e * s
                }
            }, {
                key: "onRaf",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    !this.static && (this.slide ? this.updateX(t) : this.updateY(t))
                }
            }, {
                key: "destroy",
                value: function () {
                    this.parent && this.parent.remove(this), this.removed = !0, this.visible = this.static = !1
                }
            }]) && bh(e.prototype, n), i && bh(e, i), a
        }(Na);

    function Ch(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var Ph = g.bounds,
        Fh = g.dom,
        Lh = function t() {
            var e = this;
            ! function (t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), Ch(this, "render", (function () {
                e.renderer.render(e.scene, e.camera)
            })), Ch(this, "out", (function (t) {
                var n = t.done,
                    i = t.from,
                    r = e.mat.uniforms.uProgress;
                e.tl.clear().to(r, {
                    value: 1,
                    duration: 1,
                    ease: "power2.inOut",
                    onUpdate: function () {
                        return e.render()
                    }
                }, 0).add((function () {
                    i.remove(), n()
                })).play()
            })), Ch(this, "in", (function (t) {
                var n = t.done,
                    i = e.mat.uniforms,
                    r = i.uProgress,
                    a = i.uOut;
                e.tl.clear().set(a, {
                    value: !1
                }).to(r, {
                    value: 0,
                    duration: .85,
                    ease: "power3.inOut",
                    onUpdate: function () {
                        return e.render()
                    }
                }, 0).set(a, {
                    value: !0
                }).add((function () {
                    return n()
                })).play()
            })), Ch(this, "resize", (function () {
                var t = Ph.ww,
                    n = Ph.wh;
                e.camera.left = t / -2, e.camera.right = t / 2, e.camera.top = n / 2, e.camera.bottom = n / -2, e.camera.updateProjectionMatrix(), e.renderer.setSize(t, n), e.triangle.scale.set(t / 2, n / 2, 1)
            }));
            var n = Ph.ww,
                i = Ph.wh;
            this.renderer = new ch({
                alpha: !0,
                antialias: !0
            }), this.renderer.setPixelRatio(1), this.renderer.setSize(n, i), this.renderer.setClearColor(16777215, 0), this.scene = new Ba, this.camera = new ph(n / -2, n / 2, i / 2, i / -2, 1, 100), this.camera.lookAt(this.scene.position), this.camera.position.z = 1, this.renderer.domElement.classList.add("t"), Fh.body.appendChild(this.renderer.domElement), this.geo = new fs;
            var r = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
                a = new Float32Array([0, 0, 2, 0, 0, 2]);
            this.geo.setAttribute("uv", new Ya(a, 2)), this.geo.setAttribute("position", new Ya(r, 3)), this.texture = new Tr, this.texture.generateMipMaps = !1, this.texture.minFilter = 1006, this.texture.magFilter = 1006, this.texture.format = 1022;
            var s = new Image;
            s.src = "/2020/static/bg-gradient.png", s.decode().then((function () {
                e.texture.image = s, e.texture.needsUpdate = !0
            })), this.mat = new Es({
                fragmentShader: "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D uTexture;\n\nuniform float uProgress;\n\nuniform bool uOut;\n\nvec4 transparent = vec4(0., 0., 0., 0.);\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 uv = vUv;\n\n  vec4 tex = texture2D(uTexture, uv);\n\n  if (!uOut) uv.y = 1. - uv.y;\n  float t = step(uv.y, uProgress);\n  vec4 color = mix(transparent, tex, t);\n  \n  gl_FragColor = color;\n}  ",
                vertexShader: "precision highp float;\n#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(){\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",
                uniforms: {
                    uProgress: {
                        value: 0
                    },
                    uTexture: {
                        value: this.texture
                    },
                    uOut: {
                        value: !0
                    }
                }
            }), this.triangle = new so(this.geo, this.mat), this.triangle.scale.set(n / 2, i / 2, 1), this.triangle.frustumCulled = !1, this.scene.add(this.triangle), this.tl = vr.timeline({
                paused: !0
            }), U.on("transition:out", this.out), U.on("transition:in", this.in), U.on("resize:on-reset", this.resize)
        };

    function Rh(t) {
        return (Rh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
            return typeof t
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Ih(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function kh(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Oh(t, e, n) {
        return (Oh = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
            var i = function (t, e) {
                for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Vh(t)););
                return t
            }(t, e);
            if (i) {
                var r = Object.getOwnPropertyDescriptor(i, e);
                return r.get ? r.get.call(n) : r.value
            }
        })(t, e, n || t)
    }

    function Nh(t, e) {
        return (Nh = Object.setPrototypeOf || function (t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Bh(t) {
        var e = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function () {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function () {
            var n, i = Vh(t);
            if (e) {
                var r = Vh(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return zh(this, n)
        }
    }

    function zh(t, e) {
        return !e || "object" !== Rh(e) && "function" != typeof e ? Uh(t) : e
    }

    function Uh(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Vh(t) {
        return (Vh = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }

    function Gh(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var Hh = new gs(1, 1, 15, 1),
        jh = new Es({
            vertexShader: "precision highp float;\n#define GLSLIFY 1\n\nuniform float uProgress;\nuniform float uOffset;\nuniform float uVelo;\nuniform float uStrength;\n\n#define M_PI 3.1415926535897932384626433832795\n\nvarying vec2 vUv;\n\nvoid main(){\n  vec3 pos = position;\n  vec4 mvPosition = modelViewMatrix * vec4(pos, 1.);\n\n  float dist = mvPosition.x / uOffset;\n  mvPosition.z += sin(dist * M_PI + M_PI / 2.) * -uStrength * (1. + (uVelo * 1.5));\n\n  vUv = uv;\n  gl_Position = projectionMatrix * mvPosition;\n}",
            fragmentShader: "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D uTexture;\n\nuniform float uAlpha;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 uv = vUv;\n\n  vec4 texture = texture2D(uTexture, uv);\n  \n  gl_FragColor = texture * uAlpha;\n}"
        }),
        Wh = g.bounds,
        Xh = g.flags,
        qh = function (t) {
            ! function (t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Nh(t, e)
            }(a, t);
            var e, n, i, r = Bh(a);

            function a() {
                var t;
                Ih(this, a);
                for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                return Gh(Uh(t = r.call.apply(r, [this].concat(n))), "play", (function () {
                    t.visible = !0
                })), Gh(Uh(t), "pause", (function () {
                    t.visible = !1
                })), t
            }
            return e = a, (n = [{
                key: "init",
                value: function (t) {
                    var e = this;
                    if (Oh(Vh(a.prototype), "init", this).call(this, t), this.geometry = Hh, this.material = jh.clone(), this.texture = new Tr, this.texture.generateMipMaps = !1, this.texture.minFilter = 1006, this.texture.magFilter = 1006, this.texture.format = 1022, this.slide = !0, this.initial = !0, this.material.uniforms = {
                            uTime: {
                                value: 0
                            },
                            uTexture: {
                                value: this.texture
                            },
                            uVelo: {
                                value: 0
                            },
                            uStrength: {
                                value: 0
                            },
                            uProgress: {
                                value: 0
                            },
                            uAlpha: {
                                value: 1
                            },
                            uOffset: {
                                value: 0
                            }
                        }, this.setUnis(), Xh.isDesktop) this.vid = document.createElement("video"), this.vid.src = location.origin + this.el.dataset.vid, this.vid.muted = !0, this.vid.loop = !0, this.vid.currentTime = 1, this.vid.lastFrame = !1, this.vid.preload = !0, this.vid.play();
                    else {
                        var n = new Image;
                        n.src = this.el.dataset.img, n.decode().then((function () {
                            e.texture.image = n, e.texture.needsUpdate = !0
                        }))
                    }
                    this.mesh = new so(this.geometry, this.material), this.add(this.mesh), uu.slides.add(this), uu.planes[this.name] = this, this.onAdd()
                }
            }, {
                key: "onAdd",
                value: function () {
                    this.vid && this.vid.play(), U.on("intro:in", this.play), U.on("intro:out", this.pause)
                }
            }, {
                key: "setUnis",
                value: function () {
                    var t = this.material.uniforms,
                        e = t.uStrength,
                        n = t.uOffset;
                    e.value = Wh.ww / 100, n.value = this.camUnit.width
                }
            }, {
                key: "updateX",
                value: function (t) {
                    this.visible && this.material && (Oh(Vh(a.prototype), "updateX", this).call(this, t), this.material.uniforms.uVelo.value = vu.velo.diff, this.vid && this.updateVid())
                }
            }, {
                key: "updateVid",
                value: function () {
                    this.vid.readyState >= this.vid.HAVE_CURRENT_DATA && (this.vid.lastFrame ? this.vid.lastFrame = !1 : (this.vid.lastFrame = !0, this.initial && (this.initial = !1, this.texture.image = this.vid, uu.loaded.push(!0), 10 === uu.loaded.length && (Xh.loaded = !0, U.emit("gl:loaded"))), this.texture.needsUpdate = !0))
                }
            }, {
                key: "resize",
                value: function () {
                    Oh(Vh(a.prototype), "resize", this).call(this), this.setUnis()
                }
            }, {
                key: "destroy",
                value: function () {
                    Oh(Vh(a.prototype), "destroy", this).call(this), U.off("intro:in", this.play), U.off("intro:out", this.pause), this.vid && this.vid.pause()
                }
            }]) && kh(e.prototype, n), i && kh(e, i), a
        }(Ah);

    function Yh(t) {
        return (Yh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
            return typeof t
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Zh(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function Jh(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Kh(t, e, n) {
        return (Kh = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
            var i = function (t, e) {
                for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = eu(t)););
                return t
            }(t, e);
            if (i) {
                var r = Object.getOwnPropertyDescriptor(i, e);
                return r.get ? r.get.call(n) : r.value
            }
        })(t, e, n || t)
    }

    function $h(t, e) {
        return ($h = Object.setPrototypeOf || function (t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Qh(t) {
        var e = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function () {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function () {
            var n, i = eu(t);
            if (e) {
                var r = eu(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return tu(this, n)
        }
    }

    function tu(t, e) {
        return !e || "object" !== Yh(e) && "function" != typeof e ? function (t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function eu(t) {
        return (eu = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var nu = new gs(1, 1, 15, 1),
        iu = new Es({
            vertexShader: "precision mediump float;\n#define GLSLIFY 1\n\nuniform float uProgress;\nuniform float uVelo;\n\n#define M_PI 3.1415926535897932384626433832795\n\nvarying vec2 vUv;\n\nvoid main(){\n  vec3 pos = position;\n\n  pos.y += ((sin(uv.x * M_PI) * uVelo) * 0.35);\n\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n}",
            fragmentShader: "precision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D uTexture;\n\nuniform float uAlpha;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 uv = vUv;\n\n  vec4 texture = texture2D(uTexture, uv);\n  \n  gl_FragColor = texture;\n}"
        }),
        ru = function (t) {
            ! function (t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && $h(t, e)
            }(a, t);
            var e, n, i, r = Qh(a);

            function a() {
                return Zh(this, a), r.apply(this, arguments)
            }
            return e = a, (n = [{
                key: "init",
                value: function (t) {
                    Kh(eu(a.prototype), "init", this).call(this, t), this.geometry = nu, this.material = iu.clone(), this.texture = new Tr, this.texture.generateMipMaps = !1, this.texture.minFilter = 1006, this.texture.magFilter = 1006, this.texture.format = 1022, this.st = !0, this.animated = !1, this.initial = !0, this.material.uniforms = {
                        uTime: {
                            value: 0
                        },
                        uTexture: {
                            value: this.texture
                        },
                        uVelo: {
                            value: 0
                        },
                        uProgress: {
                            value: 0
                        },
                        uAlpha: {
                            value: 1
                        },
                        uOffset: {
                            value: this.camUnit.width
                        }
                    }, this.vid = document.createElement("video"), this.vid.src = location.origin + this.el.dataset.src, this.vid.muted = !0, this.vid.loop = !0, this.vid.currentTime = 1, this.vid.lastFrame = !1, this.vid.preload = !0, this.mesh = new so(this.geometry, this.material), this.mesh.renderOrder = 10, this.add(this.mesh), uu.group.add(this), uu.planes[this.name] = this
                }
            }, {
                key: "onRaf",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    !this.static && this.material && (this.updateY(t), this.material.uniforms.uVelo.value = e, this.updateVid(), n ? this.vid.play() : this.vid.pause())
                }
            }, {
                key: "updateVid",
                value: function () {
                    this.vid.readyState >= this.vid.HAVE_ENOUGH_DATA && (this.vid.lastFrame ? this.vid.lastFrame = !1 : (this.vid.lastFrame = !0, this.initial && (this.initial = !1, this.texture.image = this.vid), this.texture.needsUpdate = !0))
                }
            }, {
                key: "destroy",
                value: function () {
                    Kh(eu(a.prototype), "destroy", this).call(this)
                }
            }]) && Jh(e.prototype, n), i && Jh(e, i), a
        }(Ah);

    function au(t) {
        return function (t) {
            if (Array.isArray(t)) return su(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return su(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return su(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function su(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function ou(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    var lu = g.bounds,
        hu = g.flags,
        uu = new(function () {
            function t() {
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.planes = {}, this.slides = new lh, this.group = new lh, this.hero = y(".js-hero-inner"), this.heroVids = _(".js-hero-vid"), this.heroContent = y(".js-hero-content"), this.sv = !1, this.loaded = []
            }
            var e, n, r;
            return e = t, (n = [{
                key: "fromDom",
                value: function (t, e) {
                    var n = t.dataset.glId,
                        r = t.dataset.glComponent,
                        a = this.planes[n];
                    if (a && !a.keep) this.add(a, e);
                    else if (!a) {
                        if (hu.isDevice && "PlaneVideo" === r) return;
                        (new i[r]).init({
                            el: t,
                            name: n
                        })
                    }
                }
            }, {
                key: "addPlanes",
                value: function (t) {
                    var e = this,
                        n = t.el,
                        i = _("[data-gl-id]", n);
                    i && i.forEach((function (t) {
                        return e.fromDom(t, n)
                    }))
                }
            }, {
                key: "add",
                value: function (t, e) {
                    t.visible || (t.name.includes("slide") ? this.slides.add(t) : this.group.add(t), t.visible = !0, t.material.uniforms.uAlpha.value = 1, t.update(e), t.onAdd && t.onAdd())
                }
            }, {
                key: "resize",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                    for (var e in this.planes) this.planes[e].resize(t)
                }
            }, {
                key: "setStatic",
                value: function () {
                    [].concat(au(this.group.children), au(this.slides.children)).forEach((function (t) {
                        return t.static = !0
                    }))
                }
            }, {
                key: "removePlanes",
                value: function () {
                    for (var t in this.planes) this.remove(this.planes[t])
                }
            }, {
                key: "remove",
                value: function (t) {
                    t.destroy()
                }
            }, {
                key: "toggleSlides",
                value: function (t) {
                    var e = lu.hero.h;
                    t > e && !this.sv ? (U.emit("intro:out"), vr.set(this.heroContent, {
                        autoAlpha: 0
                    }), this.sv = !0) : t <= e && this.sv && (this.sv = !1, vr.set(this.heroContent, {
                        autoAlpha: 1
                    }), U.emit("intro:in"))
                }
            }]) && ou(e.prototype, n), r && ou(e, r), t
        }());

    function cu(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function pu(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var fu = g.dom,
        du = g.flags,
        mu = du.isDevice,
        gu = du.isDesktop,
        vu = new(function () {
            function t() {
                var e = this;
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), pu(this, "tick", (function () {
                    mu ? (e.target = fu.scroll.scrollTop, U.emit("tick", {
                        target: e.target,
                        current: e.target,
                        diff: 0
                    })) : (e.last = e.current, e.current = v(e.current, e.target, e.ease), e.rounded = Math.round(100 * e.current) / 100, e.diff = 5e-4 * (e.target - e.current), uu.sv || (e.velo.current = v(e.velo.current, e.rounded, e.velo.ease), e.velo.diff = vr.utils.clamp(0, .75, 5e-4 * (e.rounded - e.velo.current))), U.emit("tick", {
                        target: e.target,
                        current: e.rounded,
                        diff: e.diff,
                        still: Math.abs(e.current - e.last) <= .001
                    }))
                })), pu(this, "onScroll", (function (t) {
                    var n = t.y;
                    du.locked || (e.target += n, e.clamp())
                })), pu(this, "reset", (function () {
                    e.target = e.current = e.rounded = 0
                })), pu(this, "resize", (function () {
                    e.clamp(), e.rounded = e.current = e.target
                })), this.target = 0, this.current = 0, this.rounded = 0, this.velo = {
                    current: 0,
                    diff: 0,
                    ease: .075
                }, this.ease = .115, this.init()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "clamp",
                value: function () {
                    this.target = vr.utils.clamp(0, g.bounds.scroll, this.target)
                }
            }, {
                key: "init",
                value: function () {
                    vr.ticker.fps(-1), vr.ticker.add(this.tick), gu && (U.on("scroll", this.onScroll), U.on("resize:on-reset", this.resize), U.on("scroll:on-reset", this.reset))
                }
            }]) && cu(e.prototype, n), i && cu(e, i), t
        }()),
        yu = n(2),
        _u = n.n(yu);

    function xu(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    var bu = g.dom,
        Eu = g.bounds,
        wu = g.flags.isDevice;
    new(function () {
        function t() {
            var e, n, i, r = this;
            ! function (t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), i = function () {
                var t = window.innerWidth;
                wu && t === Eu.ww || (Eu.ww = t, Eu.wh = window.innerHeight, r.setOrientation(bu, Eu), r.setVh(), U.emit("resize"), wu && U.emit("resize:on-reset"))
            }, (n = "resize") in (e = this) ? Object.defineProperty(e, n, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[n] = i, this.setOrientation(bu, Eu), this.setVh(), U.on("resize", window, _u()(this.resize, 200)), U.on("orientationchange", window, this.resize)
        }
        var e, n, i;
        return e = t, (n = [{
            key: "setOrientation",
            value: function (t, e) {
                var n = t.body,
                    i = e.wh;
                e.ww < i ? n.classList.add("is-portrait") : n.classList.remove("is-portrait")
            }
        }, {
            key: "setVh",
            value: function () {
                bu.body.style.setProperty("--vh", "".concat(.01 * Eu.wh, "px"))
            }
        }]) && xu(e.prototype, n), i && xu(e, i), t
    }());

    function Du(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Mu(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var Su = g.flags,
        Tu = Su.isDevice;
    new(function () {
        function t() {
            var e = this;
            ! function (t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), Mu(this, "onMove", (function (t) {
                if (Su.dragging) {
                    var n = e.getPos(t),
                        i = n.x,
                        r = n.y,
                        a = n.target;
                    U.emit("mousemove", {
                        x: i,
                        y: r,
                        target: a,
                        e: t
                    })
                }
            })), Mu(this, "onDown", (function (t) {
                if (3 !== t.which) {
                    var n = e.getPos(t),
                        i = n.x,
                        r = n.y,
                        a = n.target;
                    e.on = i, U.emit("mousedown", {
                        x: i,
                        y: r,
                        target: a
                    })
                }
            })), Mu(this, "onUp", (function (t) {
                var n = e.getPos(t),
                    i = n.x,
                    r = n.target;
                e.off = i;
                var a = Math.abs(e.off - e.on) < 10;
                U.emit("mouseup", {
                    x: i,
                    target: r,
                    click: a
                })
            })), this.on = 0, this.off = 0, this.events = {
                move: Tu ? "touchmove" : "mousemove",
                down: Tu ? "touchstart" : "mousedown",
                up: Tu ? "touchend" : "mouseup"
            }, this.addEvents()
        }
        var e, n, i;
        return e = t, (n = [{
            key: "addEvents",
            value: function () {
                var t = this.events,
                    e = t.move,
                    n = t.down,
                    i = t.up;
                window.addEventListener(e, this.onMove, {
                    passive: !1
                }), window.addEventListener(n, this.onDown, {
                    passive: !1
                }), window.addEventListener(i, this.onUp, {
                    passive: !1
                }), U.on("click", window, (function (t) {
                    return U.emit("click", t)
                }))
            }
        }, {
            key: "getPos",
            value: function (t) {
                return {
                    x: t.changedTouches ? t.changedTouches[0].clientX : t.clientX,
                    y: t.changedTouches ? t.changedTouches[0].clientY : t.clientY,
                    target: t.target
                }
            }
        }]) && Du(e.prototype, n), i && Du(e, i), t
    }());

    function Au(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    var Cu = new(function () {
        function t() {
            ! function (t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.isRunning = !1, this.el = y(".js-pe")
        }
        var e, n, i;
        return e = t, (n = [{
            key: "run",
            value: function () {
                var t = this;
                clearTimeout(this.timer), this.timer = setTimeout((function () {
                    t.isRunning = !1, t.togglePointers("none")
                }), 300), this.isRunning || (this.isRunning = !0, this.togglePointers("all"))
            }
        }, {
            key: "togglePointers",
            value: function (t) {
                this.el.style.pointerEvents = t
            }
        }]) && Au(e.prototype, n), i && Au(e, i), t
    }());

    function Pu(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var Fu, Lu, Ru, Iu, ku, Ou = g.dom,
        Nu = g.flags,
        Bu = new function t() {
            var e = this;
            ! function (t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), Pu(this, "handle", (function (t) {
                t.forEach((function (t) {
                    var n = e.cache.find((function (e) {
                        var n = e.el;
                        return t.target === n
                    }));
                    n && (t.isIntersecting ? (n.enter && n.enter(n, t.target), n.intersecting = !0) : (n.leave && n.leave(n, t.target), n.intersecting = !1))
                }))
            })), Pu(this, "destroy", (function () {
                e.cache.forEach((function (t, n) {
                    e.inst.unobserve(t.el), t.ani && t.ani.destroy(), e.cache.splice(0, n)
                }))
            })), this.inst = new IntersectionObserver(this.handle, {
                root: Nu.isDesktop ? null : Ou.scroll
            }), U.on("on-leave-completed", this.destroy), this.cache = []
        },
        zu = n(0),
        Uu = n.n(zu),
        Vu = function () {
            return "undefined" != typeof window
        },
        Gu = function () {
            return Fu || Vu() && (Fu = window.gsap) && Fu.registerPlugin && Fu
        },
        Hu = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
        ju = {
            rect: ["width", "height"],
            circle: ["r", "r"],
            ellipse: ["rx", "ry"],
            line: ["x2", "y2"]
        },
        Wu = function (t) {
            return Math.round(1e4 * t) / 1e4
        },
        Xu = function (t) {
            return parseFloat(t || 0)
        },
        qu = function (t, e) {
            return Xu(t.getAttribute(e))
        },
        Yu = Math.sqrt,
        Zu = function (t, e, n, i, r, a) {
            return Yu(Math.pow((Xu(n) - Xu(t)) * r, 2) + Math.pow((Xu(i) - Xu(e)) * a, 2))
        },
        Ju = function (t) {
            return console.warn(t)
        },
        Ku = function (t) {
            return "non-scaling-stroke" === t.getAttribute("vector-effect")
        },
        $u = function (t) {
            if (!(t = Lu(t)[0])) return 0;
            var e, n, i, r, a, s, o, l = t.tagName.toLowerCase(),
                h = t.style,
                u = 1,
                c = 1;
            Ku(t) && (c = t.getScreenCTM(), u = Yu(c.a * c.a + c.b * c.b), c = Yu(c.d * c.d + c.c * c.c));
            try {
                n = t.getBBox()
            } catch (t) {
                Ju("Some browsers won't measure invisible elements (like display:none or masks inside defs).")
            }
            var p = n || {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                f = p.x,
                d = p.y,
                m = p.width,
                g = p.height;
            if (n && (m || g) || !ju[l] || (m = qu(t, ju[l][0]), g = qu(t, ju[l][1]), "rect" !== l && "line" !== l && (m *= 2, g *= 2), "line" === l && (f = qu(t, "x1"), d = qu(t, "y1"), m = Math.abs(m - f), g = Math.abs(g - d))), "path" === l) r = h.strokeDasharray, h.strokeDasharray = "none", e = t.getTotalLength() || 0, u !== c && Ju("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled."), e *= (u + c) / 2, h.strokeDasharray = r;
            else if ("rect" === l) e = 2 * m * u + 2 * g * c;
            else if ("line" === l) e = Zu(f, d, f + m, d + g, u, c);
            else if ("polyline" === l || "polygon" === l)
                for (i = t.getAttribute("points").match(Hu) || [], "polygon" === l && i.push(i[0], i[1]), e = 0, a = 2; a < i.length; a += 2) e += Zu(i[a - 2], i[a - 1], i[a], i[a + 1], u, c) || 0;
            else "circle" !== l && "ellipse" !== l || (s = m / 2 * u, o = g / 2 * c, e = Math.PI * (3 * (s + o) - Yu((3 * s + o) * (s + 3 * o))));
            return e || 0
        },
        Qu = function (t, e) {
            if (!(t = Lu(t)[0])) return [0, 0];
            e || (e = $u(t) + 1);
            var n = Ru.getComputedStyle(t),
                i = n.strokeDasharray || "",
                r = Xu(n.strokeDashoffset),
                a = i.indexOf(",");
            return a < 0 && (a = i.indexOf(" ")), (i = a < 0 ? e : Xu(i.substr(0, a)) || 1e-5) > e && (i = e), [Math.max(0, -r), Math.max(0, i - r)]
        },
        tc = function () {
            Vu() && (document, Ru = window, ku = Fu = Gu(), Lu = Fu.utils.toArray, Iu = -1 !== ((Ru.navigator || {}).userAgent || "").indexOf("Edge"))
        },
        ec = {
            version: "3.2.6",
            name: "drawSVG",
            register: function (t) {
                Fu = t, tc()
            },
            init: function (t, e, n, i, r) {
                if (!t.getBBox) return !1;
                ku || tc();
                var a, s, o, l, h = $u(t) + 1;
                return this._style = t.style, this._target = t, e + "" == "true" ? e = "0 100%" : e ? -1 === (e + "").indexOf(" ") && (e = "0 " + e) : e = "0 0", s = function (t, e, n) {
                    var i, r, a = t.indexOf(" ");
                    return a < 0 ? (i = void 0 !== n ? n + "" : t, r = t) : (i = t.substr(0, a), r = t.substr(a + 1)), (i = ~i.indexOf("%") ? Xu(i) / 100 * e : Xu(i)) > (r = ~r.indexOf("%") ? Xu(r) / 100 * e : Xu(r)) ? [r, i] : [i, r]
                }(e, h, (a = Qu(t, h))[0]), this._length = Wu(h + 10), 0 === a[0] && 0 === s[0] ? (o = Math.max(1e-5, s[1] - h), this._dash = Wu(h + o), this._offset = Wu(h - a[1] + o), this._offsetPT = this.add(this, "_offset", this._offset, Wu(h - s[1] + o))) : (this._dash = Wu(a[1] - a[0]) || 1e-6, this._offset = Wu(-a[0]), this._dashPT = this.add(this, "_dash", this._dash, Wu(s[1] - s[0]) || 1e-5), this._offsetPT = this.add(this, "_offset", this._offset, Wu(-s[0]))), Iu && (l = Ru.getComputedStyle(t)).strokeLinecap !== l.strokeLinejoin && (s = Xu(l.strokeMiterlimit), this.add(t.style, "strokeMiterlimit", s, s + .01)), this._live = Ku(t) || ~(e + "").indexOf("live"), this._props.push("drawSVG"), 1
            },
            render: function (t, e) {
                var n, i, r, a, s = e._pt,
                    o = e._style;
                if (s) {
                    for (e._live && (n = $u(e._target) + 11) !== e._length && (i = n / e._length, e._length = n, e._offsetPT.s *= i, e._offsetPT.c *= i, e._dashPT ? (e._dashPT.s *= i, e._dashPT.c *= i) : e._dash *= i); s;) s.r(t, s.d), s = s._next;
                    r = e._dash, a = e._offset, n = e._length, o.strokeDashoffset = e._offset, 1 !== t && t ? o.strokeDasharray = r + "px," + n + "px" : (r - a < .001 && n - r <= 10 && (o.strokeDashoffset = a + 1), o.strokeDasharray = a < .001 && n - r <= 10 ? "none" : a === r ? "0px, 999999px" : r + "px," + n + "px")
                }
            },
            getLength: $u,
            getPosition: Qu
        };

    function nc(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function ic(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    Gu() && Fu.registerPlugin(ec), vr.registerPlugin(ec);
    var rc = g.flags,
        ac = function () {
            function t() {
                var e = this;
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), ic(this, "run", (function () {
                    var t = rc.isDevice,
                        n = rc.loaded;
                    !e.home || t || n ? e.go() : U.on("gl:loaded", e.go)
                })), ic(this, "go", (function () {
                    e.tl.pause(), e.tl.tweenTo("end"), e.clock.loop = !1
                })), this.el = y(".js-mask"), this.ui = {
                    bg: y(".js-mask-bg"),
                    circle: y(".js-mask-circle"),
                    outline: y(".js-mask-outline"),
                    clock: y(".js-mask-clock")
                }, this.home = y(".js-h-circle"), this.init()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function () {
                    this.createClock(), this.prepare(), this.addEvents()
                }
            }, {
                key: "addEvents",
                value: function () {
                    U.on("loaded", this.run)
                }
            }, {
                key: "createClock",
                value: function () {
                    var t = this.ui.clock;
                    this.clock = Uu.a.loadAnimation({
                        container: t,
                        renderer: "svg",
                        loop: !0,
                        autoplay: !1,
                        path: "/data.json"
                    }), this.clock.setSubframe(!1), this.clock.setSpeed(1.25)
                }
            }, {
                key: "prepare",
                value: function () {
                    var t, e = this;
                    this.home && (t = x(this.home).bottom);
                    var n = this.ui,
                        i = n.circle,
                        r = n.bg,
                        a = n.outline;
                    this.tl = vr.timeline({
                        paused: !0,
                        immediateRender: !0,
                        onStart: function () {
                            e.clock.play()
                        },
                        onComplete: function () {
                            e.destroy(), e.el.innerHTML = "", g.flags.locked = !1
                        }
                    }).addLabel("start"), this.home ? this.tl.set([a, ".js-h-progress"], {
                        alpha: vr.utils.wrap([1, 0])
                    }) : this.tl.set(a, {
                        alpha: 1
                    }), this.tl.from(a, {
                        drawSVG: 0,
                        duration: 1.75,
                        ease: "power2.inOut"
                    }).addLabel("loaded"), this.home ? this.tl.to(i, {
                        y: t - x(i).bottom,
                        scale: .75,
                        duration: 2,
                        ease: "power2.inOut"
                    }).to(r, {
                        alpha: 0,
                        duration: .95,
                        ease: "power1.inOut"
                    }, "-=0.95").to([i, ".js-h-progress"], {
                        alpha: vr.utils.wrap([0, 1]),
                        duration: .15,
                        ease: "linear"
                    }) : this.tl.to(this.el, {
                        alpha: 0,
                        duration: .85,
                        ease: "power1.inOut"
                    }), this.tl.addLabel("end"), setTimeout((function () {
                        e.tl.tweenTo("loaded")
                    }), 1e3)
                }
            }, {
                key: "removeEvents",
                value: function () {
                    U.off("loaded", this.run)
                }
            }, {
                key: "destroy",
                value: function () {
                    this.removeEvents(), this.clock.destroy(), this.tl.kill(), this.ui = null
                }
            }]) && nc(e.prototype, n), i && nc(e, i), t
        }();

    function sc(t) {
        return function (t) {
            if (Array.isArray(t)) return oc(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return oc(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return oc(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function oc(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function lc(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function hc(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function uc(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var cc = g.flags,
        pc = function () {
            function t() {
                var e = this,
                    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _("[data-smooth-item]");
                lc(this, t), uc(this, "run", (function (t) {
                    var n = t.current;
                    e.current = n, !e.resizing && e.transformSections()
                })), uc(this, "resize", (function () {
                    e.resizing = !0, e.getSections(), U.emit("resize:on-reset"), e.transformSections(), e.resizing = !1
                })), this.elems = n, this.current = 0, this.last = null, this.resizing = !1, this.sections = null, this.init()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function () {
                    this.getSections(), this.addEvents()
                }
            }, {
                key: "addEvents",
                value: function () {
                    U.on("tick", this.run), U.on("resize", this.resize)
                }
            }, {
                key: "update",
                value: function (t) {
                    this.elems = t, this.getSections()
                }
            }, {
                key: "getSections",
                value: function () {
                    if (this.elems) {
                        var t = g.bounds,
                            e = this.elems.length - 1;
                        this.sections = sc(this.elems).map((function (n, i) {
                            n.style.transform = "translate3d(0, 0, 0)";
                            var r = x(n),
                                a = r.top,
                                s = r.bottom;
                            return i === e && (t.scroll = s - t.wh), {
                                el: n,
                                start: a - t.wh,
                                end: s,
                                out: !0
                            }
                        }))
                    }
                }
            }, {
                key: "transformSections",
                value: function () {
                    var t = this;
                    cc.locked || this.sections.length > 0 && this.sections.forEach((function (e) {
                        t.visible(e) || t.resizing ? (e.out && (e.out = !1), t.transform(e.el)) : e.out || (e.out = !0, t.transform(e.el))
                    }))
                }
            }, {
                key: "transform",
                value: function (t) {
                    t.style.transform = "translate3d(0, ".concat(-this.current, "px, 0)")
                }
            }, {
                key: "visible",
                value: function (t) {
                    var e = t.start,
                        n = t.end;
                    return this.current > e && this.current < n
                }
            }, {
                key: "removeEvents",
                value: function () {
                    U.off("tick", this.run), U.off("resize", this.resize)
                }
            }, {
                key: "destroy",
                value: function () {
                    this.removeEvents(), this.sections = this.elems = null, U.emit("scroll:on-reset")
                }
            }]) && hc(e.prototype, n), i && hc(e, i), t
        }(),
        fc = n(3),
        dc = n.n(fc);

    function mc(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    new(function () {
        function t() {
            var e, n, i, r = this;
            ! function (t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), i = function (t) {
                for (var e = function (e) {
                        var n = t[e];
                        if (n.isIntersecting) {
                            var i = r.cache.find((function (t) {
                                return t.el === n.target
                            }));
                            i.intersecting = !0, i.tl.play(), r.observer.unobserve(n.target)
                        }
                    }, n = 0; n < t.length; n++) e(n)
            }, (n = "handle") in (e = this) ? Object.defineProperty(e, n, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[n] = i, this.el = g.dom.body, this.cache = null, this.observer = new IntersectionObserver(this.handle, {
                root: null,
                rootMargin: "0px 0px 10% 0px",
                threshold: [0, 0]
            })
        }
        var e, n, i;
        return e = t, (n = [{
            key: "update",
            value: function (t) {
                this.getElems(t), this.observe()
            }
        }, {
            key: "getElems",
            value: function (t) {
                var e = this;
                this.cache = null, this.cache = [];
                var n = _("[data-scroll]", t);
                n && n.forEach((function (t) {
                    t.getBoundingClientRect().top < g.bounds.wh || e.cache.push({
                        el: t,
                        intersecting: !1,
                        tl: e.getTimelines(t, t.dataset.scroll)
                    })
                }))
            }
        }, {
            key: "getTimelines",
            value: function (t, e) {
                var n = vr.timeline({
                    paused: !0,
                    immediateRender: !0
                });
                if ("words" === e) {
                    var i = new dc.a(t, {
                        type: "lines, words"
                    });
                    n.set(i.lines, {
                        overflow: "hidden"
                    }).from(i.words, {
                        yPercent: 100,
                        duration: 1.75,
                        stagger: .1,
                        ease: "expo"
                    }, 0)
                }
                return n.progress(1).progress(0), n
            }
        }, {
            key: "observe",
            value: function () {
                var t = this;
                this.cache.forEach((function (e) {
                    return t.observer.observe(e.el)
                }))
            }
        }, {
            key: "clean",
            value: function () {
                var t = this;
                this.cache.forEach((function (e) {
                    return t.observer.unobserve(e.el)
                }))
            }
        }, {
            key: "destroy",
            value: function () {
                this.observer.disconnect(), this.observer = null, this.cache = null
            }
        }]) && mc(e.prototype, n), i && mc(e, i), t
    }());

    function gc(t) {
        return function (t) {
            if (Array.isArray(t)) return vc(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return vc(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return vc(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function vc(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function yc(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function _c(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
//    var xc = g.flags,
//        bc = function () {
//            function t() {
//                var e = this;
//                ! function (t, e) {
//                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
//                }(this, t), _c(this, "ui", {}), _c(this, "run", (function () {
//                    var t = e.state,
//                        n = t.target - t.current;
//                    !t.dragging && Math.abs(n) <= .001 || (t.current += n * e.opts.ease, t.rounded = Math.round(100 * t.current) / 100, t.progress = t.rounded / t.max, !t.resizing && e.transform())
//                })), _c(this, "down", (function (t) {
//                    var n = t.x,
//                        i = t.y;
//                    if (t.target.closest(".js-pricing-draggable")) {
//                        var r = e.state;
//                        xc.dragging = !0, r.dragging = !0, r.cancel.x = n, r.cancel.y = i, r.on = r.target + n * e.opts.speed, !e.initial && e.removeCTA()
//                    }
//                })), _c(this, "move", (function (t) {
//                    var n = t.x,
//                        i = t.y,
//                        r = t.e,
//                        a = e.state;
//                    if (a.dragging) {
//                        var s = a.cancel;
//                        Math.abs(n - s.x) > Math.abs(i - s.y) && r.cancelable && (r.preventDefault(), r.stopPropagation()), a.target = a.on - n * e.opts.speed, e.clamp()
//                    }
//                })), _c(this, "up", (function () {
//                    xc.dragging = !1, e.state.dragging = !1
//                })), _c(this, "click", (function (t) {
//                    var n = t.target.closest(".js-pricing-bullet");
//                    if (n) {
//                        var i = e.state;
//                        i.target = i.snap[e.ui.bullets.indexOf(n)]
//                    }
//                })), _c(this, "resize", (function () {
//                    var t = e.state;
//                    t.resizing = !0, e.setBounds(), e.setScale(), e.clamp(), t.rounded = t.current = t.target, e.transform(), t.resizing = !1
//                })), this.el = y(".js-pricing"), this.ui.container = y(".js-pricing-slides"), this.ui.slides = gc(_(".js-pricing-slide")), this.ui.bullets = gc(_(".js-pricing-bullet")), this.ui.handle = y(".js-pricing-handle"), this.state = {
//                    target: 0,
//                    current: 0,
//                    rounded: 0,
//                    scale: 0,
//                    on: 0,
//                    max: 0,
//                    cancel: {
//                        x: 0,
//                        y: 0
//                    },
//                    dragging: !1,
//                    resizing: !1,
//                    snap: null
//                }, this.opts = {
//                    speed: 2,
//                    ease: .085
//                }, this.init()
//            }
//            var e, n, i;
//            return e = t, (n = [{
//                key: "init",
//                value: function () {
//                    this.setBounds(), this.addEvents()
//                }
//            }, {
//                key: "addEvents",
//                value: function () {
//                    U.on("tick", this.run), U.on("mousedown", this.down), U.on("mouseup", this.up), U.on("mousemove", this.move), U.on("click", this.click), U.on("resize", this.resize)
//                }
//            }, {
//                key: "setBounds",
//                value: function () {
//                    var t = this,
//                        e = this.ui,
//                        n = e.slides,
//                        i = e.container,
//                        r = g.bounds.ww;
//                    i.style.transform = "translate3d(0, 0, 0)";
//                    var a = r - x(i).right;
//                    this.state.max = x(n[n.length - 1]).right + a - r, this.state.snap = n.map((function (e, i) {
//                        return t.state.max / (n.length - 1) * i
//                    })), this.setScale()
//                }
//            }, {
//                key: "setScale",
//                value: function () {
//                    var t = this.ui.bullets,
//                        e = this.state,
//                        n = x(t[2]).left - x(t[0]).left;
//                    e.scale = e.max / n
//                }
//            }, {
//                key: "transform",
//                value: function () {
//                    var t = this.ui,
//                        e = t.container,
//                        n = t.handle,
//                        i = this.state,
//                        r = i.rounded,
//                        a = i.scale;
//                    e.style.transform = "translate3d(".concat(-r, "px, 0, 0)"), n.style.transform = "translate3d(".concat(r / a, "px, 0, 0)")
//                }
//            }, {
//                key: "removeCTA",
//                value: function () {
//                    this.initial = !0;
//                    var t = y(".js-btn-next", this.el);
//                    vr.to(t, {
//                        alpha: 0,
//                        duration: .35,
//                        ease: "power1",
//                        onComplete: function () {
//                            return t.remove()
//                        }
//                    })
//                }
//            }, {
//                key: "clamp",
//                value: function () {
//                    var t = this.state;
//                    t.target = vr.utils.clamp(0, t.max, t.target)
//                }
//            }, {
//                key: "removeEvents",
//                value: function () {
//                    U.off("tick", this.run), U.off("mousedown", this.down), U.off("mouseup", this.up), U.off("mousemove", this.move), U.off("resize", this.resize), U.off("click", this.click)
//                }
//            }, {
//                key: "destroy",
//                value: function () {
//                    this.removeEvents(), this.state = null, this.opts = null, this.ui = null
//                }
//            }]) && yc(e.prototype, n), i && yc(e, i), t
//        }();

    function Ec(t) {
        return function (t) {
            if (Array.isArray(t)) return wc(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return wc(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return wc(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function wc(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function Dc(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function Mc(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Sc(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var Tc = g.bounds,
        Ac = function () {
            function t() {
                var e = this,
                    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _("[data-stick]");
                Dc(this, t), Sc(this, "run", (function (t) {
                    var n = t.current;
                    e.current = n, !e.resizing && e.transformElems(n)
                })), Sc(this, "resize", (function () {
                    e.resizing = !0, e.cache = null, e.getCache(), e.transformElems(), e.resizing = !1
                })), this.elems = Ec(n), this.cache = null, this.resizing = !1, this.init()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function () {
                    this.getCache(), this.addEvents()
                }
            }, {
                key: "addEvents",
                value: function () {
                    U.on("tick", this.run), U.on("resize:on-reset", this.resize)
                }
            }, {
                key: "transformElems",
                value: function () {
                    var t = this,
                        e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.current;
                    this.cache && this.cache.forEach((function (n) {
                        var i = t.visible(n, e),
                            r = i.visible,
                            a = i.progress;
                        r || t.resizing ? (n.out && (n.out = !1), t.transform(n, e, a)) : n.out || (n.out = !0, t.transform(n, e, a))
                    }))
                }
            }, {
                key: "transform",
                value: function (t, e, n) {
                    var i = t.els.node,
                        r = t.bounds,
                        a = r.start,
                        s = r.max,
                        o = r.min,
                        l = t.tl,
                        h = e - a,
                        u = vr.utils.clamp(o, s, h);
                    l && n && l.progress(n), i.style.transform = "translate3d(0, ".concat(u, "px, 0)")
                }
            }, {
                key: "visible",
                value: function (t, e) {
                    var n, i = t.duration,
                        r = i.start,
                        a = i.end,
                        s = e > r && e < a;
                    return t.tl && s && (n = vr.utils.clamp(0, 1, (e - r) / (a - r))), {
                        visible: s,
                        progress: n
                    }
                }
            }, {
                key: "getCache",
                value: function () {
                    var t = this,
                        e = Tc.wh;
                    this.cache = this.elems.map((function (n) {
                        return t.base({
                            el: n
                        }, e)
                    })), this.addTalentText(), this.addHiw()
                }
            }, {
                key: "base",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Tc.wh;
                    return function () {
                        var n = t.el,
                            i = {};
                        i.node = t.el, i.node.style.transform = "translate3d(0, 0, 0)", i.start = t.start || y("[data-stick-start]", n) || n.closest("[data-stick-start]"), i.end = t.end || y("[data-stick-end]", i.start) || n.closest("[data-stick-end]");
                        var r = {
                                node: x(n),
                                start: x(i.start),
                                end: x(i.end)
                            },
                            a = {
                                start: r.start.top - e,
                                end: r.end.bottom,
                                height: r.node.height,
                                progress: 0
                            },
                            s = 2 * (r.node.top - r.start.top),
                            o = e - r.node.height;
                        return {
                            els: i,
                            rects: r,
                            duration: a,
                            bounds: {
                                start: r.start.top,
                                max: r.start.bottom - r.start.top - e - s + o,
                                min: 0
                            },
                            tl: null
                        }
                    }()
                }
            }, {
                key: "addTalentText",
                value: function () {
                    var t = this.base({
                            el: y(".js-stick-talent"),
                            end: y(".js-stick-talent-end")
                        }),
                        e = t.bounds,
                        n = t.rects,
                        i = g.bounds.wh,
                        r = .5 * (i - n.node.height);
                    e.start = n.start.top - r, e.max = n.end.bottom - e.start - i + (i - n.end.height) / 2, t.tl = vr.timeline({
                        paused: !0,
                        defaults: {
                            ease: "linear",
                            duration: 1
                        }
                    }).fromTo(".js-tal-r", {
                        xPercent: 0,
                        alpha: 0
                    }, {
                        xPercent: -37.5,
                        alpha: 1
                    }), this.cache.push(t)
                }
            }, {
                key: "addHiw",
                value: function () {
                    var t = this.base({
                            el: y(".js-stick-hiw"),
                            end: y(".js-stick-hiw-end")
                        }),
                        e = t.bounds,
                        n = t.rects,
                        i = .5 * (g.bounds.wh - n.node.height);
                    e.start = n.start.top - i, this.cache.push(t)
                }
            }, {
                key: "removeEvents",
                value: function () {
                    U.off("tick", this.run), U.off("resize:on-reset", this.resize)
                }
            }, {
                key: "destroy",
                value: function () {
                    this.removeEvents(), this.cache = null
                }
            }]) && Mc(e.prototype, n), i && Mc(e, i), t
        }();

    function Cc(t) {
        return function (t) {
            if (Array.isArray(t)) return Pc(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return Pc(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Pc(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function Pc(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function Fc(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    var Lc = g.flags.isDesktop,
        Rc = function () {
            function t() {
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), this.elems = [].concat(Cc(_(".js-bm")), Cc(_(Lc ? ".js-bm-d" : ".js-bm-m"))), this.slides = y(".js-hiw-slides"), this.last = null, this.init()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function () {
                    var t = this;
                    this.elems.forEach((function (e) {
                        return t.set(e)
                    }))
                }
            }, {
                key: "set",
                value: function (t) {
                    var e = Uu.a.loadAnimation({
                        container: t,
                        renderer: "svg",
                        loop: !0,
                        autoplay: !1,
                        path: "/".concat(t.dataset.name, "/data.json")
                    });
                    e.setSubframe(!1), Bu.cache.push({
                        el: t,
                        ani: e,
                        enter: function (t) {
                            Lc && (t.el.style.visibility = "visible"), t.ani.play()
                        },
                        leave: function (t) {
                            t.ani.stop(), Lc && (t.el.style.visibility = "hidden")
                        },
                        intersecting: !1
                    }), Bu.inst.observe(t)
                }
            }]) && Fc(e.prototype, n), i && Fc(e, i), t
        }();

    function Ic(t) {
        return function (t) {
            if (Array.isArray(t)) return kc(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return kc(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return kc(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function kc(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function Oc(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Nc(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var Bc = g.flags,
        zc = g.bounds,
        Uc = function () {
            function t() {
                var e = this;
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), Nc(this, "ui", {}), Nc(this, "run", (function () {
                    var t = e.state,
                        n = t.target - t.current;
                    !t.dragging && Math.abs(n) <= .001 || (t.current += n * e.opts.ease, t.rounded = Math.round(100 * t.current) / 100, t.progress = t.rounded / t.max, !t.resizing && e.transformSlides())
                })), Nc(this, "down", (function (t) {
                    var n = t.x,
                        i = t.y;
                    if (t.target.closest(".js-proof-draggable")) {
                        var r = e.state;
                        Bc.dragging = !0, r.dragging = !0, r.cancel.x = n, r.cancel.y = i, r.on = r.target + n * e.opts.speed, !e.initial && e.removeCTA()
                    }
                })), Nc(this, "move", (function (t) {
                    var n = t.x,
                        i = t.y,
                        r = t.e,
                        a = e.state;
                    if (a.dragging) {
                        var s = a.cancel;
                        Math.abs(n - s.x) > Math.abs(i - s.y) && r.cancelable && (r.preventDefault(), r.stopPropagation()), a.target = a.on - n * e.opts.speed, e.clamp()
                    }
                })), Nc(this, "up", (function () {
                    Bc.dragging = !1, e.state.dragging = !1
                })), Nc(this, "resize", (function () {
                    var t = e.state;
                    t.resizing = !0, e.setCache(), e.clamp(), t.rounded = t.current = t.target, e.transformSlides(), t.resizing = !1
                })), this.el = y(".js-proof"), this.ui.container = y(".js-proof-slides"), this.ui.slides = Ic(_(".js-proof-slide")), this.state = {
                    target: 0,
                    current: 0,
                    rounded: 0,
                    on: 0,
                    max: 0,
                    cancel: {
                        x: 0,
                        y: 0
                    },
                    dragging: !1,
                    resizing: !1
                }, this.opts = {
                    speed: 2,
                    ease: .085
                }, this.init()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function () {
                    this.setCache(), this.addEvents()
                }
            }, {
                key: "addEvents",
                value: function () {
                    U.on("tick", this.run), U.on("mousedown", this.down), U.on("mouseup", this.up), U.on("mousemove", this.move), U.on("resize", this.resize)
                }
            }, {
                key: "setCache",
                value: function () {
                    var t = this,
                        e = this.ui,
                        n = e.slides,
                        i = e.container,
                        r = zc.ww,
                        a = n.length - 1;
                    this.cache = n.map((function (e, n) {
                        e.style.transform = "translate3d(0, 0, 0)";
                        var s = x(e),
                            o = s.left,
                            l = s.right;
                        return n === a && (t.state.max = l + (r - x(i).right) - r), {
                            el: e,
                            start: o - r - 50,
                            end: l + 50,
                            out: !0
                        }
                    }))
                }
            }, {
                key: "transform",
                value: function (t, e) {
                    t.style.transform = "translate3d(".concat(-e, "px, 0, 0)")
                }
            }, {
                key: "transformSlides",
                value: function () {
                    var t = this,
                        e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.state.rounded;
                    this.cache.forEach((function (n) {
                        t.visible(n, e) || t.state.resizing ? (n.out && (n.out = !1, n.el.style.visibility = "visible"), t.transform(n.el, e)) : n.out || (n.out = !0, t.transform(n.el, e), n.el.style.visibility = "hidden")
                    }))
                }
            }, {
                key: "visible",
                value: function (t, e) {
                    var n = t.start,
                        i = t.end;
                    return e > n && e < i
                }
            }, {
                key: "removeCTA",
                value: function () {
                    this.initial = !0;
                    var t = y(".js-btn-next", this.el);
                    vr.to(t, {
                        alpha: 0,
                        duration: .35,
                        ease: "power1",
                        onComplete: function () {
                            return t.remove()
                        }
                    })
                }
            }, {
                key: "clamp",
                value: function () {
                    var t = this.state;
                    t.target = vr.utils.clamp(0, t.max, t.target)
                }
            }, {
                key: "removeEvents",
                value: function () {
                    U.off("tick", this.run), U.off("mousedown", this.down), U.off("mouseup", this.up), U.off("mousemove", this.move), U.off("resize", this.resize)
                }
            }, {
                key: "destroy",
                value: function () {
                    this.removeEvents(), this.state = null, this.opts = null, this.ui = null
                }
            }]) && Oc(e.prototype, n), i && Oc(e, i), t
        }();

    function Vc(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(t);
            e && (i = i.filter((function (e) {
                return Object.getOwnPropertyDescriptor(t, e).enumerable
            }))), n.push.apply(n, i)
        }
        return n
    }

    function Gc(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = null != arguments[e] ? arguments[e] : {};
            e % 2 ? Vc(Object(n), !0).forEach((function (e) {
                qc(t, e, n[e])
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Vc(Object(n)).forEach((function (e) {
                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
            }))
        }
        return t
    }

    function Hc(t) {
        return function (t) {
            if (Array.isArray(t)) return jc(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return jc(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return jc(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function jc(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function Wc(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function Xc(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function qc(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var Yc = function () {
        function t() {
            var e = this,
                n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _("[data-from]");
            Wc(this, t), qc(this, "run", (function (t) {
                var n = t.current;
                e.current = n, !e.resizing && e.playTimelines()
            })), qc(this, "resize", (function () {
                e.resizing = !0, e.cache = null, e.getCache(), e.playTimelines(), e.resizing = !1
            })), this.elems = Hc(n), this.current = 0, this.resizing = !1, this.init()
        }
        var e, n, i;
        return e = t, (n = [{
            key: "init",
            value: function () {
                this.getCache(), this.addEvents()
            }
        }, {
            key: "addEvents",
            value: function () {
                U.on("tick", this.run), U.on("resize:on-reset", this.resize)
            }
        }, {
            key: "playTimelines",
            value: function () {
                var t = this,
                    e = g.bounds.wh;
                this.cache.forEach((function (n) {
                    if (t.visible(n) || t.resizing) {
                        var i = n.rect,
                            r = i.top,
                            a = i.height,
                            s = n.tl,
                            o = vr.utils.clamp(0, 1, 1 - (-t.current + r + a) / (a + e));
                        s.progress(o)
                    }
                }))
            }
        }, {
            key: "getCache",
            value: function () {
                this.cache = this.elems.map((function (t) {
                    var e = JSON.parse(t.dataset.from),
                        n = JSON.parse(t.dataset.to),
                        i = vr.timeline({
                            paused: !0
                        }).fromTo(t, 1, e, Gc(Gc({}, n), {
                            ease: "linear"
                        }));
                    i.progress(1);
                    var r = t.getBoundingClientRect();
                    return i.progress(0), {
                        tl: i,
                        rect: r,
                        start: r.top - g.bounds.wh,
                        end: r.bottom
                    }
                }))
            }
        }, {
            key: "visible",
            value: function (t) {
                var e = t.start,
                    n = t.end;
                return this.current > e && this.current < n
            }
        }, {
            key: "removeEvents",
            value: function () {
                U.off("tick", this.run), U.off("resize:on-reset", this.resize)
            }
        }, {
            key: "destroy",
            value: function () {
                this.removeEvents(), this.cache = this.elems = null
            }
        }]) && Xc(e.prototype, n), i && Xc(e, i), t
    }();

    function Zc(t) {
        return function (t) {
            if (Array.isArray(t)) return Jc(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return Jc(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Jc(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function Jc(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function Kc(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function $c(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    vr.registerPlugin(ec);
    var Qc = g.bounds,
        tp = g.flags.isDevice,
        ep = function () {
            function t() {
                var e = this;
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), $c(this, "ui", {}), $c(this, "addEvents", (function () {
                    U.on("tick", e.run), U.on("resize:on-reset", e.resize)
                })), $c(this, "run", (function (t) {
                    var n = t.current;
                    (!e.state.resizing || n > e.bounds.max) && e.animate(n)
                })), $c(this, "resize", (function () {
                    var t = e.state;
                    t.resizing = !0, e.setBounds(), e.setTlA(), e.setTlB(), e.animate(), t.resizing = !1
                })), $c(this, "removeEvents", (function () {
                    U.off("tick", e.run), U.off("resize:on-reset", e.resize)
                })), this.ui.texts = Zc(_(".js-h-txt")), this.ui.intro = y(".js-intro"), this.ui.introContent = y(".js-intro-content"), this.state = {
                    progress: {
                        a: 0,
                        b: 0
                    },
                    resizing: !1
                }, this.tl = {
                    a: null,
                    b: null
                }, this.init()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function () {
                    this.cacheTexts(), this.setBounds(), this.setLottie(), this.setTlA(), this.setTlB(), this.addEvents()
                }
            }, {
                key: "setBounds",
                value: function () {
                    var t = this.ui,
                        e = t.intro,
                        n = t.introContent,
                        i = tp ? vu.target : 0,
                        r = x(n).top + i,
                        a = x(e).top + i,
                        s = r - .5 * Qc.wh - a,
                        o = r;
                    this.bounds = {
                        start: a,
                        end: s,
                        max: o
                    }
                }
            }, {
                key: "cacheTexts",
                value: function () {
                    this.texts = this.ui.texts.map((function (t, e) {
                        var n = _(".js-h-txt__l", t),
                            i = vr.timeline({
                                paused: !0
                            }),
                            r = .25 * e,
                            a = .25 * (e + 1),
                            s = [y(".js-h-uline", t), y(".js-h-uline span", t)];
                        return 0 !== e && vr.set(n, {
                            yPercent: 100
                        }), 1 === e ? {
                            i: e,
                            el: t,
                            lines: n,
                            uline: s,
                            tl: i,
                            p1: r,
                            p2: a,
                            p1T: !1,
                            p2T: !1
                        } : 2 === e ? {
                            i: e,
                            el: t,
                            lines: n,
                            uline: s,
                            tl: i,
                            p1: r,
                            p1T: !1
                        } : {
                            i: e,
                            el: t,
                            lines: n,
                            uline: s,
                            tl: i,
                            p2: a,
                            p2T: !1
                        }
                    }))
                }
            }, {
                key: "setLottie",
                value: function () {
                    this.icon = Uu.a.loadAnimation({
                        container: y(".js-h-progress"),
                        loop: !1,
                        autoplay: !1,
                        path: "/data.json"
                    })
                }
            }, {
                key: "setTlA",
                value: function () {
                    var t = this,
                        e = {
                            progress: 0
                        };
                    this.tl.a && this.tl.a.kill(), this.tl.a = vr.timeline({
                        paused: !0,
                        defaults: {
                            ease: "linear"
                        }
                    }).fromTo(".js-h-circle path", {
                        drawSVG: 0
                    }, {
                        drawSVG: "100%",
                        duration: .8,
                        ease: "power1.inOut"
                    }, 0).to(e, {
                        progress: 1,
                        duration: 1,
                        onUpdate: function () {
                            t.icon.goToAndStop(e.progress * t.icon.getDuration(!1) * 1e3, !1)
                        }
                    }, 0)
                }
            }, {
                key: "setTlB",
                value: function () {
                    var t = this,
                        e = {
                            progress: 1
                        };
                    !this.state.resizing && (this.planes = uu.slides.children.filter((function (t) {
                        return t.name.includes("slide")
                    }))), this.tl.b && this.tl.b.kill(), this.tl.b = vr.timeline({
                        paused: !0,
                        defaults: {
                            ease: "linear"
                        }
                    }).fromTo(".js-intro__bg", {
                        alpha: 0
                    }, {
                        alpha: 1,
                        duration: .25,
                        ease: "linear"
                    }, 0).fromTo([".js-h-logo, .js-h-play-icon"], {
                        alpha: 1
                    }, {
                        alpha: 0,
                        duration: .25,
                        ease: "linear"
                    }, 0).to(e, {
                        progress: 0,
                        duration: 1,
                        onUpdate: function () {
                            t.togglePlanes(e.progress)
                        }
                    }, 0).fromTo(".js-h-txt--last", {
                        alpha: 1
                    }, {
                        alpha: 0,
                        duration: .9
                    }, 0)
                }
            }, {
                key: "animate",
                value: function () {
                    var t = this,
                        e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : vu.target,
                        n = this.state.progress,
                        i = this.bounds,
                        r = i.start,
                        a = i.end;
                    n.a = vr.utils.clamp(0, 1, e / r), n.b = vr.utils.clamp(0, 1, (e - r) / a), this.texts.forEach((function (e) {
                        return t.toggleTexts(e, n.a)
                    })), this.tl.a.progress(n.a), this.tl.b.progress(n.b)
                }
            }, {
                key: "togglePlanes",
                value: function (t) {
                    this.planes.forEach((function (e) {
                        return e.material.uniforms.uAlpha.value = t
                    }))
                }
            }, {
                key: "toggleTexts",
                value: function (t, e) {
                    t.p1 && this.toggleP1(t, e), this.toggleP2(t, e)
                }
            }, {
                key: "toggleP1",
                value: function (t, e) {
                    e > t.p1 && !t.p1T ? (t.p1T = !0, t.tl.clear().set(t.uline, {
                        alpha: 1
                    }).fromTo(t.lines, {
                        yPercent: 100
                    }, {
                        yPercent: 0,
                        duration: 1.1,
                        stagger: .075,
                        ease: "expo"
                    }, .35).fromTo(t.uline, {
                        xPercent: vr.utils.wrap([-100, 100])
                    }, {
                        xPercent: 0,
                        duration: 1,
                        ease: "expo.inOut"
                    }, .45).play()) : e <= t.p1 && t.p1T && (t.p1T = !1, t.tl.clear().to(t.lines, {
                        yPercent: -100,
                        duration: .5,
                        stagger: .075,
                        ease: "power2.inOut"
                    }).to(t.uline, {
                        xPercent: vr.utils.wrap([100, -100]),
                        duration: .5,
                        ease: "expo.inOut"
                    }, 0).play())
                }
            }, {
                key: "toggleP2",
                value: function (t, e) {
                    e > t.p2 && !t.p2T ? (t.p2T = !0, t.tl.clear().to(t.lines, {
                        yPercent: -100,
                        duration: .5,
                        stagger: .075,
                        ease: "power2.inOut"
                    }).to(t.uline, {
                        xPercent: vr.utils.wrap([100, -100]),
                        duration: .5,
                        ease: "expo.inOut"
                    }, 0).play()) : e <= t.p2 && t.p2T && (t.p2T = !1, t.tl.clear().set(t.uline, {
                        alpha: 1
                    }).fromTo(t.lines, {
                        yPercent: 100
                    }, {
                        yPercent: 0,
                        duration: 1.1,
                        stagger: .075,
                        ease: "expo"
                    }, .35).fromTo(t.uline, {
                        xPercent: vr.utils.wrap([-100, 100])
                    }, {
                        xPercent: 0,
                        duration: 1,
                        ease: "expo.inOut"
                    }, .45).play())
                }
            }, {
                key: "destroy",
                value: function () {
                    this.removeEvents(), this.planes = null, this.tl.a.kill(), this.tl.b.kill(), this.state = null, this.texts = null
                }
            }]) && Kc(e.prototype, n), i && Kc(e, i), t
        }();

    function np(t) {
        return function (t) {
            if (Array.isArray(t)) return ip(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return ip(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ip(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function ip(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function rp(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function ap(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var sp, op, lp, hp, up, cp, pp, fp = g.bounds,
        dp = g.flags,
        mp = function () {
            function t() {
                var e = this;
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), ap(this, "ui", {}), ap(this, "run", (function () {
                    var t = e.state,
                        n = t.target,
                        i = n.x,
                        r = n.scale,
                        a = t.current,
                        s = t.resize,
                        o = i - a.x;
                    Math.abs(o) <= .001 || (a.x += .1 * o, a.scale += .1 * (r - a.scale), !s && e.transformLine(a.x, a.scale))
                })), ap(this, "handle", (function (t) {
//                    t.forEach((function (t) {
//                        var n = e.cache && e.cache.menu.find((function (e) {
//                            return e.elem === t.target
//                        }));
//                        if (n) {
//                            var i = n.el,
//                                r = n.i,
//                                a = n.x,
//                                s = n.scaleX;
//                            if (t.isIntersecting) {
//                                var o = e.state;
//                                o.last && o.last.classList.remove("is-active"), o.i = r, e.line(a, s), i.classList.add("is-active"), o.last = i
//                            }
//                        } else {
//                            var l = e.cache.hiw.find((function (e) {
//                                return e.elem === t.target
//                            })).el;
//                            if (t.isIntersecting) {
//                                var h = e.state.hiw;
//                                h.last && h.last.classList.remove("is-active"), l.classList.add("is-active"), h.last = l
//                            }
//                        }
//                    }))
                })), ap(this, "anchorScroll", (function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                    t && t.preventDefault();
                    var n = e.cache.elems[e.ui.elems.indexOf(t.currentTarget)];
                    vr.to(vu, {
                        target: n,
                        duration: 1.5,
                        ease: "power3.inOut"
                    })
                })), ap(this, "arrowScroll", (function (t) {
                    var n = t.currentTarget,
                        i = e.ui.arrows.indexOf(n),
                        r = vr.utils.clamp(0, fp.scroll, e.cache.arrows[i]);
                    vr.to(vu, {
                        target: r,
                        duration: 1,
                        ease: "power3.inOut"
                    })
                })), ap(this, "resize", (function () {
                    var t = e.state;
                    t.resize = !0, e.setElemCache(), e.setArrowCache(), e.updateMenuCache(), t.resize = !1
                })), this.ui.elems = np(_("[data-anchor]")), this.ui.menuElems = this.ui.elems.filter((function (t) {
                    return t.classList.contains("js-sm-link")
                })), this.ui.hiwElems = this.ui.elems.filter((function (t) {
                    return t.classList.contains("js-hiw-link")
                })), this.ui.arrows = np(_(".js-s-arrow")), this.ui.line = y(".js-sh-line"), this.state = {
                    last: null,
                    target: {
                        scale: 0,
                        x: 0
                    },
                    current: {
                        scale: 0,
                        x: 0
                    },
                    hiw: {
                        last: 0
                    },
                    i: 0
                }, this.cache = {
                    elems: null,
                    arrows: null,
                    menu: null,
                    hiw: null
                }, this.o = new IntersectionObserver(this.handle, {
                    root: null,
                    rootMargin: "-25% 0px -25% 0px",
                    threshold: [0, 0]
                }), this.init()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function () {
                    this.setElemCache(), this.setArrowCache(), this.setMenuCache(), this.setHiwCache(), this.addEvents()
                }
            }, {
                key: "addEvents",
                value: function () {
                    var t = this.ui,
                        e = t.elems,
                        n = t.arrows;
                    U.on("tick", this.run), U.on("resize:on-reset", this.resize), e.length && U.on("click", e, this.anchorScroll), n.length && U.on("click", n, this.arrowScroll)
                }
            }, {
                key: "setElemCache",
                value: function () {
                    var t = fp.ww;
                    this.cache.elems = this.ui.elems.map((function (e) {
                        var n = y("".concat(e.dataset.anchor)),
                            i = t * (n.dataset.offset || .1);
                        return x(n).top - i
                    }))
                }
            }, {
                key: "setArrowCache",
                value: function () {
                    var t = fp.ww,
                        e = this.ui.arrows;
                    e.length && (this.cache.arrows = e.map((function (n, i) {
                        return i >= e.length - 2 ? 0 : x(e[i + 1]).top - .1 * t
                    })))
                }
            }, {
                key: "setMenuCache",
                value: function () {
                    var t = this,
                        e = this.ui,
                        n = e.menuElems,
                        i = e.line;
                    if (n.length) {
                        var r = x(i).width;
                        this.cache.menu = n.map((function (e, n) {
                            var a = y("".concat(e.dataset.anchor)),
                                s = e.offsetLeft,
                                o = e.offsetWidth / r;
                            return 0 === n && (dp.initial ? vr.timeline().set(i, {
                                alpha: 1
                            }).fromTo(i, {
                                scaleX: 0,
                                x: 0
                            }, {
                                scaleX: o,
                                x: s,
                                duration: .75,
                                ease: "power3.inOut"
                            }) : vr.set(i, {
                                alpha: 1,
                                scaleX: o,
                                x: s
                            })), t.o.observe(a), {
                                el: e,
                                elem: a,
                                i: n,
                                x: s,
                                scaleX: o
                            }
                        }))
                    }
                }
            }, {
                key: "setHiwCache",
                value: function () {
                    var t = this,
                        e = this.ui.hiwElems;
                    e.length && (this.cache.hiw = e.map((function (e) {
                        var n = y("".concat(e.dataset.anchor));
                        return t.o.observe(n), {
                            el: e,
                            elem: n
                        }
                    })))
                }
            }, {
                key: "updateMenuCache",
                value: function () {
                    var t = this.cache.menu;
                    if (t) {
                        this.transformLine(0, 1);
                        var e = x(this.ui.line).width;
                        t.forEach((function (t) {
                            t.x = t.el.offsetLeft, t.scaleX = t.el.offsetWidth / e
                        })), this.line(), this.transformLine()
                    }
                }
            }, {
                key: "transformLine",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.state.current.x,
                        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state.current.scale,
                        n = this.ui.line;
                    n && (n.style.transform = "translate3d(".concat(t, "px, 0, 0) scaleX(").concat(e, ")"))
                }
            }, {
                key: "line",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.cache.menu[this.state.i].x,
                        e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.cache.menu[this.state.i].scaleX,
                        n = this.state.target;
                    n.scale = e, n.x = t
                }
            }, {
                key: "removeEvents",
                value: function () {
                    var t = this.ui,
                        e = t.elems,
                        n = t.arrows;
                    e.length && U.off("click", e, this.anchorScroll), n.length && U.off("click", n, this.arrowScroll), U.off("resize:on-reset", this.resize)
                }
            }, {
                key: "destroy",
                value: function () {
                    this.removeEvents(), this.cache = null, this.ui = null
                }
            }]) && rp(e.prototype, n), i && rp(e, i), t
        }(),
        gp = function () {
            return "undefined" != typeof window
        },
        vp = function () {
            return sp || gp() && (sp = window.gsap) && sp.registerPlugin && sp
        },
        yp = function (t) {
            return "string" == typeof t
        },
        _p = function (t, e) {
            var n = "x" === e ? "Width" : "Height",
                i = "scroll" + n,
                r = "client" + n;
            return t === lp || t === hp || t === up ? Math.max(hp[i], up[i]) - (lp["inner" + n] || hp[r] || up[r]) : t[i] - t["offset" + n]
        },
        xp = function (t, e) {
            var n = "scroll" + ("x" === e ? "Left" : "Top");
            return t === lp && (null != t.pageXOffset ? n = "page" + e.toUpperCase() + "Offset" : t = null != hp[n] ? hp : up),
                function () {
                    return t[n]
                }
        },
        bp = function (t, e) {
            var n = cp(t)[0].getBoundingClientRect(),
                i = !e || e === lp || e === up,
                r = i ? {
                    top: hp.clientTop - (lp.pageYOffset || hp.scrollTop || up.scrollTop || 0),
                    left: hp.clientLeft - (lp.pageXOffset || hp.scrollLeft || up.scrollLeft || 0)
                } : e.getBoundingClientRect(),
                a = {
                    x: n.left - r.left,
                    y: n.top - r.top
                };
            return !i && e && (a.x += xp(e, "x")(), a.y += xp(e, "y")()), a
        },
        Ep = function (t, e, n, i) {
            return isNaN(t) || "object" == typeof t ? yp(t) && "=" === t.charAt(1) ? parseFloat(t.substr(2)) * ("-" === t.charAt(0) ? -1 : 1) + i : "max" === t ? _p(e, n) : Math.min(_p(e, n), bp(t, e)[n]) : parseFloat(t)
        },
        wp = function () {
            sp = vp(), gp() && sp && document.body && (lp = window, up = document.body, hp = document.documentElement, cp = sp.utils.toArray, sp.config({
                autoKillThreshold: 7
            }), pp = sp.config(), op = 1)
        },
        Dp = {
            version: "3.2.6",
            name: "scrollTo",
            rawVars: 1,
            register: function (t) {
                sp = t, wp()
            },
            init: function (t, e, n, i, r) {
                op || wp();
                this.isWin = t === lp, this.target = t, this.tween = n, "object" != typeof e ? yp((e = {
                    y: e
                }).y) && "max" !== e.y && "=" !== e.y.charAt(1) && (e.x = e.y) : e.nodeType && (e = {
                    y: e,
                    x: e
                }), this.vars = e, this.autoKill = !!e.autoKill, this.getX = xp(t, "x"), this.getY = xp(t, "y"), this.x = this.xPrev = this.getX(), this.y = this.yPrev = this.getY(), null != e.x ? (this.add(this, "x", this.x, Ep(e.x, t, "x", this.x) - (e.offsetX || 0), i, r, Math.round), this._props.push("scrollTo_x")) : this.skipX = 1, null != e.y ? (this.add(this, "y", this.y, Ep(e.y, t, "y", this.y) - (e.offsetY || 0), i, r, Math.round), this._props.push("scrollTo_y")) : this.skipY = 1
            },
            render: function (t, e) {
                for (var n, i, r, a, s, o = e._pt, l = e.target, h = e.tween, u = e.autoKill, c = e.xPrev, p = e.yPrev, f = e.isWin; o;) o.r(t, o.d), o = o._next;
                n = f || !e.skipX ? e.getX() : c, r = (i = f || !e.skipY ? e.getY() : p) - p, a = n - c, s = pp.autoKillThreshold, e.x < 0 && (e.x = 0), e.y < 0 && (e.y = 0), u && (!e.skipX && (a > s || a < -s) && n < _p(l, "x") && (e.skipX = 1), !e.skipY && (r > s || r < -s) && i < _p(l, "y") && (e.skipY = 1), e.skipX && e.skipY && (h.kill(), e.vars.onAutoKill && e.vars.onAutoKill.apply(h, e.vars.onAutoKillParams || []))), f ? lp.scrollTo(e.skipX ? n : e.x, e.skipY ? i : e.y) : (e.skipY || (l.scrollTop = e.y), e.skipX || (l.scrollLeft = e.x)), e.xPrev = e.x, e.yPrev = e.y
            },
            kill: function (t) {
                var e = "scrollTo" === t;
                (e || "scrollTo_x" === t) && (this.skipX = 1), (e || "scrollTo_y" === t) && (this.skipY = 1)
            }
        };

    function Mp(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function Sp(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Tp(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    Dp.max = _p, Dp.getOffset = bp, Dp.buildGetter = xp, vp() && sp.registerPlugin(Dp), vr.registerPlugin(Dp);
    var Ap = g.dom.scroll,
        Cp = function () {
            function t() {
                var e = this,
                    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _("[data-anchor]");
                Mp(this, t), Tp(this, "animate", (function (t) {
                    var n = t.currentTarget;
                    e.tl.clear().to(Ap, {
                        scrollTo: {
                            y: "".concat(n.dataset.anchor),
                            offsetY: 200
                        },
                        duration: 1.5,
                        ease: "power3.inOut"
                    }).play()
                })), this.elems = n, this.tl = vr.timeline({
                    paused: !0
                }), U.on("click", this.elems, this.animate)
            }
            var e, n, i;
            return e = t, (n = [{
                key: "destroy",
                value: function () {
                    U.off("click", this.elems, this.animate), this.tl.kill()
                }
            }]) && Sp(e.prototype, n), i && Sp(e, i), t
        }();

    function Pp(t) {
        return function (t) {
            if (Array.isArray(t)) return Fp(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return Fp(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Fp(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function Fp(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function Lp(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Rp(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var Ip = g.flags,
        kp = function () {
            function t() {
                var e = this;
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), Rp(this, "ui", {}), Rp(this, "click", (function (t) {
                    var n = t.target;
                    if (t.click) {
                        var i = n.closest("[data-v-src]");
                        i && e.open(i.dataset.vSrc)
                    }
                })), Rp(this, "enter", (function (t) {
                    var n = t.currentTarget;
//                    e.cache[e.ui.elems.indexOf(n)].a.goToAndPlay(1)
                })), Rp(this, "close", (function () {
                    e.state.open = !1;
                    var t = e.ui,
                        n = t.vm,
                        i = t.vid;
                    e.tl.clear().to(n, {
                        autoAlpha: 0,
                        duration: .35,
                        ease: "power1"
                    }).add((function () {
                        return i.pause()
                    })).play(), Ip.locked = !1, n.classList.remove("is-open")
                })), this.ui.elems = Pp(_("[data-v-src]")), this.ui.vm = y(".js-vm"), this.ui.vid = y(".js-vm-vid"), this.tl = vr.timeline({
                    paused: !0
                }), this.state = {
                    open: !1
                }, this.init()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function () {
//                    this.setCache(), 
                    this.addEvents()
                }
            }, {
                key: "addEvents",
                value: function () {
                    U.on("click", ".js-vm-close", this.close), U.on("mouseup", this.click), Ip.hover && U.on("mouseenter", this.ui.elems, this.enter)
                }
            }, {
                key: "setCache",
                value: function () {
                    this.cache = this.ui.elems.map((function (t) {
                        var e = Uu.a.loadAnimation({
                            container: t,
                            renderer: "svg",
                            loop: !1,
                            autoplay: !1,
                            path: "/data.json"
                        });
                        return e.setSubframe(!1), {
                            a: e
                        }
                    }))
                }
            }, {
                key: "open",
                value: function (t) {
                    var e = this.state;
                    if (!e.open) {
                        e.open = !0;
                        var n = this.ui,
                            i = n.vm,
                            r = n.vid;
                        t !== r.src && (r.src = t), r.play(), this.tl.clear().to(i, {
                            autoAlpha: 1,
                            duration: .35,
                            ease: "power1"
                        }).add((function () {
                            Ip.locked = !0
                        })).play(), i.classList.add("is-open")
                    }
                }
            }]) && Lp(e.prototype, n), i && Lp(e, i), t
        }();

    function Op(t) {
        return function (t) {
            if (Array.isArray(t)) return Np(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return Np(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Np(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function Np(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function Bp(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function zp(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    var Up = g.flags.isDevice,
        Vp = function () {
            function t() {
                var e = this,
                    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _("[data-lazy-src]");
                Bp(this, t), this.elems = n, Up && (this.elems = [].concat(Op(this.elems), Op(_("[data-lazy-src-m]")))), this.elems.forEach((function (t) {
                    return e.set(t)
                })), this.load()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "load",
                value: function () {
                    var t = _("[data-lazy-load]");
                    t && t.forEach((function (t) {
                        return t.src = t.dataset.lazyLoad
                    }))
                }
            }, {
                key: "set",
                value: function () {
                    this.elems.forEach((function (t) {
                        Bu.cache.push({
                            el: t,
                            enter: function (e, n) {
                                var i = e.e,
                                    r = void 0 === i ? t : i,
                                    a = "IMG" === t.nodeName,
                                    s = r.dataset.lazySrc || r.dataset.lazySrcM,
                                    o = new Image;
                                o.src = s, o.decode().then((function () {
                                    a ? r.src = s : r.appendChild(o), r.classList.add("is-animated")
                                })), Bu.inst.unobserve(n)
                            }
                        }), Bu.inst.observe(t)
                    }))
                }
            }]) && zp(e.prototype, n), i && zp(e, i), t
        }();

    function Gp(t) {
        return function (t) {
            if (Array.isArray(t)) return Hp(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return Hp(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Hp(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function Hp(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function jp(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Wp(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var Xp = g.bounds,
        qp = function () {
            function t() {
                var e = this;
                ! function (t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, t), Wp(this, "run", (function (t) {
                    var n = t.current;
                    if (!t.still) {
                        var i = e.i,
                            r = e.visible(n);
                        r ? (!e.initial && e.setInitial(), i.last = i.current, i.current = Math.round(vr.utils.clamp(0, 1, (n - e.min) / e.max) * e.total), i.last !== i.current && e.check()) : r || e.out || i.current !== e.total || (e.out = !0, e.cache[e.total].ani.stop())
                    }
                })), Wp(this, "resize", (function () {
                    e.cache.forEach((function (t, n) {
                        return e.setBounds(n, t.el)
                    }))
                })), this.container = y(".js-hiw-slides"), this.slides = Gp(_(".js-hiw-slide")), this.current = 0, this.total = this.slides.length - 1, this.z = this.total + 1, this.i = {
                    last: 0,
                    curent: 0
                }, this.initial = !1, this.init()
            }
            var e, n, i;
            return e = t, (n = [{
                key: "init",
                value: function () {
                    this.setCache(), this.addEvents()
                }
            }, {
                key: "addEvents",
                value: function () {
                    U.on("tick", this.run), U.on("resize:on-reset", this.resize)
                }
            }, {
                key: "check",
                value: function () {
                    var t = this.cache[this.i.last],
                        e = this.cache[this.i.current],
                        n = e.inner,
                        i = e.ani;
                    t && t.ani.stop(), this.z += 1, this.container.appendChild(n), this.tl(n, t), i.play()
                }
            }, {
                key: "setInitial",
                value: function () {
                    this.initial = !0;
                    var t = this.cache[0],
                        e = t.ani,
                        n = t.inner;
                    e.play(), vr.set(n, {
                        alpha: 1
                    })
                }
            }, {
                key: "tl",
                value: function (t, e) {
                    return vr.timeline({
                        onComplete: function () {
                            return e && e.inner.remove()
                        }
                    }).set(t, {
                        zIndex: this.z
                    }).fromTo(t, {
                        alpha: 0
                    }, {
                        alpha: 1,
                        duration: .25,
                        ease: "power1"
                    })
                }
            }, {
                key: "visible",
                value: function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.current;
                    return t > this.start && t < this.end
                }
            }, {
                key: "setCache",
                value: function () {
                    var t = this;
                    this.cache = this.slides.map((function (e, n) {
                        var i = y("[data-name]", e),
                            r = Uu.a.loadAnimation({
                                container: i,
                                renderer: "svg",
                                loop: !0,
                                autoplay: !1,
                                path: "/static/lottie/".concat(i.dataset.name, "/data.json")
                            });
                        return r.setSubframe(!1), t.setBounds(n, e), i.remove(), t.container.appendChild(i), vr.set(i, {
                            alpha: 0
                        }), {
                            inner: i,
                            el: e,
                            ani: r
                        }
                    }))
                }
            }, {
                key: "setBounds",
                value: function (t, e) {
                    if (0 === t || t === this.total) {
                        var n = Xp.wh,
                            i = .25 * n,
                            r = x(e),
                            a = r.top,
                            s = r.bottom;
                        0 === t && (this.start = a - n, this.min = a - i), t === this.total && (this.end = s, this.max = a - i - this.min)
                    }
                }
            }, {
                key: "removeEvents",
                value: function () {
                    U.off("tick", this.run), U.off("resize:on-reset", this.resize)
                }
            }, {
                key: "destroy",
                value: function () {
                    this.removeEvents(), this.cache.forEach((function (t) {
                        return t.ani.destroy()
                    })), this.cache = this.i = null
                }
            }]) && jp(e.prototype, n), i && jp(e, i), t
        }();

    function Yp(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }
    var Zp = function () {
        function t(e) {
            var n, i, r, a = this;
            ! function (t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), r = function (t) {
                t && t.preventDefault(), document.MC_callback = function (t) {
                    "success" == t.result ? a.msg.textContent = "Subscribed to waitlist" : a.msg.textContent = "Make sure your inputs are correct"
                }, a.appendScript()
            }, (i = "submit") in (n = this) ? Object.defineProperty(n, i, {
                value: r,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : n[i] = r, this.el = e, this.form = y("form", this.el), this.action = this.form.getAttribute("action"), this.inputs = {
                email: y(".js-mc-email", this.form),
                tel: y(".js-mc-phone", this.form)
            }, this.msg = y(".js-mc-msg", this.form), this.addEvents()
        }
        var e, n, i;
        return e = t, (n = [{
            key: "addEvents",
            value: function () {
                U.on("submit", this.el, this.submit)
            }
        }, {
            key: "appendScript",
            value: function () {
                var t = y(".js-mc-script");
                t && t.remove();
                var e = this.inputs,
                    n = e.email,
                    i = e.tel,
                    r = document.createElement("script");
                r.type = "text/javascript", r.classList.add("js-mc-script"), r.src = "".concat(this.action, "&c=document.MC_callback&EMAIL=").concat(n.value, "&PHONE=").concat(i.value), y("head").appendChild(r)
            }
        }, {
            key: "destroy",
            value: function () {
                U.off("submit", this.el, this.submit)
            }
        }]) && Yp(e.prototype, n), i && Yp(e, i), t
    }();

    function Jp(t) {
        return (Jp = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
            return typeof t
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Kp(t) {
        return function (t) {
            if (Array.isArray(t)) return $p(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (!t) return;
            if ("string" == typeof t) return $p(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return $p(t, e)
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function $p(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
        return i
    }

    function Qp(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function tf(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function ef(t, e) {
        return (ef = Object.setPrototypeOf || function (t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function nf(t) {
        var e = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function () {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function () {
            var n, i = af(t);
            if (e) {
                var r = af(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return rf(this, n)
        }
    }

    function rf(t, e) {
        return !e || "object" !== Jp(e) && "function" != typeof e ? function (t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function af(t) {
        return (af = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var sf = g.flags,
        of = g.dom,
        lf = sf.isDevice,
        hf = sf.isDesktop,
        uf = function (t) {
            ! function (t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && ef(t, e)
            }(a, t);
            var e, n, i, r = nf(a);

            function a() {
                return Qp(this, a), r.apply(this, arguments)
            }
            return e = a, (n = [{
                key: "initial",
                value: function () {
                    var t = this;
                    new ac, g.addClasses(), this.onEnter(), window.onload = function () {
                        return t.loaded()
                    }
                }
            }, {
                key: "onEnter",
                value: function () {
                    of .scroll.scrollTop = 0, this.el = this.wrap.lastElementChild
                }
            }, {
                key: "onLeave",
                value: function () {
                    this.scrollTo && this.scrollTo.destroy(), this.forms && this.forms.forEach((function (t) {
                        return t.destroy()
                    }))
                }
            }, {
                key: "onEnterCompleted",
                value: function () {
                    this.handleVm(), this.handleSmoothScroll(), this.handleLazy(), this.handleScrollTo(), this.handleMC(), this.lottieScroll = new Rc, this.parallax = new Yc
                }
            }, {
                key: "onLeaveCompleted",
                value: function () {
                    this.smoothScroll && this.smoothScroll.destroy(), U.emit("on-leave-completed")
                }
            }, {
                key: "handleSmoothScroll",
                value: function () {
                    if (!lf) {
                        var t = _("[data-smooth-item]");
                        t.length > 0 && (this.smoothScroll = new pc(t))
                    }
                }
            }, {
                key: "handleScrollTo",
                value: function () {
                    if (hf) this.scrollTo = new mp;
                    else {
                        var t = _("[data-anchor]");
                        t.length && (this.scrollTo = new Cp(t))
                    }
                }
            }, {
                key: "handleVm",
                value: function () {
                    this.vm = new kp
                }
            }, {
                key: "handleLazy",
                value: function () {
                    var t = _("[data-lazy-src]");
                    t.length > 0 && (this.lazy = new Vp(t))
                }
            }, {
                key: "handleMC",
                value: function () {
                    var t = _(".js-mc-form", this.el);
                    t.length > 0 && (this.forms = Kp(t).map((function (t) {
                        return new Zp(t)
                    })))
                }
            }, {
                key: "loaded",
                value: function () {
                    this.onEnterCompleted(), new Lh, U.emit("loaded"), sf.initial = !0
                }
            }, {
                key: "setup",
                value: function () {
                    this.initial()
                }
            }]) && tf(e.prototype, n), i && tf(e, i), a
        }(c.Renderer);

    function cf(t) {
        return (cf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
            return typeof t
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function pf(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function ff(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function df(t, e, n) {
        return (df = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
            var i = function (t, e) {
                for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = _f(t)););
                return t
            }(t, e);
            if (i) {
                var r = Object.getOwnPropertyDescriptor(i, e);
                return r.get ? r.get.call(n) : r.value
            }
        })(t, e, n || t)
    }

    function mf(t, e) {
        return (mf = Object.setPrototypeOf || function (t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function gf(t) {
        var e = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function () {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function () {
            var n, i = _f(t);
            if (e) {
                var r = _f(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return vf(this, n)
        }
    }

    function vf(t, e) {
        return !e || "object" !== cf(e) && "function" != typeof e ? yf(t) : e
    }

    function yf(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function _f(t) {
        return (_f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }

    function xf(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    var bf = g.bounds,
        Ef = g.flags.isDevice,
        wf = bf.hero,
        Df = function (t) {
            ! function (t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && mf(t, e)
            }(a, t);
            var e, n, i, r = gf(a);

            function a() {
                var t;
                pf(this, a);
                for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
                return xf(yf(t = r.call.apply(r, [this].concat(n))), "setHeroBounds", (function () {
                    var e = bf.ww,
                        n = _(".js-hero-slide", t.el),
                        i = y(".js-hero", t.el);
                    n && (wf.w = x(n[n.length - 1]).right - e), i && (wf.h = x(i).height)
                })), t
            }
            return e = a, (n = [{
                key: "initial",
                value: function () {
                    df(_f(a.prototype), "initial", this).call(this), U.on("resize", this.setHeroBounds)
                }
            }, {
                key: "onEnter",
                value: function () {
                    df(_f(a.prototype), "onEnter", this).call(this), this.setHeroBounds(), this.initGl(), this.intro = new ep
                }
            }, {
                key: "onLeave",
                value: function () {
                    df(_f(a.prototype), "onLeave", this).call(this), this.stickies && this.stickies.destroy(), this.hiw && this.hiw.destroy(), this.pricing && this.pricing.destroy(), this.proof && this.proof.destroy()
                }
//            }, {
//                key: "onEnterCompleted",
//                value: function () {
//                    df(_f(a.prototype), "onEnterCompleted", this).call(this), !Ef && (this.stickies = new Ac, this.hiw = new qp), this.pricing = new bc, this.proof = new Uc
//                }
            }, {
                key: "onLeaveCompleted",
                value: function () {
                    df(_f(a.prototype), "onLeaveCompleted", this).call(this), this.intro && this.intro.destroy(), yh.destroy()
                }
            }, {
                key: "initGl",
                value: function () {
                    yh.init(this.el), uu.addPlanes({
                        el: this.el
                    })
                }
            }]) && ff(e.prototype, n), i && ff(e, i), a
        }(uf);

    function Mf(t) {
        return (Mf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
            return typeof t
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function Sf(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function Tf(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function Af(t, e) {
        return (Af = Object.setPrototypeOf || function (t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Cf(t) {
        var e = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function () {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function () {
            var n, i = Ff(t);
            if (e) {
                var r = Ff(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Pf(this, n)
        }
    }

    function Pf(t, e) {
        return !e || "object" !== Mf(e) && "function" != typeof e ? function (t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function Ff(t) {
        return (Ff = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    var Lf = function (t) {
        ! function (t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && Af(t, e)
        }(a, t);
        var e, n, i, r = Cf(a);

        function a() {
            return Sf(this, a), r.apply(this, arguments)
        }
        return e = a, (n = [{
            key: "in",
            value: function (t) {
                var e = t.done;
                U.emit("transition:in", {
                    done: e
                })
            }
        }, {
            key: "out",
            value: function (t) {
                var e = t.from,
                    n = t.done;
                U.emit("transition:out", {
                    done: n,
                    from: e
                })
            }
        }]) && Tf(e.prototype, n), i && Tf(e, i), a
    }(c.Transition);

    function Rf(t) {
        return (Rf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
            return typeof t
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function If(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
        }
    }

    function kf(t, e, n) {
        return (kf = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
            var i = function (t, e) {
                for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = zf(t)););
                return t
            }(t, e);
            if (i) {
                var r = Object.getOwnPropertyDescriptor(i, e);
                return r.get ? r.get.call(n) : r.value
            }
        })(t, e, n || t)
    }

    function Of(t, e) {
        return (Of = Object.setPrototypeOf || function (t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function Nf(t) {
        var e = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function () {}))), !0
            } catch (t) {
                return !1
            }
        }();
        return function () {
            var n, i = zf(t);
            if (e) {
                var r = zf(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else n = i.apply(this, arguments);
            return Bf(this, n)
        }
    }

    function Bf(t, e) {
        return !e || "object" !== Rf(e) && "function" != typeof e ? function (t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function zf(t) {
        return (zf = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }
    c.initial = !1;
    new(function (t) {
        ! function (t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), e && Of(t, e)
        }(a, t);
        var e, n, i, r = Nf(a);

        function a() {
            var t;
            return function (t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, a), (t = r.call(this, {
                renderers: {
                    home: Df,
                    default: uf
                },
                transitions: {
                    default: Lf
                }
            })), t
        }
        return e = a, (n = [{
            key: "navigate",
            value: function (t) {
                g.dom.lastClicked = t.currentTarget, kf(zf(a.prototype), "navigate", this).call(this, t)
            }
        }]) && If(e.prototype, n), i && If(e, i), a
    }(c.Core));
    "scrollRestoration" in history && (history.scrollRestoration = "manual")
}]);
